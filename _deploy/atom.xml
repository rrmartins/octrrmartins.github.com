<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2013-02-22T02:23:56-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[TRADUÇÃO] - Trabalhando com time zones em Ruby on Rails]]></title>
    <link href="http://rrmartins.github.com/blog/2012/12/02/traducao-trabalhando-com-time-zones-em-ruby-on-rails/"/>
    <updated>2012-12-02T09:37:00-02:00</updated>
    <id>http://rrmartins.github.com/blog/2012/12/02/traducao-trabalhando-com-time-zones-em-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>Conversando com o <a href="https://twitter.com/cjkihlbom">CJ Kihlbom</a>, um cara super gente boa. :) E ele liberou ai a tradução do post <a href="http://www.elabs.se/blog/36-working-with-time-zones-in-ruby-on-rails">Working with time zones in Ruby on Rails</a>.</p>

<hr />

<p>Tradução</p>

<hr />

<p><a href="http://api.rubyonrails.org">Rails</a> oferece ótimas ferramentas para trabalhar com fusos horários, mas ainda há um monte de coisas que
podem dar errado. Este blog tem como objetivo lançar alguma luz sobre essas pegadinhas e oferecer soluções
para os problemas mais comuns.</p>

<!--more-->


<p>O que, provavelmente, tem me enganado é que a maioria das vezes o fato de que os tolos do Rails acredita que
você tem tudo coberto o tempo todo <strong>(com o perdão do trocadilho)</strong>. Não me interpretem mal. Eu uso Rails
para fazer o trabalho, tanto para mim quanto possível. Mas eu aprendi da maneira mais difícil que eu não
posso fugir não sabendo quando e como o Rails está me ajudando. Outra pegadinha é o fato de que você tem mais
fusos horários em jogo do que você pode acreditar. Considere o seguinte: db, servidor, a máquina dev, sistema
configurado, o usuário específico configurado e o navegador.</p>

<h3>Configure sua app Rails</h3>

<p>Então, quais as ferramentas que temos à nossa disposição como desenvolvedores <a href="http://api.rubyonrails.org">Rails</a>? O mais importante é
a configuração <code>config.time_zone</code> em seu arquivo <code>config/application.rb</code>. ActiveRecord irá ajudá-lo a
converter de e para UTC (o que a documentação não explica) e o fuso horário de sua escolha. Isto significa
que, se tudo que você está fazendo é ter usuários postando varias vezes através de um formulário e utilizar
<code>Active Record</code> que ele persista que você é bom para ir.</p>

<h3>Processamento de informações de time</h3>

<p>Então, o que sobre o fato de fazer algo com a informação de <code>time</code> antes de aceitá-lo? Que é quando se torna
complicado.</p>

<h4>Parsing</h4>

<p>Ao analisar informações de <code>time</code> é importante nunca fazê-lo sem especificar o fuso horário. A melhor maneira
de o fazer é utilizar <code>Time.zone.parse</code> (que vai usar na zona de tempo especificado no <code>config.time_zone</code>) em
vez de apenas <code>Time.parse</code> (que vai usar a zona do computador).</p>

<h4>Trabalhar com atributos numéricos e ActiveRecord</h4>

<p>Chamadas de método como <code>2.hours.ago</code> usa o fuso horário que você configurou, portanto, use este se você
pode! A mesma coisa é verdade para atributos de tempo em modelos <code>ActiveRecord</code>.</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="o">.</span><span class="n">first</span>
</span><span class='line'><span class="n">post</span><span class="o">.</span><span class="n">published_at</span> <span class="c1">#=&gt; Thu, 22 Mar 2012 00:00:00 CDT -05:00</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ActiveRecord</code> busca a hora <code>UTC</code> do banco de dados e converte para o fuso horário em <code>config.time_zone</code> para
você.</p>

<h4>Date vs Time</h4>

<p><code>Time</code> tem informações de <code>Date</code>, mas <code>Date</code> não tem informação de <code>Time</code>. Mesmo que você não acha que se
importa, você pode perceber que você faz, mais cedo ou mais tarde. Seja seguro e use <code>Time</code> (ou <code>DateTime</code>,
se você precisa de suporte para <code>Times</code> muito longe do presente).</p>

<p>Mas vamos dizer que você está preso com uma <code>Date</code> que você precisa para tratar como um <code>Time</code>, pelo menos,
certifique-se de convertê-lo para o seu fuso horário configurado:</p>

<figure class='code'><figcaption><span>Date vs Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">from_now</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 22:04:47 JST +09:00</span>
</span><span class='line'><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">to_time_in_current_zone</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 00:00:00 JST +09:00</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Consultando</h4>

<p>Desde que Rails sabe que a sua informação de <code>Time</code> é armazenado como UTC no banco de dados que irá converter
a qualquer momento que você dá para o UTC.</p>

<figure class='code'><figcaption><span>Query</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Post</span><span class="o">.</span><span class="n">where</span> <span class="p">(</span><span class="o">[</span><span class="s2">&quot;posts.publised_at&gt;?&quot;</span><span class="p">,</span> <span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">now</span><span class="o">]</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Só não se esqueça de nunca construir a seqüência de consulta à mão e use sempre <code>Time.zone.now</code> como a base e
você deve ser seguro.</p>

<h3>Trabalhando com APIs</h3>

<h4>Fornecimento</h4>

<p>A construção de uma API web para o consumo de outros? Certifique-se sempre de enviar todos os dados de tempo
como <code>UTC</code> (e especificar que este é o caso).</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">iso8601</span> <span class="c1"># =&gt; &quot;2012-03-16T14: 55:33 Z&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Leia mais sobre por ISO8601 é aconselhável aqui: <a href="http://devblog.avdi.org/2009/10/25/iso8601-dates-in-ruby/">iso8601-dates-in-ruby</a></p>

<h4>Consumindo</h4>

<p>Quando você começa a informação do <code>Time</code> a partir de uma API externa que você não tem controle sobre o que
você simplesmente necessita de descobrir o formato e o fuso horário que é enviado a você. Porque
<code>Time.zone.parse</code> pode não funcionar com o formato que você recebe, pode precisar de usar:</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_string</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-%dT%H:%M:%S%z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">in_time_zone</span><span class="p">(</span><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Por que não há nenhum método <code>#strptime</code> em <code>Time.zone</code> quando há um <code>#parse</code>. No entanto, não se esqueça de
chamar <code>in_time_zone</code> (<code>Time.zone</code>) no seu resultado!</p>

<h3>Trabalhar com vários fusos horários do usuário</h3>

<p>Muitos sistemas necessita de suporte aos usuários para entrar e visualizar as informações de tempo em uma
variedade de zonas de tempo. Para conseguir isso, você precisa armazenar zona de cada usuário tempo
(provavelmente só um dos nomes de zona de tempo <code>String</code> encontrado no <code>rake time:zones:all</code>). Então, para
realmente usar esse fuso horário o padrão mais comum é simplesmente criar um método particular em sua
<code>ActionController</code> e executá-la antes como um filtro.</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">before_filter</span> <span class="ss">:set_time_zone</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">set_time_zone</span>
</span><span class='line'>  <span class="no">Time</span><span class="o">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">current_user</span><span class="o">.</span><span class="n">time_zone</span> <span class="k">if</span> <span class="n">current_user</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isso vai fazer a mesma coisa que <code>config.time_zone</code> mas em uma base por pedido. Eu ainda recomendo mudar o
<code>config.time_zone</code> padrão para um fuso horário que é um bom padrão para seus usuários.</p>

<h4>Testando</h4>

<p>Todos acima é algo que os testes devem pegar para você. O problema é que você como o usuário e seu
computador como o servidor de desenvolvimento, acontece a residir no mesmo fuso horário. Esse raramente é o
 caso, uma vez que você levar as coisas para a produção.</p>

<p>Highgroove liberado apenas <a href="https://github.com/highgroove/zonebie">Zonebie</a>, uma gem que o ajuda a lidar com isso. Eu não tive tempo de testá-lo
eu mesmo ainda, mas parece muito promissor. Se você achar que isso seja um exagero, pelo menos,
certifique-se de que seus testes executados com um conjunto <code>Time.zone</code> para outro fuso horário do que a sua
máquina de desenvolvimento está configurado!</p>

<h4>Bug no Time.zone.parse</h4>

<p>Jarkko Laine (<a href="https://twitter.com/#!/jarkko">@Jarkko</a>) apontou que não há atualmente um bug no <code>Rails</code> que pode fazer o
<code>Time.zone.parse</code> perder uma hora quando o tempo do sistema está em <code>DST</code> (<code>horário de verão</code>) e seu fuso
horário configurado não. Jarkko postou um problema no <code>Rails</code> rastreando o assunto e escreveu um patch para
corrigir o bug. Até que o patch foi aceito ou se você está rodando com versões mais antigas do <code>Rails</code> a
única forma segura de evitar este erro, quer seja um patches para <code>Rails</code> em seu aplicativo com correção
Jarkko’s ou uso:</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># use</span>
</span><span class='line'><span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TimeWithZone</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="kp">nil</span><span class="p">,</span> <span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="p">,</span> <span class="no">DateTime</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-25 03:29&quot;</span><span class="p">))</span>
</span><span class='line'><span class="c1"># =&gt; Sun, 25 Mar 2012 03:29:00 PDT -07:00</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># or if possible pass the time zone in the string</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-25 03:29 PDT&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; Sun, 25 Mar 2012 03:29:00 PDT -07:00</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># instead of</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-25 03:29&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; Sun, 25 Mar 2012 04:29:00 PDT -07:00</span>
</span></code></pre></td></tr></table></div></figure>


<p>Deve, contudo, ser mencionado que é muito raro que esta superfícies de bug e quando ele faz isso só pode
perder uma hora. Se você pode viver com o que você provavelmente faz melhor por apenas aguardando o patch
para ser aceito.</p>

<h3>Cheat Sheet</h3>

<h4>FAZER</h4>

<figure class='code'><figcaption><span>Date vs Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">2</span><span class="o">.</span><span class="n">hours</span><span class="o">.</span><span class="n">ago</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 14:02:42 CET +01:00</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">from_now</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 22:04:47 JST +09:00</span>
</span><span class='line'><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">to_time_in_current_zone</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 00:00:00 JST +09:00</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-02 16:05:37&quot;</span><span class="p">)</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 16:05:37 JST +09:00</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">now</span> <span class="c1"># =&gt; Sat, 03 Mar 2012 00:07:37 JST +09:00</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">today</span> <span class="c1"># If you really can&#39;t have a Time or DateTime for some reason</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">iso8601</span> <span class="c1"># &quot;When supliyng an API (you can actually skip .zone here, but I find it better to always use it, than miss it when it&#39;s needed)</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_string</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-%dT%H:%M:%S%z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">in_time_zone</span><span class="p">(</span><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="p">)</span> <span class="c1"># If you can&#39;t use parse</span>
</span></code></pre></td></tr></table></div></figure>


<h4>NÃO FAZER</h4>

<figure class='code'><figcaption><span>Date vs Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">now</span> <span class="c1"># =&gt; 2012-03-02 16:05:37 +0100</span>
</span><span class='line'><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">to_time</span> <span class="c1"># =&gt; 2012-03-02 00:00:00 +0100</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-02 16:05:37&quot;</span><span class="p">)</span> <span class="c1"># =&gt; 2012-03-02 16:05:37 +0100</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">now</span> <span class="c1"># =&gt; 2012-03-02 16:07:20 +0100</span>
</span><span class='line'><span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="c1"># This could be yesterday or tomorrow depending on the machine&#39;s time zone!</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_string</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-%dT%H:%M:%S%z&#39;</span><span class="p">)</span> <span class="c1"># You won&#39;t have the time in your configured time zone!</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Epílogo</h3>

<p>Espero que você tenha aprendido alguma coisa com este post. Tenho certeza que fiz ao escrevê-lo! Se você tem
algum comentário sobre como ele pode ser melhorada, ou se você encontrar algum erro, por favor me avise por
postar um comentário abaixo!</p>

<hr />

<p>Agradeço ao amigo <a href="https://twitter.com/cjkihlbom">CJ Kihlbom</a>, abraços amigo&#8230; :D</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Teste salva sua carne]]></title>
    <link href="http://rrmartins.github.com/blog/2012/11/04/teste-salva-sua-carne/"/>
    <updated>2012-11-04T09:30:00-02:00</updated>
    <id>http://rrmartins.github.com/blog/2012/11/04/teste-salva-sua-carne</id>
    <content type="html"><![CDATA[<p>Galera estou lendo mais um livro, e vou passar para vocês um textículo do inicio do <a href="http://www.amazon.com/Rails-3-Action-Ryan-Bigg/dp/1935182277">Rails 3 in Action</a>.</p>

<p>Lendo o capitulo 1, ele deixou uma pergunta no ar: como você faz aplicações Rails sustentável?</p>

<p>A resposta é que você escreve testes automatizados para a aplicação como você desenvolve, e você escreve isso <strong>o tempo todo</strong>.</p>

<!-- more -->


<p>Ao escrever testes automatizados para a sua aplicação, você pode rapidamente assegurar que o aplicativo está funcionando
como deveria. Se você não escrever testes, a sua alternativa seria a de verificar toda a aplicação manualmente, o que é
demorado e propício a erros. <strong>Teste automatizado economiza uma tonelada de tempo, a longo prazo e leva a menos bugs.</strong> Os
seres humanos cometem erros; programas (se codificado corretamente) não.</p>

<h2>Teste e desenvolvimento orientado a comportamento</h2>

<p>No mundo <code>Ruby</code> uma enorme ênfase é colocada em teste, especificamente  desenvolvimento orientado a testes (Test-driven
 development - TDD) e desenvolvimento de comportamentos (Behavior-Driven Development - BDD).</p>

<p>Ao aprender técnicas de teste bem como agora, você tem um caminho sólido para se certificar que nada esta quebrado quando
você começa a escrever sua primeira aplicação real Rails. Se você não testar, não há como dizer o que poderia dar errado
seu código.</p>

<p>TDD é uma metodologia que consiste em escrever um caso de teste falho primeiro (geralmente usando uma testar ferramenta
como <code>Test::Unit</code>), em seguida, escrever o código para fazer o teste passar e, finalmente, refatorar o código. Este
processo é comumente chamado de <code>vermelho-verde-refatorar</code>( <code>red-green-refactor</code> ). As razões para desenvolver código desta
forma são duas. Primeiro, faz você considera como o código deve ser executado antes de ser usado por qualquer pessoa. Em
segundo lugar, crie um teste automatizado, você pode executar quantas vezes você quiser para garantir que o seu código ainda
está trabalhando como pretendido.</p>

<p>BDD é uma metodologia baseada em TDD. Você escreve um teste automatizado para verificar a interação entre as diferentes
partes da base de código em vez de testar que cada parte funciona de forma independente.</p>

<p>As duas ferramentas são usadas para o BDD são (RSpec)[http://rspec.info/] e (Cucumber)[http://cukes.info/].</p>

<h2>Test-Driven Development</h2>

<p>Uma resposta enigmática mas verdadeira para a pergunta &#8220;Por que eu deveria testar?&#8221; é &#8220;porque você é humano.&#8221;. Os seres
humanos - a grande maioria deste livro - comete erros. É uma de nossas favoritas maneiras de aprender. Porque os
seres-humanos cometem erros, ter uma ferramenta para informar quando eles fazem um erro é útil, não é? Teste automatizado
fornece uma rápida segurança para informar aos desenvolvedores quando eles cometem erros. Por eles, é claro, queremos dizer
que você. Nós queremos que você faça poucos erros quanto possível. Queremos que salvar sua vida!</p>

<p>TDD e BDD também dar-lhe tempo para pensar nas suas decisões antes de escrever qualquer código. Escrevendo primeiro teste
para a implementação, você é (ou, pelo menos, você deve ser) levado a pensar através da implementação: o código que você
vai escrever depois do teste e como você vai fazer para o teste passar. Se você encontrar um teste difícil de escrever,
então talvez a implementação pode ser melhorada. Infelizmente, não há nenhuma maneira clara de quantificar a dificuldade de
escrever um teste e trabalhar com ele para além de consultar outras pessoas que estão familiarizadas com o processo.</p>

<p>Uma vez que o teste é implementado, você deve ir escrever algum código que o seu teste pode passar. Se você está
trabalhando escrevendo o código primeiro e depois os testes para pegar um bug da implementação, é geralmente melhor
repensar o teste e desfazer sua implementação.</p>

<p><strong>Primeiro teste, código mais tarde.</strong></p>

<p>Até mais amigos!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Threads e Concorrência - Exemplos de Threads - Part IV - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/11/04/threads-e-concorrencia-exemplos-de-threads-part-iv-number-ruby-1-dot-9/"/>
    <updated>2012-11-04T09:20:00-02:00</updated>
    <id>http://rrmartins.github.com/blog/2012/11/04/threads-e-concorrencia-exemplos-de-threads-part-iv-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Exemplos de Threads</strong>&#8230;</p>

<h4>Exemplos de Threads</h4>

<p>Agora que já passamos alguns post falando do modelo <code>Thread</code> e da API de <code>Thread</code> em Ruby, vamos dar uma olhada em alguns
exemplos reais de vários códigos de <code>threads</code>.</p>

<!--more-->


<h3>Leitura de arquivos simultaneamente</h3>

<p>O uso mais comum de <code>threads</code> de Ruby é em programas que são IO. Eles permitem que os programas mantenham ocupado até
mesmo enquanto espera por alguma entrada do usuário, o sistema de arquivos, ou da rede. A seguir de código, por exemplo,
define um método <code>conread</code> (para leitura simultânea) que leva uma série de nomes de arquivos e retorna um mapa de <code>hash</code>
com esses nomes para o conteúdo desses arquivos. Ele usa <code>thread</code> para ler esses arquivos ao mesmo tempo, e é realmente
destinado a ser utilizado com o módulo <code>open-uri</code>, que permite que as URL&#8217;s <code>HTTP</code> e <code>FTP</code> possam ser abertas com
<code>Kernel.open</code> e ler como se fossem arquivos:</p>

<figure class='code'><figcaption><span>Lendo arquivos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ler arquivos simultaneamente. Use com o módulo &quot;open-uri&quot; para buscar URLs.</span>
</span><span class='line'><span class="c1"># Passe uma matriz de nomes de arquivos. Retorna um mapa de nomes de arquivos de hash para o conteúdo.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">conread</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>
</span><span class='line'>  <span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>             <span class="c1"># hash vazio de resultados</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># Crie uma linha para cada arquivo</span>
</span><span class='line'><span class="err">  </span><span class="n">filenames</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">filename</span><span class="o">|</span>      <span class="c1"># Para cada arquivo chamado</span>
</span><span class='line'><span class="err">    </span><span class="n">h</span><span class="o">[</span><span class="n">filename</span><span class="o">]</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>     <span class="c1"># Criar um fio, mapa para filename</span>
</span><span class='line'><span class="err">      </span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span> <span class="p">}</span>  <span class="c1"># Abra e leia o arquivo</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>                           <span class="c1"># valor da linha é o conteúdo do arquivo</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Percorre o hash, à espera de cada thread para completar.</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Substitua a thread no hash com o seu valor (o conteúdo de arquivo)</span>
</span><span class='line'>  <span class="n">h</span><span class="o">.</span><span class="n">each_pair</span> <span class="k">do</span> <span class="o">|</span><span class="n">filename</span><span class="p">,</span> <span class="n">thread</span><span class="o">|</span>
</span><span class='line'>    <span class="k">begin</span>
</span><span class='line'>      <span class="n">h</span><span class="o">[</span><span class="n">filename</span><span class="o">]</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">value</span>    <span class="c1"># Mapa de nomes ao conteúdo do arquivo</span>
</span><span class='line'>    <span class="k">rescue</span>
</span><span class='line'>      <span class="n">h</span><span class="o">[</span><span class="n">filename</span><span class="o">]</span> <span class="o">=</span> <span class="vg">$!</span>              <span class="c1"># Ou a exceção levantada</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Servidor A Multithreads</h3>

<p>Outra, quase canônico caso, o uso de <code>threads</code> é para escrever servidores que podem comunicar com mais do que um cliente
de cada vez. Vimos como fazer isto utilizando multiplexagem com Kernel.select, mas um pouco mais simples (Embora
possivelmente menos escalável) solução usa <code>threads</code>:</p>

<figure class='code'><figcaption><span>Servidor a Multithreads</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;socket&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Este método espera um socket ligado a um cliente.</span>
</span><span class='line'><span class="c1"># Ele lê as linhas do cliente, inverte-los e envia-los de volta.</span>
</span><span class='line'><span class="c1"># Múltiplas Threads podem executar este método, ao mesmo tempo.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">handle_client</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="k">while</span> <span class="kp">true</span>
</span><span class='line'>    <span class="n">input</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">gets</span><span class="o">.</span><span class="n">chop</span>     <span class="c1"># Ler uma linha de entrada do cliente</span>
</span><span class='line'>    <span class="k">break</span> <span class="k">if</span> <span class="o">!</span><span class="n">input</span>         <span class="c1"># sai se tem muitas entradas</span>
</span><span class='line'>    <span class="k">break</span> <span class="k">if</span> <span class="n">input</span><span class="o">==</span><span class="s2">&quot;quit&quot;</span>  <span class="c1"># ou se o cliente pede</span>
</span><span class='line'>    <span class="n">c</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="n">input</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span>   <span class="c1"># Caso contrário, responde ao cliente.</span>
</span><span class='line'>    <span class="n">c</span><span class="o">.</span><span class="n">flush</span>                 <span class="c1"># Força a saída para fora</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">c</span><span class="o">.</span><span class="n">close</span>                   <span class="c1"># Fecha o socket cliente</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">server</span> <span class="o">=</span> <span class="no">TCPServer</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="c1"># Ouve na porta 2000</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="kp">true</span>                    <span class="c1"># Laço de servidores para sempre</span>
</span><span class='line'>  <span class="n">client</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">accept</span>      <span class="c1"># Espere um cliente para conectar</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">client</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="c1"># Inicia uma nova thread</span>
</span><span class='line'>    <span class="n">handle_client</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># E Lida com o clinete nessa Thread</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Iteradores simultâneas</h3>

<p>Embora tarefas IO são o caso de uso típico para <code>threads</code> de Ruby, eles não se restringem aos que usam. O código a seguir
adiciona um método <code>conmap</code> (por mapa concorrente) para o modulo <code>Enumerável</code>. Ele funciona como mapa, mas processa cada
elemento da matriz de entrada com uma distinta <code>Thread</code>:</p>

<figure class='code'><figcaption><span>Iterador Simultâneo</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Enumerable</span>           <span class="c1"># Abre o módulo Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">conmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>        <span class="c1"># Define um novo método que espera um block</span>
</span><span class='line'>    <span class="n">threads</span> <span class="o">=</span> <span class="o">[]</span>            <span class="c1"># Começa com uma matriz vazia de threads</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>     <span class="c1"># Para cada item enumerable</span>
</span><span class='line'>      <span class="c1"># Chama o bloco em uma nova Thread, e lembra da Thread</span>
</span><span class='line'>      <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="c1"># Agora mapea o conjunto de Threads para os seus valores</span>
</span><span class='line'>    <span class="n">threads</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="p">}</span> <span class="c1"># E retorna a matriz de valores</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>E aqui está uma versão concorrente similar do iterador de cada um:</p>

<figure class='code'><figcaption><span>Módulo Enumerable</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">concurrently</span>
</span><span class='line'>    <span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="k">yield</span> <span class="n">item</span> <span class="p">}}</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">join</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>O código é sucinto e desafiador: se você pode fazer sentido, você está bem em seu caminho para o domínio da sintaxe de
Ruby e iteradores Ruby.</p>

<p>Lembre-se que no Ruby 1.9, iteradores padrões que não são passado um bloco retorna um objeto enumerador. Isto significa
que, dado o método <code>concurrently</code> definido mais cedo e um objeto <code>Hash h</code>, podemos escrever:</p>

<figure class='code'><figcaption><span>Método Concurrently</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">h</span><span class="o">.</span><span class="n">each_pair</span><span class="o">.</span><span class="n">concurrently</span> <span class="p">{</span><span class="o">|*</span><span class="n">pair</span><span class="o">|</span> <span class="n">process</span><span class="p">(</span><span class="n">pair</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Até o proximo amigos!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Threads e Concorrência - Escalando Threads - Part III - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/10/28/threads-e-concorrencia-escalando-threads-part-iii-number-ruby-1-dot-9/"/>
    <updated>2012-10-28T15:04:00-02:00</updated>
    <id>http://rrmartins.github.com/blog/2012/10/28/threads-e-concorrencia-escalando-threads-part-iii-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Escalando Threads</strong>&#8230;</p>

<h2>Threads e Concorrência</h2>

<h3>Escalando Threads</h3>

<!-- more -->


<p>Intérpretes do Ruby(irb), muitas vezes têm mais <code>threads</code> para executar do que há CPU tem disponível para executá-los. Quando
o processamento paralelo verdadeiro não é possível, é simulado através da partilha de uma CPU entre <code>threads</code>. O processo para
a partilha de uma CPU entre as <code>threads</code> é chamado de escalonamento de <code>threads</code>. Dependendo da implementação e plataforma,
agendamento de <code>threads</code> pode ser feito pelo Intérprete do Ruby(irb), ou pode ser tratado pelo sistema operacional.</p>

<h4>Prioridades da Thread</h4>

<p>O primeiro fator que afeta o agendamento de <code>threads</code> é prioridades de <code>thread</code>: com a alta prioridade da <code>thread</code> são
agendadas antes de baixa prioridade de <code>thread</code>. Mais precisamente, uma <code>thread</code> só vai ficar o tempo de CPU, se não houver
maior prioridade de <code>thread</code> aguardando para ser executada.</p>

<p>Definir e consultar a prioridade de um objeto Ruby <code>Thread</code> com <code>priority=</code> e <code>priority</code>. Note-se que não há nenhuma maneira
de definir a prioridade de uma <code>thread</code> antes que ela comece a funcionar. Uma <code>thread</code> pode, no entanto, aumentar ou diminuir
sua própria prioridade como a primeira ação que toma.</p>

<p>Uma <code>thread</code> recém-criada começa com a mesma prioridade que a <code>thread</code> que a criou. A <code>thread</code> principal começa na prioridade
 0.</p>

<p>Como muitos aspectos de <code>threading</code>, prioridades de <code>threads</code> são depende da implementação do <code>Ruby</code> e do subjacente sistema
operacional. No Linux, por exemplo, <code>threads</code> não privilegiadas não pode ter as suas prioridades levantada ou abaixada. Assim,
no Ruby 1.9 (que usa <code>threads</code> nativas) no <code>Linux</code>, a definição de prioridades de <code>Thread</code> é ignorada.</p>

<h4>Aquisição de Thread e Thread.pass</h4>

<p>Quando várias <code>Threads</code> com a mesma prioridade precisam compartilhar a CPU, cabe a <code>thread</code> programada para decidir quando e
por quanto tempo, cada <code>thread</code> é executada. Alguns escalonadores são antecipadas, o que significa que elas permitem a <code>thread</code>
a ser executada apenas por um determinado período de tempo antes de permitir outra <code>thread</code> da mesma prioridade para ser
executada. Outros programadores não são preempção: uma vez que uma <code>thread</code> começa a correr, ela continua funcionando a menos
que durma, blocos para I/O, ou uma <code>thread</code> de maior prioridade acorda.</p>

<p>Se uma longa linha de computação liga (ou seja, aquela que nunca faz bloqueio para I/O) está em execução em um agendador
não preemptivo, ela vai &#8220;morrer de fome&#8221; as outras <code>threads</code> com a mesma prioridade, e elas nunca tem a chance de correr.
Para evitar esse problema, de longa duração <code>compute-bound</code> <code>threads</code> devem chamar periodicamente <code>Thread.pass</code> para pedir o
programador para produzir a CPU para outra <code>thread</code>.</p>

<p>Até a proxima amigos! :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Threads e Concorrência - Threads e Variáveis - Part II - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/10/28/threads-e-concorrencia-threads-e-variaveis-part-ii-number-ruby-1-dot-9/"/>
    <updated>2012-10-28T14:53:00-02:00</updated>
    <id>http://rrmartins.github.com/blog/2012/10/28/threads-e-concorrencia-threads-e-variaveis-part-ii-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Threads e Variáveis</strong>&#8230;</p>

<h2>Threads e Concorrência</h2>

<h3>Threads e Variáveis</h3>

<!-- more -->


<p>Uma das características-chave de <code>Thread</code> é que elas podem compartilhar o acesso a variáveis. Como <code>Threads</code> são definidas
por blocos, eles têm acesso a qualquer que seja variáveis ​​(variáveis ​​locais, variáveis ​​de instância, variáveis ​​globais e
 assim por diante) estão no escopo do bloco:</p>

<figure class='code'><figcaption><span>Thread e Variavel</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Esta Thread pode consultar e definir a variável x</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Esta Thread e também consulta e seta x</span>
</span><span class='line'><span class="err">  </span><span class="c1"># E pode consultar e definir T1 e T2 também.</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Quando dois ou mais <code>Thread</code> de ler e escrever as mesmas variáveis ao mesmo tempo, elas devem tomar cuidado para que elas o
fazem corretamente. Nós vamos ter mais a dizer sobre isso quando consideramos a sincronização de <code>threads</code> abaixo.</p>

<h4>Thread-privadas variáveis</h4>

<p>Variáveis ​​definidas dentro do bloco de uma <code>thread</code> são particulares para essa <code>thread</code> e não são visíveis para qualquer
outra <code>thread</code>. Isto é simplesmente consequência de regras de variáveis de escopo ​​Ruby.</p>

<p>Muitas vezes queremos uma <code>Thread</code> tenha sua própria cópia privada de uma variável de modo a que o seu comportamento não se
altere se o valor do referido mude de variáveis. Considere o seguinte código, que tenta criar três tópicos que impressão (
respectivamente) os números 1, 2 e 3:</p>

<figure class='code'><figcaption><span>Threads Privadas</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="n">n</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Em algumas circunstâncias, em algumas implementações, este código pode funcionar como o esperado e imprimir os números 1, 2 e
3. Em outras circunstâncias, ou em outras implementações, talvez não. É perfeitamente possível (se tópicos recentemente
criados não executa de imediato) para o código imprimir 4, 4, e 4, por exemplo. Cada thread lê uma cópia compartilhada da
variável n, e o valor ds mudanças de variáveis ​​como o loop é executado. O valor impresso pela <code>thread</code> depende de quando esse
segmento é executado em relação para a thread pai.</p>

<p>Para resolver este problema, passamos o valor atual de n para o método <code>Thread.new</code>, e atribuimos o atual valor da variável a
um parâmetro de bloco. Parâmetros de bloco são privados para o bloco, e este valor particular não é partilhado entre tópicos:</p>

<figure class='code'><figcaption><span>Threads Privadas</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span>
</span><span class='line'>  <span class="c1"># Obtem uma cópia privada do valor atual de n em x</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que temos uma outra forma de resolver este problema é a utilização de um iterador em vez de um loop <code>while</code>. Neste
caso, o valor de <code>n</code> é modificado para particular para o bloco externo e nunca durante a execução desse bloco:</p>

<figure class='code'><figcaption><span>Thread Privada com Interator</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span> <span class="n">n</span> <span class="o">|</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="nb">puts</span> <span class="n">n</span><span class="p">}}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Variáveis ​​de Threads locais</h4>

<p>Algumas das variáveis especiais globais de Ruby são <code>thread</code> local: elas podem ter valores diferentes em <code>threads</code> diferentes.
<code>$SAFE</code> e <code>$~</code> são exemplos. Isto significa que, se dois <code>thread</code> estão realizando conconrrencia de expressão regular ao mesmo
tempo, eles vão ver diferentes valores de <code>$~</code>, e a realização de um jogo em um fio não irá interferir com os resultados de
um jogo executado na outra discussão.</p>

<p>A classe <code>Thread</code> provê <code>hash-like</code> como o comportamento. Ele define métodos de instância <code>[]</code> e <code>[]=</code> que permitem associar
valores arbitrários com qualquer símbolo. (Se você usar uma cadeia de caracteres em vez disso, ele será convertido em um
símbolo. Ao contrário <code>hashs</code> de verdade, a classe <code>Thread</code> só permite símbolos como chaves.) Os valores associados a estes
símbolos comportam-se como variáveis ​​de <code>Thread</code> locais. Eles não são privados como variáveis de block ​​locais porque qualquer
<code>Thread</code> pode pesquisar um valor em qualquer outra <code>Thread</code>. Mas eles não são variáveis partilhadas, uma vez que cada Thread
pode ter a sua própria cópia.</p>

<p>Como exemplo, suponha que nós criamos <code>thread</code> para download de arquivos de um servidor web. A <code>Thread</code> principal pode querer
monitorar o progresso do download. Para permitir isso, cada <code>Thread</code> pode fazer o seguinte:</p>

<figure class='code'><figcaption><span>Thread de progresso</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="o">[</span><span class="ss">:progress</span><span class="o">]</span> <span class="o">=</span> <span class="n">bytes_received</span>
</span></code></pre></td></tr></table></div></figure>


<p>A <code>Thread</code> principal poderia, então, determinar o total de bytes baixado com um código como este:</p>

<figure class='code'><figcaption><span>Thread de progresso</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">download_threads</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">t</span><span class="o">[</span><span class="ss">:progress</span><span class="o">]</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Junto com <code>[]</code> e <code>[]=</code>, <code>Thread</code> também define um método <code>key?</code> para testar se uma determinada chave existe para uma discussão
. Os métodos <code>keys</code> retorna uma matriz de símbolos que representam as chaves definidas para a <code>Thread</code>. Este código pode ser
melhor escrito como se segue, de modo que ela trabalhe de tópicos que ainda não começou a correr e não tenha definido a chave
:progress ainda:</p>

<figure class='code'><figcaption><span>Thread de progresso</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">download_threads</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">t</span><span class="o">[</span><span class="ss">:progress</span><span class="o">]</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">key?</span><span class="p">(</span><span class="ss">:progress</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Até a proxima galera! :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Threads e Concorrência - Part I - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/10/28/threads-e-concorrencia-part-i-number-ruby-1-dot-9/"/>
    <updated>2012-10-28T14:26:00-02:00</updated>
    <id>http://rrmartins.github.com/blog/2012/10/28/threads-e-concorrencia-part-i-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Thread Lifecycle</strong>&#8230;</p>

<h2>Threads e Concorrência</h2>

<!-- more -->


<p>Programas tradicionais têm uma única &#8220;thread de execução&#8221;: as declarações ou instruções que compõem o programa são executadas
sequencialmente até que o programa termina. Um programa multithread tem mais de uma <code>thread</code> de execução. Dentro de cada <code>
thread</code>, os comandos são executados sequencialmente, mas as próprias <code>threads</code> podem ser executadas em paralelo em uma
CPU multicore, por exemplo. Frequentemente (em um núcleo único, uma única CPU, por exemplo), várias <code>Threads</code> não são na
realidade executadas em paralelo, mas o paralelismo é simulada intercalando a execução das <code>threads</code>.</p>

<p>Programas como o software de processamento de imagem que fazem um monte de cálculos estão a ser dito <code>compute-bound</code>. Eles só
podem beneficiar de multithreading, se há realmente múltiplas CPUs para executar os cálculos em paralelo. A maioria dos
programas não são totalmente vinculados a computação, no entanto. Muitos, como navegadores web, passam a maior parte de seu
tempo de espera para a rede ou arquivo <code>I/O</code>. Programas como estes estão a ser dito <code>IO-bound</code>. Programas <code>IO-bound</code> pode ser
útil mesmo quando várias <code>threads</code> há apenas uma única CPU disponível. Um navegador pode tornar uma imagem em uma <code>thread</code>
enquanto outra <code>thread</code> está à espera para a próxima imagem para ser baixada da rede.</p>

<p>Ruby faz com que seja fácil de escrever programas <code>multi-threaded</code> com a <code>Class Thread</code>. Para iniciar uma nova <code>thread</code>,
apenas associa um bloco com uma chamada para <code>Thread.new</code>. Uma nova <code>thread</code> será criada para executar o código no bloco, e a
<code>thread</code> original retornará do <code>Thread.new</code> imediatamente e continuar a execução com a afirmação seguinte:</p>

<figure class='code'><figcaption><span>Iniciando um thread</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Thread #1 está sendo executado aqui</span>
</span><span class='line'><span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Thread #2 executa esse código</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1"># Thread #1 executa esse código</span>
</span></code></pre></td></tr></table></div></figure>


<p>Vamos começar nossa cobertura de <code>threads</code> explicando o modelo <code>Thread</code> de Ruby e API em alguns detalhes. Estas seções
introdutórias explicam as coisas como ciclo de vida da <code>thread</code>, agendamento de threads, e os estados da <code>thread</code>. Com que o
material introdutório como pré-requisito, passamos a apresentar código de exemplo e para cobrir <code>threads</code> avançadas como
sincronização de <code>threads</code>.</p>

<p>Finalmente, é importante notar que os programas de Ruby também pode alcançar simultaneidade ao nível do processo de sistema
operacional executando executáveis externos ​​ou novas cópias de bifurcação do interpretador Ruby. Fazendo isto é dependem do
sistema operacional. Para mais informações, use <code>ri</code> para procurar os métodos <code>Kernel.system</code>, <code>Kernel.exec</code>, <code>Kernel.fork</code>,
<code>IO.popen</code>, e o módulo <code>Process</code>.</p>

<h3>Lifecycle Tópico</h3>

<p>Como descrito acima, novas <code>threads</code> são criados com <code>Thread.new</code>. Você também pode usar os sinónimos <code>Thread.start</code> e
<code>Thread.fork</code>. Não há necessidade de se iniciar uma <code>thread</code> depois de criá-la, ele começa a ser executado automaticamente
quando os recursos da CPU estejam disponíveis. O valor da invocação <code>Thread.new</code> é um objeto <code>Thread</code>. A classe <code>Thread</code>
define um número de métodos para consultar e manipular a <code>thread</code> enquanto ela está sendo executada.</p>

<p>Uma <code>thread</code> é executa o código do bloco associado à chamada para <code>Thread.new</code> e depois pára execução. O valor da última
expressão em que o bloco é o valor da <code>thread</code>, e pode ser obtido chamando o método do valor do objeto <code>Thread</code>. Se a <code>thread</code>
foi executado para conclusão, então o valor retorna o valor da <code>thread</code> de imediato. Caso contrário, os blocos de valor do
método e não retorna até que a <code>threado</code> for concluída.</p>

<p>O método de classe <code>Thread.current</code> retorna o objeto <code>Thread</code> que representa o atual <code>thread</code>. Isso permite que as <code>threads</code>
manipulam-se. O método da classe <code>Thread.main</code> retorna o objeto <code>Thread</code> que representa a principal <code>thread</code>, este é a
<code>thread</code> inicial de execução que começou quando o Programa Ruby foi iniciado.</p>

<h4>A Thread principal</h4>

<p>A <code>Thread</code> principal é especial: o interpretador Ruby pára de correr quando a <code>thread</code> principal é feita. Ele faz isso mesmo
que a <code>thread</code> principal criou outras <code>threads</code> que ainda estão em execução. Você deve garantir, portanto, que a sua princial
<code>thread</code> não termina enquanto outras <code>threads</code> ainda estão em execução. Uma maneira de fazer isso é escrever sua <code>thread</code>
principal sob a forma de um <code>loop</code> infinito. Outra maneira é explicitamente esperar para as <code>threads</code> ser concluída. Já
mencionamos que você pode chamar o método <code>value</code> de uma <code>thread</code> que espera que ela termine. Se você não se importa com o
valor de suas <code>threads</code>, você pode esperar com o método de instancia <code>join</code>.</p>

<p>O seguinte método espera até que todas as linhas, com excepção da <code>thread</code> principal e a <code>thread</code> atual (que pode ser a mesma
coisa), ter saído:</p>

<figure class='code'><figcaption><span>Thread Principal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">join_all</span>
</span><span class='line'>  <span class="n">main</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">main</span>        <span class="c1"># Thread Principal</span>
</span><span class='line'>  <span class="n">current</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">current</span>  <span class="c1"># Thread atual</span>
</span><span class='line'>  <span class="n">all</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">list</span>         <span class="c1"># Todas as threads ainda em execução</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Agora chama join em cada thread</span>
</span><span class='line'>  <span class="n">all</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">join</span> <span class="k">unless</span> <span class="n">t</span> <span class="o">==</span> <span class="n">current</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">==</span> <span class="n">main</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Threads e exceções não tratadas</h4>

<p>Se uma exceção é levantada na <code>thread</code> principal, e não é tratada em qualquer lugar, o interpretador Ruby imprime uma
mensagem e sai. Em outras <code>threads</code> que a <code>thread</code> principal, exceções não tratadas causam a <code>thread</code> para parar de executar.
Por defeito, no entanto, isto não faz o intérprete para imprimir uma mensagem ou saída. Se uma <code>thread</code> <code>t</code> sai por causa de
uma exceção não tratada, e outra <code>thread</code> de chamadas <code>t.join</code> ou <code>t.value</code>, então a exceção que ocorreu em <code>t</code> é levantada
na <code>thread</code> de <code>s</code>.</p>

<p>Se você gostaria de qualquer exceção não tratada em qualquer <code>thread</code> para fazer com que o intérprete saia, use o método de
classe <code>Thread.abort_on_exception=</code>:</p>

<figure class='code'><figcaption><span>Thread</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Thread</span><span class="o">.</span><span class="n">abort_on_exception</span> <span class="o">=</span> <span class="kp">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se você quer uma exceção não tratada em uma <code>thread</code> específica faz com que o intérprete saia, utilizando o método de
exemplo, através do mesmo nome:</p>

<figure class='code'><figcaption><span>Thread abort</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="n">abort_on_exception</span> <span class="o">=</span> <span class="kp">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos.. até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Encadeamento de Alias - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/09/18/encadeamento-de-alias-number-ruby-1-dot-9/"/>
    <updated>2012-09-18T08:38:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/09/18/encadeamento-de-alias-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Encadeamento de Alias</b>&#8230;</p>




<h1>Encadeamento de Alias</h1>


<p>Como já visto, metaprogramação em Ruby muitas vezes envolve a dinâmica definição de métodos. Assim como comum é a dinâmica modificação de métodos.
Métodos são modificados com uma técnica que chamaremos de encadeamento de alias. Ele funciona assim:</p>

<!-- more -->


<pre><code>* Primeiro, criar um alias para o método a ser modificado. este apelido fornece um nome para 
a versão não modificada do método.

* Em seguida, definem uma nova versão do método. Esta nova versão deve chamar a versão não modificada
através dos alias, mas pode adicionar qualquer funcionalidade que for necessário, antes e depois de que
faz isso.
</code></pre>

<p>Note-se que estes passos podem ser aplicados repetidamente (desde que um alias diferente é usado de cada vez), criando uma cadeia de métodos e aliases.</p>

<p>Este post inclui três exemplos de encadeamento de alias. O primeiro realiza o encadeamento de apelido estaticamente, ou seja, usando pseudônimo
regulares e declarações <code>def</code>. Os segundo e terceiro exemplos são mais dinâmicos; eles são apelidos que acorrentam métodos arbitrariamente nomeados
utilizando <code>alias_method</code>, <code>define_method</code> e <code>class_eval</code>.</p>

<h3>Rastreando Arquivos Carregados e Classes Definidas</h3>


<p>O <code>Exemplo 1-1</code> é um código que mantém o controle de todos os ficheiros carregados e todas as classes definidas num programa. Quando o programa sai,
ele imprime um relatório. Você pode usar este código para &#8220;instrumento&#8221; de um existente programa para que você entenda melhor o que está fazendo. Uma
maneira de usar este código é inserir esta linha no começo do programa:</p>

<figure class='code'><figcaption><span>classtrace</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;classtrace&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Uma solução mais fácil, no entanto, é usar a opção -r para o seu intérprete Ruby(<code>irb</code>):</p>

<figure class='code'><figcaption><span>Opção -r</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">ruby</span> <span class="o">-</span><span class="n">rclasstrace</span> <span class="n">my_program</span><span class="o">.</span><span class="n">rb</span>  <span class="o">--</span><span class="n">traceout</span> <span class="sr">/tmp/</span><span class="n">trace</span>
</span></code></pre></td></tr></table></div></figure>


<p>A opção -r carrega a biblioteca especificado antes de começar a executar o programa.</p>

<p>O <code>Exemplo 1-1</code> usa apelido de encadeamento estático para rastrear todas as chamadas dos métodos <code>Kernel.require</code> e <code>Kernel.load</code>. Ele define um hook
<code>Object.inherited</code> para rastrear as definições de novas classes. E ele usa <code>Kernel.at_exit</code> para executar um bloco de código quando o programa termina.
Além dos encadeamentos de alias <code>require</code> e <code>load</code> e defini <code>Object.inherited</code>, a única modificação do espaço global feita por este código é a
definição de um módulo chamado <code>ClassTrace</code>. Todo o estado necessário para o rastreio é armazenado em constantes dentro deste módulo, de modo que não
poluem o <code>namespace</code> com variáveis globais.</p>

<figure class='code'><figcaption><span>Exemplo 1-1. Rastreando Arquivos Carregados e Classes Definidas</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Definimos este módulo para manter o estado global do require, de modo que</span>
</span><span class='line'><span class="c1"># Nós não alteramos o espaço global mais do que o necessário.</span>
</span><span class='line'><span class="k">module</span> <span class="nn">ClassTrace</span>
</span><span class='line'><span class="err">  </span> <span class="c1"># Esta matriz mantém a nossa lista de arquivos carregados e classes definidas.</span>
</span><span class='line'><span class="err">  </span> <span class="c1"># Cada elemento é um subarray segurando a classe definida ou o</span>
</span><span class='line'><span class="err">  </span> <span class="c1"># Arquivo carregado e o quadro de pilha onde ele foi definido ou carregado.</span>
</span><span class='line'><span class="err">  </span> <span class="n">T</span> <span class="o">=</span> <span class="o">[]</span>  <span class="c1"># Array para armazenar os arquivos carregados</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span> <span class="c1"># Agora defini a constante OUT para especificar onde saída do rastreamento vai.</span>
</span><span class='line'><span class="err">  </span> <span class="c1"># O padrão é stderr, mas também pode vir a partir de argumentos na linha de comando</span>
</span><span class='line'><span class="err">  </span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;--traceout&quot;</span><span class="p">)</span>    <span class="c1"># Se existe argumento</span>
</span><span class='line'><span class="err">    </span> <span class="no">OUT</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>  <span class="c1"># Abre o arquivo especificado</span>
</span><span class='line'><span class="err">    </span> <span class="no">ARGV</span><span class="o">[</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="kp">nil</span>                  <span class="c1"># E remova os argumentos</span>
</span><span class='line'><span class="err">  </span> <span class="k">else</span>
</span><span class='line'><span class="err">    </span> <span class="no">OUT</span> <span class="o">=</span> <span class="no">STDERR</span>                     <span class="c1"># Caso contrário, o padrão para STDERR</span>
</span><span class='line'><span class="err">  </span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Passo 1 encadeamento Alias: definir aliases para os métodos originais</span>
</span><span class='line'><span class="k">alias</span> <span class="n">original_require</span> <span class="nb">require</span>
</span><span class='line'><span class="k">alias</span> <span class="n">original_load</span> <span class="nb">load</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Passo 2 encadeamento Alias 2: definir novas versões dos métodos</span>
</span><span class='line'><span class="k">def</span> <span class="nf">require</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">file</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>     <span class="c1"># Lembre-se de onde que estava carregado</span>
</span><span class='line'><span class="err">  </span><span class="n">original_require</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>                <span class="c1"># Chame o método original</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="err"> </span> <span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>  <span class="c1"># Lembre-se de onde que estava carregado</span>
</span><span class='line'><span class="err"> </span> <span class="n">original_load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>                  <span class="c1"># Chame o método original</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Este método hook é chamado de cada vez que uma nova classe é definida</span>
</span><span class='line'><span class="k">def</span> <span class="nc">Object</span><span class="o">.</span><span class="nf">inherited</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">c</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>        <span class="c1"># Lembre-se onde que foi definido</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Kernel.at_exit registra um bloco a ser executado quando o programa sai</span>
</span><span class='line'><span class="c1"># Vamos utilizá-lo para comunicar os dados de arquivo e de classe que recolhemos</span>
</span><span class='line'><span class="nb">at_exit</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">o</span> <span class="o">=</span> <span class="no">ClassTrace</span><span class="o">::</span><span class="no">OUT</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">60</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Files Loaded and Classes Defined:&quot;</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">60</span>
</span><span class='line'>  <span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">what</span><span class="p">,</span><span class="n">where</span><span class="o">|</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">what</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Class</span>  <span class="c1"># Report class (with hierarchy) defined</span>
</span><span class='line'>      <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Defined: </span><span class="si">#{</span><span class="n">what</span><span class="o">.</span><span class="n">ancestors</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;&lt;-&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="n">where</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">else</span>                 <span class="c1"># Report file loaded</span>
</span><span class='line'>      <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Loaded: </span><span class="si">#{</span><span class="n">what</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="n">where</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Métodos encadeamento de segurança da Thread</h3>


<p>O alias de encadeamento é feito pelo método <code>Module.synchronize_method</code>, o qual, por sua vez usa um método auxiliar <code>Module.create_alias</code> para definir
um alias adequado para qualquer método dado (incluindo métodos como o operador +).</p>

<p>Depois de definir estes novo métodos <code>Module</code>, Exemplo 1-2 redefine o método <code>synchronized</code> novamente. Quando o método é invocado dentro de uma classe
ou de um módulo, ele chama <code>synchronize_method</code> em cada um dos símbolos que é passado. Curiosamente, contudo, pode também ser chamado sem argumentos,
quando utilizado desta forma, acrescenta sincronização para qualquer método de instância é definido a seguir. (Utiliza o <code>hook</code> para receber
notificação quando um novo método <code>method_added</code> é adicionado.) Note que o código deste exemplo depende do método <code>Object.mutex</code> e a classe
<code>SynchronizedObject</code>.</p>

<figure class='code'><figcaption><span>Exemplo 1-2. Alias de encadeamento de segurança da Thread</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Define um alias corrente Module.synchronize_method de métodos de instância</span>
</span><span class='line'><span class="c1"># Assim que sincronizar a instância antes da execução.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Module</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Esta é uma função auxiliar para o encadeamento alias.</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Dado o nome de um método (como uma string ou símbolo) e um prefixo, cria</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Um alias exclusivo para o método, e retornar o nome do alias</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Como um símbolo. Quaisquer caracteres de pontuação em nome método original</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Serão convertidos em números para que os operadores podem ser alias.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">create_alias</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;alias&quot;</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Cole o prefixo do nome original e converter pontuação</span>
</span><span class='line'><span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">#{</span><span class="n">original</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="n">aka</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span><span class="sr">/([\=\|\&amp;\+\-\*\/\^\!\?\~\%\&lt;\&gt;\[\]])/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">num</span> <span class="o">=</span> <span class="vg">$1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>                       <span class="c1"># Ruby 1.8 character -&gt; ordinal</span>
</span><span class='line'>      <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">ord</span> <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">is_a?</span> <span class="nb">String</span> <span class="c1"># Ruby 1.9 character -&gt; ordinal</span>
</span><span class='line'>      <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">num</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="err">    </span>
</span><span class='line'><span class="err">    </span><span class="c1"># Mantenha acrescentando ressalta até chegarmos a um nome que não está em uso</span>
</span><span class='line'><span class="err">    </span><span class="n">aka</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="k">while</span> <span class="nb">method_defined?</span> <span class="n">aka</span> <span class="ow">or</span> <span class="nb">private_method_defined?</span> <span class="n">aka</span>
</span><span class='line'>
</span><span class='line'><span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="n">aka</span><span class="o">.</span><span class="n">to_sym</span>           <span class="c1"># Converter o nome de alias de um símbolo</span>
</span><span class='line'><span class="err">    </span><span class="n">alias_method</span> <span class="n">aka</span><span class="p">,</span> <span class="n">original</span> <span class="c1"># Na verdade criar o alias</span>
</span><span class='line'><span class="err">    </span><span class="n">aka</span>                                            <span class="c1"># Retorna o nome do alias</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Alias correntam o método nomeado para adicionar sincronização</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">synchronize_method</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Primeiro, fazemos um alias para a versão dessincronizado do método.</span>
</span><span class='line'><span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="n">create_alias</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;unsync&quot;</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Agora redefini o original para invocar o alias em um bloco sincronizado.</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Queremos o método definido como sendo capaz de aceitar os blocos, de modo que</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Não pode usar define_method, e deve avaliar vez uma string com</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Class_eval. Note-se que tudo entre% Q {} e da correspondência</span>
</span><span class='line'><span class="err">    </span><span class="c1"># É uma string entre aspas, e não um bloco.</span>
</span><span class='line'><span class="err">    </span><span class="nb">class_eval</span> <span class="sx">%Q{</span>
</span><span class='line'><span class="sx">      def </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(*args, &amp;block)</span>
</span><span class='line'><span class="sx">        synchronized(self) { </span><span class="si">#{</span><span class="n">aka</span><span class="si">}</span><span class="sx">(*args, &amp;block) }</span>
</span><span class='line'><span class="sx">      end</span>
</span><span class='line'><span class="sx">    }</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Este método global sincronizado agora pode ser usado de três maneiras diferentes.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Caso 1: com um argumento e um bloco, sincronizar sobre o objeto</span>
</span><span class='line'><span class="err">  </span><span class="c1"># E executar o bloco</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Caso dois: com um argumento que não é um símbolo e nenhum bloco</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Devolve um invólucro de SynchronizedObject</span>
</span><span class='line'><span class="err">  </span><span class="k">elsif</span> <span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">is_a?</span> <span class="no">Symbol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="no">SynchronizedObject</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Caso três: quando invocado em um módulo com nenhum bloco, alias a cadeia</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Chamado métodos para adicionar sincronização. Ou, se não há argumentos,</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Então apelido acorrentam o próximo método definido.</span>
</span><span class='line'><span class="err">  </span><span class="k">elsif</span> <span class="nb">self</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Module</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Synchronize the named methods</span>
</span><span class='line'>      <span class="n">args</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="nb">self</span><span class="o">.</span><span class="n">synchronize_method</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Se nenhum método é especificado pelo synchronize o método seguinte define</span>
</span><span class='line'><span class="err">      </span><span class="n">eigenclass</span> <span class="o">=</span> <span class="n">class</span><span class="o">&lt;&lt;</span><span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>      <span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span> <span class="c1"># Use eigenclass para definir métodos de classe</span>
</span><span class='line'><span class="err">        </span><span class="c1"># Define method_added para notificação quando próximo método é definido</span>
</span><span class='line'><span class="err">        </span><span class="n">define_method</span> <span class="ss">:method_added</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'><span class="err">          </span><span class="c1"># Primeiro remover esse método hook</span>
</span><span class='line'><span class="err">          </span><span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">remove_method</span> <span class="ss">:method_added</span> <span class="p">}</span>
</span><span class='line'><span class="err">          </span><span class="c1"># Em seguida, sincronize o método que acabou de ser adicionado</span>
</span><span class='line'><span class="err">          </span><span class="nb">self</span><span class="o">.</span><span class="n">synchronize_method</span> <span class="nb">name</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Caso 4: qualquer outra invocação é um erro</span>
</span><span class='line'><span class="err">  </span><span class="k">else</span>
</span><span class='line'>    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;Invalid arguments to synchronize()&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Métodos de encadeamento para Rastreamento</h3>


<p>O Exemplo 1-3 suporta o rastreio de métodos denominados de um objeto. Ele define <code>trace!</code> e <code>untrace!</code> a cadeia e desencadeiam métodos chamados de um
objeto.</p>

<p>A coisa interessante sobre esse exemplo é que ele faz o seu encadeamento de um modo diferente a partir do Exemplo 1-2. Ele simplesmente define métodos
únicos no objeto e usa <code>super</code> dentro do <code>singleton</code> para a cadeia de definição do método original de exemplo. Nenhum método são criado aliases.</p>

<figure class='code'><figcaption><span>Exemplo 8-10. Encadeamento com métodos singleton para rastrear</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Define métodos trace! e untrace! de instância para todos os objetos.</span>
</span><span class='line'><span class="c1"># trace! &quot;Cadeias&quot; os métodos chamados por definir métodos singleton</span>
</span><span class='line'><span class="c1"># Que adiciona a funcionalidade de rastreamento e use super para chamar o original.</span>
</span><span class='line'><span class="c1"># untrace! exclui os métodos singleton para remover o rastreamento.</span>
</span><span class='line'><span class="n">classe</span> <span class="no">Object</span>
</span><span class='line'><span class="err">  </span><span class="c1"># os métodos trace especificados, enviando a saída para STDERR.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">trace!</span><span class="p">(</span><span class="o">*</span><span class="nb">methods</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@_traced</span> <span class="o">=</span> <span class="vi">@_traced</span> <span class="o">||</span> <span class="o">[]</span>    <span class="c1"># Lembre-se o conjunto de métodos traçados</span>
</span><span class='line'>
</span><span class='line'><span class="err">    </span><span class="c1"># Se nenhum método foi especificado, use todos os métodos públicos definidos</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Diretamente (não herdado) pela classe deste objeto</span>
</span><span class='line'><span class="err">    </span><span class="nb">methods</span> <span class="o">=</span> <span class="nb">public_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">methods</span><span class="o">.</span><span class="n">map!</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">to_sym</span> <span class="p">}</span>    <span class="c1"># Converta qualquer cordas para símbolos</span>
</span><span class='line'><span class="err">    </span><span class="nb">methods</span> <span class="o">-=</span> <span class="vi">@_traced</span>                   <span class="c1"># remove métodos que já estão traçadas</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">empty?</span>         <span class="c1"># Voltar mais cedo se não há nada a fazer</span>
</span><span class='line'><span class="err">    </span><span class="vi">@_traced</span> <span class="o">|=</span> <span class="nb">methods</span>           <span class="c1"># Adiciona métodos para definir métodos de traçados</span>
</span><span class='line'>
</span><span class='line'><span class="err">    </span><span class="c1"># Trace o fato de que estamos começando a traçar estes métodos</span>
</span><span class='line'><span class="err">    </span><span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Tracing </span><span class="si">#{</span><span class="nb">methods</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>  
</span><span class='line'>      <span class="c1"># Singleton métodos são definidos na eigenclass</span>
</span><span class='line'>    <span class="n">eigenclass</span> <span class="o">=</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="nb">methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="c1"># Para cada método m</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Define uma versão trace singleton do método m.</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Saída de informações de rastreamento e usar super para invocar o</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Método de instância que é o rastreamento.</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Queremos que os métodos definidos para ser capaz de aceitar blocos, de modo que</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Não pode usar define_method, e deve avaliar, em vez de uma string.</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Note que tudo entre %Q{} e a correspondência é uma</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Entre aspas de string, não um bloco. Observe também que há</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Dois níveis de interpolações de string aqui. # {} É interpolada</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Quando o método singleton é definida. E \ # {} é interpolada</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Quando o método singleton é invocado.</span>
</span><span class='line'><span class="err">      </span><span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="sx">%Q{</span>
</span><span class='line'><span class="sx">        def </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(*args, &amp;block)</span>
</span><span class='line'><span class="sx">          begin</span>
</span><span class='line'><span class="sx">            STDERR &lt;&lt; &quot;Entering: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(</span><span class="se">\#</span><span class="sx">{args.join(&#39;, &#39;)})</span><span class="se">\n</span><span class="sx">&quot;</span>
</span><span class='line'><span class="sx">            result = super</span>
</span><span class='line'><span class="sx">            STDERR &lt;&lt; &quot;Exiting: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx"> with </span><span class="se">\#</span><span class="sx">{result}</span><span class="se">\n</span><span class="sx">&quot;</span>
</span><span class='line'><span class="sx">            result</span>
</span><span class='line'><span class="sx">          rescue</span>
</span><span class='line'><span class="sx">            STDERR &lt;&lt; &quot;Aborting: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">: </span><span class="se">\#</span><span class="sx">{$!.class}: </span><span class="se">\#</span><span class="sx">{$!.message}&quot;</span>
</span><span class='line'><span class="sx">            raise</span>
</span><span class='line'><span class="sx">          end</span>
</span><span class='line'><span class="sx">        end</span>
</span><span class='line'><span class="sx">      }</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Untrace os métodos especificados ou todos os métodos rastreados</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">untrace!</span><span class="p">(</span><span class="o">*</span><span class="nb">methods</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>    <span class="c1"># Se nenhuma métodos especificados untrace</span>
</span><span class='line'>      <span class="nb">methods</span> <span class="o">=</span> <span class="vi">@_traced</span>    <span class="c1"># todos os métodos atualmente rastreados</span>
</span><span class='line'>      <span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Untracing all methods on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">else</span>                    <span class="c1"># Caso contrário, untrace</span>
</span><span class='line'>      <span class="nb">methods</span><span class="o">.</span><span class="n">map!</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">to_sym</span> <span class="p">}</span>  <span class="c1"># Converter string para símbolos</span>
</span><span class='line'>      <span class="nb">methods</span> <span class="o">&amp;=</span> <span class="vi">@_traced</span>   <span class="c1"># todos os métodos especificados que são rastreados</span>
</span><span class='line'>      <span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Untracing </span><span class="si">#{</span><span class="nb">methods</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>      
</span><span class='line'>      <span class="vi">@_traced</span> <span class="o">-=</span> <span class="nb">methods</span>     <span class="c1"># Retire-os do nosso conjunto de métodos de traçados</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># Remove os métodos traçados únicos do eigenclass</span>
</span><span class='line'>      <span class="c1"># Note que nós class_eval um bloco aqui, não uma string</span>
</span><span class='line'>      <span class="p">(</span><span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span><span class="p">)</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
</span><span class='line'>        <span class="nb">methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'>          <span class="n">remove_method</span> <span class="n">m</span>     <span class="c1"># undef_method não funciona corretamente</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># Se nenhum método são traçados mais, remover o nosso exemplo var</span>
</span><span class='line'>      <span class="k">if</span> <span class="vi">@_traced</span><span class="o">.</span><span class="n">empty?</span>
</span><span class='line'>        <span class="n">remove_instance_variable</span> <span class="ss">:@_traced</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai galera! Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Criando Métodos Dinamicamente - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/09/15/criando-metodos-dinamicamente-number-ruby-1-dot-9/"/>
    <updated>2012-09-15T20:38:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/09/15/criando-metodos-dinamicamente-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Criando Métodos Dinamicamente</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Criando Métodos Dinamicamente</h1>


<p>Uma técnica importante em metaprogramação é a utilização de métodos que criam métodos. Os métodos <code>attr_reader</code> e <code>attr_accessor</code> são exemplos. Estes
métodos de instância privados do <code>Module</code> são usados como palavras-chave dentro de definições de classe. Eles aceitam nomes de atributos como seus
argumentos, e dinamicamente criam métodos com esses nomes. Os exemplos que se seguem são variantes sobre essa criação de atributos assessores dos
métodos e demonstra duas formas diferentes de criar dinamicamente métodos como este.</p>

<!--more-->




<h3>Métodos definidos com class_eval</h3>


<p>O Exemplo 1-1 define métodos privados de instância do <code>Module</code> chamado <code>readonly</code> e <code>readwrite</code>. Estes métodos funcionam como <code>attr_reader</code>
e <code>attr_accessor</code>, e eles estão aqui para demonstrar como esses métodos são implementados. A implementação é na verdade muito simples: <code>readonly</code> e
<code>readwrite</code> primeiro construi uma seqüência de código Ruby contendo as instruções necessárias para definir <code>def</code> os métodos de acesso apropriados.
Em seguida, eles avaliam que a seqüência de código usando <code>class_eval</code>. Usando <code>class_eval</code> como esta gera a sobrecarga de analisar a cadeia de código.
A vantagem, contudo, é que os métodos que definem não precisa usar as APIs reflexivas, pois eles podem consultar ou definir o valor de uma variável de
instância diretamente.</p>

<figure class='code'><figcaption><span>Exemplo 1-1. Métodos de atributos com class_eval</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Module</span>
</span><span class='line'><span class="err">  </span><span class="kp">private</span> <span class="c1"># Os métodos que se seguem são todos privados</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Este método funciona como attr_reader, mas tem um nome mais curto</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">readonly</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># Se nenhum argumento, não faz nada</span>
</span><span class='line'><span class="err">    </span><span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>                 <span class="c1"># Comece com uma cadeia vazia de código</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Gera uma seqüência de código Ruby para definir métodos leitores de atributos.</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Observe como o símbolo é interpolado para a seqüência de código.</span>
</span><span class='line'><span class="err">    </span><span class="n">syms</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>                     <span class="c1"># Para cada símbolo</span>
</span><span class='line'><span class="err">      </span><span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;def </span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">; @</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">; end</span><span class="se">\n</span><span class="s2">&quot;</span>   <span class="c1"># O método de definição</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Finalmente, class_eval o código gerado para criar métodos de instância.</span>
</span><span class='line'><span class="err">    </span><span class="nb">class_eval</span> <span class="n">code</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Este método funciona como attr_accessor, mas tem um nome mais curto.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">readwrite</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'><span class="err">    </span><span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'><span class="err">    </span><span class="n">syms</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>
</span><span class='line'>      <span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;def </span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">; @</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2"> end</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>      <span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;def </span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">=(value); @</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2"> = value; end</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="nb">class_eval</span> <span class="n">code</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Métodos definidos com define_method</h3>


<p>O Exemplo 1-2 é uma posição diferente sobre os assessores de atributos. O método <code>attributes</code> é algo como o método <code>readwrite</code> definido no <code>Exemplo
1-1</code>. Em vez de tomar qualquer número de nomes de atributos como argumentos, que espera um único objeto <code>hash</code>. Este <code>hash</code> deve ter nomes de atributos
como suas chaves, e deve mapear os nomes de atributos para os valores padrões para os atributos. O método <code>class_attrs</code> funciona como atributos, mas
define os atributos de classe em vez de atributos de instância.</p>

<p>Lembre-se que Ruby permite que as chaves para ser omitidas em torno de <code>hash</code> literais quando eles são o argumento final em uma invocação de método.
Assim, o método <code>attributes</code> pode ser chamado com um código como este:</p>

<figure class='code'><figcaption><span>Metodo attributes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Point</span>
</span><span class='line'>  <span class="n">attributes</span> <span class="ss">:x</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">:y</span> <span class="o">=&gt;</span> <span class="mi">0</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.9, podemos usar a sintaxe do <code>hash</code> é mais sucinta:</p>

<figure class='code'><figcaption><span>Attibutes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Point</span>
</span><span class='line'>  <span class="n">attributes</span> <span class="n">x</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">0</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este é outro exemplo que utiliza sintaxe flexível de Ruby para criar métodos que se comportam como palavras-chave de linguagem.</p>

<p>A implementação do método de <code>attributes</code> no <code>Exemplo 1-2</code> é um pouco diferente do que a do método <code>readwrite</code> no <code>Exemplo 1-1</code>. Em vez de definir uma
seqüência de código Ruby e avaliá-lo com <code>class_eval</code>, o método <code>attributes</code> define o corpo dos acessos de atributos de um bloco e define os métodos
que utilizam <code>define_method</code>. Uma vez que este método técnico de definição não nos permitem identificadores interpolares diretamente no corpo do
método, temos de confiar em métodos reflexivos, como <code>instance_variable_get</code>. Devido a isso, os assessores definidos com <code>attributes</code> são susceptíveis
de ser menos eficientes do que os definidos com <code>readwrite</code>.</p>

<p>Um ponto interessante sobre o método <code>attributes</code> é que não armazena explicitamente os valores padrões para os atributos em uma variável de classe de
qualquer tipo. Em vez disso, o valor por defeito para cada atributo é capturado pelo âmbito de bloquear o método usado para definir.</p>

<p>O método <code>class_attrs</code> define os atributos de classe muito simples: ele invoca <code>attributes</code> na <a href="http://blog.caelum.com.br/metaprogramacao-eigenclass-em-ruby/">eigenclass</a> da classe. Este
significa que os métodos resultantes usam variáveis de instância de classe em vez de variáveis de classe regular.</p>

<figure class='code'><figcaption><span>Exemplo 1-2. Métodos de atributos com define_method</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Module</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Este método define os atributos de métodos de reader e writer de nomeado</span>
</span><span class='line'><span class="err">  </span><span class="c1"># attributes, mas aguarda um argumento de attributes de nomes em hash mapeado para</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Valores padrões. Os métodos de reader gerados atributos retorna o</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Valor padrão se a variável de instância ainda não foi definido.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="nb">hash</span><span class="o">.</span><span class="n">each_pair</span> <span class="k">do</span> <span class="o">|</span><span class="n">symbol</span><span class="p">,</span> <span class="n">default</span><span class="o">|</span>   <span class="c1"># Para cada par de atributo/default</span>
</span><span class='line'><span class="err">      </span><span class="n">getter</span> <span class="o">=</span> <span class="n">symbol</span>                     <span class="c1"># Nome do método getter</span>
</span><span class='line'><span class="err">      </span><span class="n">setter</span> <span class="o">=</span> <span class="ss">:&quot;</span><span class="si">#{</span><span class="n">symbol</span><span class="si">}</span><span class="ss">=&quot;</span>              <span class="c1"># nome do método setter</span>
</span><span class='line'><span class="err">      </span><span class="n">variable</span> <span class="o">=</span> <span class="ss">:&quot;@</span><span class="si">#{</span><span class="n">symbol</span><span class="si">}</span><span class="ss">&quot;</span>            <span class="c1"># nome da variável de instância</span>
</span><span class='line'><span class="err">      </span><span class="n">define_method</span> <span class="n">getter</span> <span class="k">do</span>             <span class="c1"># Definir o método getter</span>
</span><span class='line'><span class="err">        </span><span class="k">if</span> <span class="n">instance_variable_defined?</span> <span class="n">variable</span>
</span><span class='line'><span class="err">          </span><span class="nb">instance_variable_get</span> <span class="n">variable</span>  <span class="c1"># Retorna variável, se definido</span>
</span><span class='line'><span class="err">        </span><span class="k">else</span>
</span><span class='line'><span class="err">          </span><span class="n">default</span>                         <span class="c1"># Caso contrário retornar padrão</span>
</span><span class='line'><span class="err">        </span><span class="k">end</span>
</span><span class='line'><span class="err">      </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">      </span><span class="n">define_method</span> <span class="n">setter</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>     <span class="c1"># Defini método setter</span>
</span><span class='line'><span class="err">        </span><span class="nb">instance_variable_set</span> <span class="n">variable</span><span class="p">,</span>   <span class="c1"># Defina a variável de instância</span>
</span><span class='line'><span class="err">                              </span><span class="n">value</span>       <span class="c1"># Para o valor do argumento</span>
</span><span class='line'><span class="err">      </span><span class="k">end</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Este método funciona como atributos, mas define métodos de classe em vez de</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Invocar atributos no eigenclass em vez de em si mesmo.</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Note que os métodos definidos usam variáveis de instância de classe</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Em vez de variáveis de classe regulares.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">class_attrs</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="n">eigenclass</span> <span class="o">=</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>    <span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">attributes</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Ambos os métodos são privados</span>
</span><span class='line'>  <span class="kp">private</span> <span class="ss">:attributes</span><span class="p">,</span> <span class="ss">:class_attrs</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos, até o proximo post!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Missing Methods e Missing Constants - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/09/15/missing-methods-e-missing-constants-number-ruby-1-dot-9/"/>
    <updated>2012-09-15T12:46:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/09/15/missing-methods-e-missing-constants-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Missing Methods e Missing Constants</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Missing Methods e Missing Constants</h1>


<p>O método <code>method_missing</code> é uma parte fundamental da pesquisa de algoritmo em método em Ruby e fornece uma maneira poderosa para capturar e manipular
invocações arbitrárias sobre um objeto. O método <code>const_missing</code> de <code>Module</code> executa uma função similar para o algoritmo de pesquisa constante e que
nos permite calcular ou lazily inicializa as constantes. Os exemplos que seguem demonstram ambos métodos.</p>

<!--more-->




<h3>Constantes Unicode Codepoint com const_missing</h3>


<p>O Exemplo 1-1 define um módulo <code>Unicode</code> que aparece para definir uma constante (uma string UTF-8) para cada <code>Unicode codepoint</code> de <code>U+0000</code> a
<code>U+10FFFF</code>. O único modo prático para suportar estas muitas constantes é a utilização do método <code>const_missing</code>. O código faz a suposição de que se uma
constante é referenciada uma vez, é susceptível de ser utilizado de novo, de modo que o método <code>const_missing</code> chama <code>Module.const_set</code> para definir
uma constante real para se referir a cada valor calculado.</p>

<figure class='code'><figcaption><span>Exemplo 1-1. Constantes Unicode codepoint com const_missing</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Todo codepoints Unicode. Ele usa const_missing para defini-los lazily.</span>
</span><span class='line'><span class="c1"># Exemplos:</span>
</span><span class='line'><span class="c1">#   copyright = Unicode::U00A9</span>
</span><span class='line'><span class="c1">#   euro = Unicode::U20AC</span>
</span><span class='line'><span class="c1">#   infinity = Unicode::U221E</span>
</span><span class='line'><span class="k">module</span> <span class="nn">Unicode</span>
</span><span class='line'>  <span class="c1"># Este método permite-nos definir constantes Unicode codepoint lazily.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">const_missing</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>  <span class="c1"># constante indefinida passada como um símbolo</span>
</span><span class='line'>    <span class="c1"># Verifique se o nome da constante é da forma certa.</span>
</span><span class='line'>    <span class="c1"># Capital U seguido de um número hexadecimal entre 0000 e 10FFFF.</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">name</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=~</span> <span class="sr">/^U([0-9a-fA-F]{4,5}|10[0-9a-fA-F]{4})$/</span>
</span><span class='line'><span class="err">      </span><span class="c1"># $1 é o número hexadecimal correspondente. Converte em um inteiro.</span>
</span><span class='line'>      <span class="n">codepoint</span> <span class="o">=</span> <span class="vg">$1</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Converte o número para uma string UTF-8 com a magia do Array.pack.</span>
</span><span class='line'>      <span class="n">utf8</span> <span class="o">=</span> <span class="o">[</span><span class="n">codepoint</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Faz a imutável string UTF-8.</span>
</span><span class='line'><span class="err">      </span><span class="n">utf8</span><span class="o">.</span><span class="n">freeze</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Define uma constante real para pesquisa mais rápida da próxima vez, e retorna</span>
</span><span class='line'><span class="err">      </span><span class="c1"># O texto UTF-8 para este tempo.</span>
</span><span class='line'><span class="err">      </span><span class="nb">const_set</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">utf8</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="k">else</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Eleva um erro para constantes do formulário errado.</span>
</span><span class='line'><span class="err">      </span><span class="k">raise</span> <span class="no">NameError</span><span class="p">,</span> <span class="s2">&quot;Uninitialized constant: Unicode::</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Rastreamento Invocações de método com method_missing</h3>


<p>No início deste post, demonstrei uma extensão para a classe <code>Hash</code> usando <code>method_missing</code>. Agora, no <code>Exemplo 1-2</code>, temos que demonstrar o uso de
<code>method_missing</code> delega as chamadas arbitrárias em um objeto para outro objeto. Neste exemplo, o que fazemos nesta ordem para a saída de rastreamento
de mensagens para o objeto.</p>

<p><code>Exemplo 1-2</code> define um método de instância <code>Object.trace</code> e uma classe <code>TracedObject</code>. O método <code>trace</code> retorna uma instância de <code>TracedObject</code> que
usa <code>method_missing</code> para pegar invocações, rastreá-las, e delegá-las ao objeto que está sendo rastreado. Você pode usar como este:</p>

<figure class='code'><figcaption><span>Rastrear Metodos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">reverse</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">a</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isso produz a seguinte saída de rastreamento:</p>

<figure class='code'><figcaption><span>Retorno</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Invocando</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
</span><span class='line'><span class="no">Volta</span><span class="p">:</span> <span class="o">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span> <span class="n">a</span> <span class="n">partir</span> <span class="n">de</span> <span class="n">a</span><span class="o">.</span><span class="n">reverse</span>
</span><span class='line'><span class="no">Invocando</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="no">Raising</span><span class="p">:</span> <span class="no">IndexError</span><span class="p">:</span> <span class="err">í</span><span class="n">ndice</span> <span class="n">de</span> <span class="mi">3</span> <span class="n">de</span> <span class="n">matriz</span> <span class="n">de</span> <span class="n">a</span><span class="o">.</span><span class="n">fetch</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que, além de demonstrar <code>method_missing</code>, o <code>Exemplo 1-2</code> demonstra também <code>Module.instance_methods</code>, <code>Module.undef_method</code> e <code>Kernel.caller</code>.</p>

<figure class='code'><figcaption><span>Exemplo 1-2. Rastreamento invocações de método com method_missing</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Se comporta exatamente como o original, mas que traça todas as chamadas de método</span>
</span><span class='line'><span class="c1"># No objeto. Se rastreamento mais de um objeto, especifique um nome para</span>
</span><span class='line'><span class="c1"># Aparecer na saída. Por padrão, as mensagens serão enviadas para STDERR,</span>
</span><span class='line'><span class="c1"># Mas você pode especificar qualquer stream (ou qualquer objeto que aceita strings</span>
</span><span class='line'><span class="c1"># Como argumentos para &lt;&lt;).</span>
</span><span class='line'><span class="n">classe</span> <span class="no">Object</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="nb">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="no">STDERR</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Retorna um TracedObject que traços e delegados tudo mais para nós.</span>
</span><span class='line'><span class="err">    </span><span class="no">TracedObject</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Esta classe usa method_missing para rastrear chamadas de método e</span>
</span><span class='line'><span class="c1"># Então delega ele para algum outro objeto. Ele exclui a maioria de seus próprios</span>
</span><span class='line'><span class="c1"># Métodos de instância para que eles não ficam no caminho de method_missing.</span>
</span><span class='line'><span class="c1"># Note que apenas métodos invocados através da TracedObject será rastreado.</span>
</span><span class='line'><span class="c1"># Se o objeto delegado chama métodos em si, aquelas invocações</span>
</span><span class='line'><span class="c1"># Não será rastreado.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">TracedObject</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Indefine todos os nossos métodos de instância públicos não críticos.</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Observe o uso do Module.instance_methods e Module.undef_method.</span>
</span><span class='line'>  <span class="nb">instance_methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'><span class="err">    </span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">to_sym</span>   <span class="c1"># Ruby 1.8 retorna string, em vez de símbolos</span>
</span><span class='line'>    <span class="k">next</span> <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="ss">:object_id</span> <span class="o">||</span> <span class="n">m</span> <span class="o">==</span> <span class="ss">:__id__</span> <span class="o">||</span> <span class="n">m</span> <span class="o">==</span> <span class="ss">:__send__</span>
</span><span class='line'><span class="err">    </span><span class="n">undef_method</span> <span class="n">m</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Inicializa esta instancia do TracedObject.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="vi">@o</span> <span class="o">=</span> <span class="n">o</span>            <span class="c1"># objeto que delegar</span>
</span><span class='line'><span class="err">    </span><span class="vi">@n</span> <span class="o">=</span> <span class="nb">name</span>         <span class="c1"># O nome do objeto a aparecer no rastreamento de mensagens</span>
</span><span class='line'><span class="err">    </span><span class="vi">@trace</span> <span class="o">=</span> <span class="n">stream</span>   <span class="c1"># Onde essas mensagens de rastreamento são enviados</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Este é o principal método de TracedObject. Ele é invocado por apenas</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Sobre qualquer invocação de método em um TracedObject.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="n">m</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">shift</span>         <span class="c1"># O primeiro é o nome do método</span>
</span><span class='line'><span class="err">    </span><span class="k">begin</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Acompanhe a invocação do método.</span>
</span><span class='line'><span class="err">      </span><span class="n">arglist</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">a</span><span class="o">.</span><span class="n">inspect</span><span class="p">}</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
</span><span class='line'><span class="err">      </span><span class="vi">@trace</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Invoking: </span><span class="si">#{</span><span class="vi">@n</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="s2">(</span><span class="si">#{</span><span class="n">arglist</span><span class="si">}</span><span class="s2">) at </span><span class="si">#{</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Invoque o método em nosso objeto de delegação e obtem o valor de retorno.</span>
</span><span class='line'><span class="err">      </span><span class="n">r</span> <span class="o">=</span> <span class="vi">@o</span><span class="o">.</span><span class="n">send</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Traça um retorno normal do método.</span>
</span><span class='line'><span class="err">      </span><span class="vi">@trace</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Returning: </span><span class="si">#{</span><span class="n">r</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2"> from </span><span class="si">#{</span><span class="vi">@n</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="s2"> to </span><span class="si">#{</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Retorna o valor que o objeto delegado retornado.</span>
</span><span class='line'><span class="err">      </span><span class="n">r</span>
</span><span class='line'><span class="err">    </span><span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Traçar um retorno anormal do método.</span>
</span><span class='line'><span class="err">      </span><span class="vi">@trace</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Raising: </span><span class="si">#{</span><span class="n">e</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">e</span><span class="si">}</span><span class="s2"> from </span><span class="si">#{</span><span class="vi">@n</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'><span class="err">      </span><span class="c1"># E re-envia qualquer exceção que o objeto delegado levantada.</span>
</span><span class='line'><span class="err">      </span><span class="k">raise</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Retorna o objeto que delegou.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">__delegate</span>
</span><span class='line'><span class="err">    </span><span class="vi">@o</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Objetos sincronizados por delegação</h3>


<p>No post anterior, vimos um método global sincronizado, que aceita um objeto e executa um bloco sob a proteção do <code>Mutex</code> associado a esse objeto.
A maior parte do exemplo consistiu na aplicação do método <code>Object.mutex</code>. O método sincronizado foi trivial:</p>

<figure class='code'><figcaption><span>Mutex</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>O Exemplo 1-3 modifica este método de modo que, quando chamado sem um bloco, ele retorna um invólucro em torno do objeto <code>SynchronizedObject</code>.
<code>SynchronizedObject</code> é uma classe que delega com base em <code>method_missing</code>. É muito parecido com a classe <code>TracedObject</code>, Exemplo 1-2, mas Ruby 1.9 está
escrito com uma subclasse de <code>BasicObject</code>, por isso não há necessidade de excluir explicitamente os métodos de instância de objeto. Note que o código
deste exemplo não está sozinho, que exige o método <code>Object.mutex</code> definido anteriormente.</p>

<figure class='code'><figcaption><span>Exemplo 1-3. Métodos de sincronização com method_missing</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="n">o</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="no">SynchronizedObject</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># A classe delega usando method_missing de segurança da thread</span>
</span><span class='line'><span class="c1"># Em vez de estender objetos e excluir nossos métodos que acabamos de estender de</span>
</span><span class='line'><span class="c1"># BasicObject, que é definido no Ruby 1.9. BasicObject não</span>
</span><span class='line'><span class="c1"># Herda do Object ou do Kernel, de modo que os métodos de uma BasicObject não pode</span>
</span><span class='line'><span class="c1"># Chamar os métodos de nível superior: eles não são apenas lá.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">SynchronizedObject</span>  <span class="o">&lt;</span> <span class="no">BasicObject</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">o</span><span class="p">);</span> <span class="vi">@delegate</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__delegate</span><span class="p">;</span> <span class="vi">@delegate</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@delegate</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span>
</span><span class='line'>      <span class="vi">@delegate</span><span class="o">.</span><span class="n">send</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos&#8230; :)</p>

<p>Até o proximo! :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Estruturas de Controle Personalizados - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/09/13/estruturas-de-controle-personalizados-number-ruby-1-dot-9/"/>
    <updated>2012-09-13T22:50:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/09/13/estruturas-de-controle-personalizados-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Estruturas de Controle Personalizados</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Estruturas de Controle Personalizados</h1>


<p>Uso de blocos em Ruby, juntamente com sua sintaxe de parênteses opcional, tornam muito fácil de definir métodos que parecem <code>iterator</code> e se comportam
como estruturas de controle. O método <code>loop</code> do <code>Kernel</code> é um exemplo simples. Neste post, desenvolvo mais três exemplos. Os exemplos aqui usam
segmentação da API do Ruby, você pode precisar de ler Threads e Concorrência para compreender todos os detalhes.</p>

<!--more-->




<h3>Executando Delaying e Repeating: `after` e `every`</h3>


<p>O exemplo 1-1 define métodos globais nomeados após os dias. Cada um leva um argumento numérico que representa um número de segundos e devem ter um
bloco associado. Depois cria um novo segmento e retorna o objeto <code>Thread</code> imediatamente. O segmento recém-criado dorme para o número especificado de
segundos e, então, chama (sem argumentos) o bloco que você forneceu. Tudo é semelhante, mas ele chama o bloco repetidamente, &#8220;dorme&#8221; o número
especificado de segundos entre chamadas. O segundo argumento para todos é um valor para passar para a primeira chamada do bloco. O valor de retorno de
cada invocação se torna o valor que passou para a próxima invocação. O bloco associado a cada intervalo pode ser usado para prevenir qualquer
invocações futuras.</p>

<p>Aqui está um exemplo de código que usa <code>after</code> e <code>every</code>:</p>

<figure class='code'><figcaption><span>after e every</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;afterevery&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">after</span> <span class="n">i</span> <span class="p">{</span> <span class="nb">puts</span> <span class="n">i</span><span class="p">}</span> <span class="p">}</span>  <span class="c1"># Lentamente imprimir os números 1-5</span>
</span><span class='line'><span class="nb">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                            <span class="c1"># Aguarde cinco segundos</span>
</span><span class='line'><span class="n">every</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span> <span class="k">do</span> <span class="o">|</span><span class="n">count</span><span class="o">|</span>               <span class="c1"># Agora, lentamente, imprimir 6-10</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">count</span>
</span><span class='line'>  <span class="k">break</span> <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">10</span>
</span><span class='line'><span class="err">  </span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>                         <span class="c1"># O valor próximo de contagem</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="nb">sleep</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>                            <span class="c1"># Dê um tempo acima para executar</span>
</span></code></pre></td></tr></table></div></figure>


<p>Chamando o <code>sleep</code> no final deste código, evita o programa de sair antes que a <code>thread</code> seja criada por poder todas completar sua contagem. Com esse
exemplo de como <code>after</code> e <code>every</code> são usadas, agora estamos prontos para apresentar a sua implementação.</p>

<figure class='code'><figcaption><span>Exemplo 1-1. Os métodos after e every</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># Defini métodos de kernel after e every por adiar blocos de código.</span>
</span><span class='line'><span class="c1"># Exemplos:</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1">#   after 1 { puts &quot;done&quot; }</span>
</span><span class='line'><span class="c1">#   every 60 { redraw_clock }</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># Ambos os métodos retornam objetos Thread. Chame kill sobre os objetos devolvidos</span>
</span><span class='line'><span class="c1"># Para cancelar a execução do código.</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># Note que essa é uma implementação muito ingênua. A mais robusta</span>
</span><span class='line'><span class="c1"># Implementação usaria uma Thread timer para todas as tarefas globais,</span>
</span><span class='line'><span class="c1"># Permitiria uma maneira de recuperar o valor de um bloco diferido, e iria</span>
</span><span class='line'><span class="c1"># Fornecer uma maneira de esperar por todas as tarefas pendentes para ser concluído.</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Executar o bloco after depois de esperar o número especificado de segundos.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">after</span><span class="p">(</span><span class="n">seconds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>       <span class="c1"># Em um novo segmento ...</span>
</span><span class='line'>    <span class="nb">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>    <span class="c1"># Primeiro espera</span>
</span><span class='line'>    <span class="n">block</span><span class="o">.</span><span class="n">call</span>        <span class="c1"># Em seguida, chamar o bloco</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span> <span class="c1"># Retorna o objeto Thread de imediato</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Repete sleep e after executando o bloco.</span>
</span><span class='line'><span class="c1"># Passa valor para o bloco na primeira chamada.</span>
</span><span class='line'><span class="c1"># Em chamadas subseqüentes, passar o valor da chamada anterior.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">every</span><span class="p">(</span><span class="n">seconds</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>                 <span class="c1"># Em um novo segmento ...</span>
</span><span class='line'>    <span class="kp">loop</span> <span class="k">do</span>                     <span class="c1"># loop para sempre (ou até ruptura no bloco)</span>
</span><span class='line'>      <span class="nb">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>            <span class="c1"># sleep</span>
</span><span class='line'><span class="err">      </span><span class="n">value</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># E invocar bloco</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span> <span class="c1"># Em seguida, repita ..</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span> <span class="c1"># cada retorna o Tópico</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Thread de segurança com blocos sincronizados</h3>


<p>Ao escrever programas que usam várias <code>Threads</code>, é importante que duas <code>threads</code> não tente modificar o mesmo objeto, ao mesmo tempo. Uma maneira de
fazer isto é colocar o código que deve ser feito em uma <code>thread</code> segura em um bloco associado a uma chamada para o método de <code>synchronize</code> de um objeto
<code>Mutex</code>. No Exemplo 1-2 que levar isso a um passo adiante, e emula a palavra-chave <code>synchronized</code> do Java com um método global chamado <code>synchronized</code>.
Este método <code>synchronized</code> espera um único objeto como argumento e um bloco. Ele obtém um <code>Mutex</code> associado ao objeto, e usa <code>Mutex.synchronize</code> para
invocar o bloco. A parte complicada é que o objeto de Ruby, ao contrário de objetos Java, não tem um <code>Mutex</code> que lhes estão associados. Então o Exemplo
1-2 também define um método de instância chamado <code>mutex</code> em Object. Curiosamente, a implementação deste método <code>mutex</code> usa <code>synchoronized</code> na sua forma
de palavras-chave novo estilo!</p>

<p><code>Mutex</code> -> <a href="http://www.ruby-doc.org/core-1.9.2/Mutex.html">http://www.ruby-doc.org/core-1.9.2/Mutex.html</a></p>

<figure class='code'><figcaption><span>Exemplo 1-2. Simples blocos sincronizados</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;thread&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 1.8 mantém Mutex nesta biblioteca</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Obter o Mutex associado com o objeto o, e então avalia</span>
</span><span class='line'><span class="c1"># Bloco sob a proteção do Mutex.</span>
</span><span class='line'><span class="c1"># Este funciona como a palavra-chave synchronized do Java.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Object.mutex na verdade não existe. Temos que definir isso.</span>
</span><span class='line'><span class="c1"># Este método retorna um Mutex único para cada objeto, e</span>
</span><span class='line'><span class="c1"># Sempre retorna o mesmo Mutex para qualquer objeto particular.</span>
</span><span class='line'><span class="c1"># Cria Mutexes lazily, o que requer sincronização para</span>
</span><span class='line'><span class="c1"># Segurança da Thread.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Object</span>
</span><span class='line'>  <span class="c1"># Retorna o Mutex para este objeto, criando, se necessário.</span>
</span><span class='line'>  <span class="c1"># A parte difícil é ter certeza de que duas threads não chamam</span>
</span><span class='line'>  <span class="c1"># Isso ao mesmo tempo e acabam por criar dois mutexes diferentes.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">mutex</span>
</span><span class='line'>    <span class="c1"># Se este objeto já tem um mutex, basta devolvê-lo</span>
</span><span class='line'>    <span class="k">return</span> <span class="vi">@__mutex</span> <span class="k">if</span> <span class="vi">@__mutex</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># Caso contrário, nós temos que criar um mutex para o objeto.</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Para fazer isso com segurança que temos para sincronizar em nosso objeto de classe.</span>
</span><span class='line'>    <span class="n">synchronized</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Verifique novamente: no momento em que entrar neste bloco sincronizado,</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Alguma outra thread pode já ter criado o mutex.</span>
</span><span class='line'>      <span class="vi">@__mutex</span> <span class="o">=</span> <span class="vi">@__mutex</span> <span class="o">||</span> <span class="no">Mutex</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="err">    </span><span class="p">}</span>
</span><span class='line'><span class="err">    </span><span class="c1"># O valor de retorno é @__mutex</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># O método Object.mutex definido acima, necessita para bloquear a classe</span>
</span><span class='line'><span class="c1"># Se o objeto não tiver um Mutex ainda. Se a classe não tem</span>
</span><span class='line'><span class="c1"># Mutex próprio ainda, então a classe da classe (a Class do Object)</span>
</span><span class='line'><span class="c1"># Será bloqueada. A fim de evitar recursão infinita, devemos</span>
</span><span class='line'><span class="c1"># Garantir que o objeto da classe tem um mutex.</span>
</span><span class='line'><span class="no">Class</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="vi">@__mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="o">.</span><span class="n">new</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos, até o proximo! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflexão e Metaprogramação - ObjectSpace e GC - #Ruby 1.9 - Part VII]]></title>
    <link href="http://rrmartins.github.com/blog/2012/09/10/reflexao-e-metaprogramacao-objectspace-e-gc-number-ruby-1-dot-9-part-vii/"/>
    <updated>2012-09-10T23:26:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/09/10/reflexao-e-metaprogramacao-objectspace-e-gc-number-ruby-1-dot-9-part-vii</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>ObjectSpace e GC</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>ObjectSpace e GC</h1>


<!-- more -->


<p>O módulo <code>ObjectSpace</code> define um punhado de métodos de baixo nível que pode ser ocasionalmente útil para depurar ou trabalhar com metaprogramação.
O método mais notável é <code>each_object</code>, um iterador que pode render cada objeto (ou a cada instância de uma classe especificada) que o intérprete sabe
sobre:</p>

<figure class='code'><figcaption><span>ObjectSpace</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Imprima uma lista de todas as classes conhecidas</span>
</span><span class='line'><span class="no">ObjectSpace</span><span class="o">.</span><span class="n">each_object</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">c</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ObjectSpace._id2ref</code> é o inverso da <code>Object.object_id:</code> leva um objeto como seu argumento ID e retorna ao objeto correspondente, ou levanta uma
RangeError se não há nenhum objeto com que ID.</p>

<p><code>ObjectSpace.define_finalizer</code> permite o registo de uma <code>Proc</code> ou um bloco de código a ser chamado quando um objeto especificado é <code>garbage collected</code>.
Você deve ter cuidado ao registar um finalizador tal, no entanto, como o bloco não tem permissão de <code>finalizer</code> usar o objeto lixo coletado. Quaisquer
valores necessários para finalizar o objeto deve ser capturados no âmbito do bloco <code>finalizer</code>, de modo a que estejam disponíveis sem desreferência do
objeto. Use <code>ObjectSpace.undefine_finalizer</code> para excluir todos os blocos inscritos para um objeto <code>finalizer</code>.</p>

<p>O final método <code>ObjectSpace</code> é <code>ObjectSpace.garbage_collect</code>, que força o <code>garbage collected</code> de Ruby para ser executado. Funcionalidade de <code>garbage
collected</code> também está disponível através do módulo <code>GC</code>. <code>GC.start</code> é sinônimo de <code>ObjectSpace.garbage_collect</code>. <code>garbage collected</code> pode ser
desativado temporariamente com <code>GC.disable</code>, e ele pode ser ativado novamente com <code>GC.enable</code>.</p>

<p>A combinação do <code>_id2ref</code> e métodos <code>define_finalizer</code> permite a definição de &#8220;fracos&#8221; objetos de referência, que possuem uma referência a um valor sem
impedir o valor de ser coletado se tornar de outra forma inacessível. Consulte a classe <code>weakref</code> na biblioteca padrão (em lib/weakref.rb) para um exemplo.</p>

<p>Até o proximo post amigos&#8230;</p>

<p>Conhecimento nunca é d+ ! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflexão e Metaprogramação - Tracing - #Ruby 1.9 - Part VI]]></title>
    <link href="http://rrmartins.github.com/blog/2012/09/10/reflexao-e-metaprogramacao-tracing-number-ruby-1-dot-9-part-vi/"/>
    <updated>2012-09-10T22:50:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/09/10/reflexao-e-metaprogramacao-tracing-number-ruby-1-dot-9-part-vi</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Tracing</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Tracing</h1>


<p>Ruby define uma série de características para rastrear a execução de um programa. Estes principalmente são os úteis para a depuração do código e
imprimir mensagens de erro informativos. Duas das mais simples das características são as palavras-chave da linguagem: <code>__FILE__</code> e <code>__LINE__</code>.
Essas palavras-chave sempre avaliam o nome do arquivo e o número da linha dentro do arquivo em que se aparece, e eles permitem que uma mensagem de erro
para especificar o local exato em que ela foi gerado:</p>

<!-- more -->


<figure class='code'><figcaption><span>__FILE__ e __LINE__</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">STDERR</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="bp">__FILE__</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="bp">__LINE__</span><span class="p">):</span> <span class="n">invalid</span> <span class="n">data</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como um aparte, note que os métodos <code>Kernel.eval</code>, <code>Object.instance_eval</code>, e <code>Module.class_eval</code> todos aceitam um nome de arquivo (ou outra seqüência) e
um número de linha como os seus dois últimos argumentos. Se você está avaliando o código que você tenha extraído de um arquivo de algum tipo, você pode
usar esses argumentos para especificar os valores de <code>__FILE__</code> e <code>__LINE__</code> para a avaliação.</p>

<p>Você, sem dúvida, notou que quando uma exceção não tratada, a mensagem de erro impressa no console contém nome e informações de número de linha. Esta
informação é baseada em <strong>FILE</strong> e <strong>LINE</strong>, é claro. Cada Objeto de exceção tem um backtrace associado a ele que mostra exatamente onde ele foi criado,
onde o método que levantou a exceção foi invocado, onde esse método foi chamado, e assim por diante. O método <code>Exception.backtrace</code> retorna um <code>array</code> de
<code>strings</code> contendo essa informação. O primeiro elemento do <code>array</code> é este o local em que ocorreu a excepção, e cada elemento subsequente é um quadro de
pilha maior.</p>

<p>Você não precisa levantar uma exceção para obter um rastreamento da pilha atual, no entanto. O método <code>Kernel.caller</code> retorna o estadp atual na pilha de
chamadas da mesma forma como <code>Exception.backtrace</code>. Com nenhum argumento, o <code>caller</code> retorna um rastreamento de pilha, cujo primeiro elemento é o método
que chamou o método que chama de <code>caller</code>. Isto é, <code>caller[0]</code> especifica o local a partir do qual o método atual foi chamado. Você também pode chamar
de <code>caller</code> com um argumento que especifica quantos quadros de pilha a cair a partir do início do registo de <code>caller</code>. O padrão é <code>1</code>, e do
<code>caller(0)[0]</code> especifica o local em que o método <code>caller</code> é invocado. Isto significa, por exemplo, que o <code>caller[0]</code> é a mesma coisa que o
<code>caller(0)[1]</code> e que o <code>caller(2)</code> é o mesmo como <code>caller[1 .. -1]</code>.</p>

<p>Rastreamentos de pilha devolvidos por <code>Exception.backtrace</code> e <code>Kernel.caller</code> também incluem nomes de métodos. Antes de Ruby 1.9, você deve analisar as
seqüências de rastreamento de pilha para extrair nomes de métodos. No Ruby 1.9, no entanto, você pode obter o nome (como um símbolo) da execução
atual do método com <code>Kernel.__method__</code> ou seu sinônimo <code>Kernel.__callee__</code>. <code>__method__</code> é útil em conjunção com <strong>FILE</strong> e <strong>LINE</strong>:</p>

<figure class='code'><figcaption><span>raise</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">raise</span> <span class="s2">&quot;Assertion failed in </span><span class="si">#{</span><span class="n">__method__</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="bp">__FILE__</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="bp">__LINE__</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que <code>__method__</code> retorna o nome pelo qual um método foi originalmente definido, mesmo que o método foi invocado por um alias.</p>

<p>Em vez de simplesmente imprimi o nome e número em que ocorre um erro, você pode dar um passo adiante e mostrar a linha real de código. Se o seu programa
define uma constante global <code>SCRIPT_LINES__</code> e define-a igual a um <code>hash</code>, então os requisitos e métodos de carregar, adicionar uma entrada para este
<code>hash</code> para cada arquivo que carregar. As chaves de hash são nomes de arquivos e os valores associados com essas chaves são <code>arrays</code> que contêm as
linhas destes arquivos. Se você quiser incluir o arquivo principal (em vez que apenas incluir os arquivos que ele necessita), no <code>hash</code>, inicializá-lo
assim:</p>

<figure class='code'><figcaption><span>SCRIPT_LINES__</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SCRIPT_LINES__</span> <span class="o">=</span> <span class="p">{</span><span class="bp">__FILE__</span> <span class="o">=&gt;</span> <span class="no">File</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span><span class="bp">__FILE__</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se você fizer isso, então você pode obter a linha atual de código-fonte em qualquer lugar em seu programa com esta expressão:</p>

<figure class='code'><figcaption><span>SCRIPT_LINES__</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SCRIPT_LINES__</span><span class="o">[</span><span class="bp">__FILE__</span><span class="o">][</span><span class="bp">__LINE__</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ruby permite rastrear atribuições para variáveis globais com <code>Kernel.trace_var</code>. Passe este método um símbolo que dá nome a uma variável global e uma
<code>string</code> ou bloco de código. Quando o valor das alterações de nomes de variáveis, a cadeia de caracteres será avaliada ou o bloco será invocado. Quando
um bloco é especificado, o novo valor da variável é passado como um argumento. Para parar o rastreamento da variável, chame <code>Kernel.untrace_var</code>. No
seguinte exemplo, notar o uso de <code>caller[1]</code>, para determinar o local do programa em que o bloco de rastreamento da variável foi invocado:</p>

<figure class='code'><figcaption><span>variavies globais</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Imprime a mensagem de cada vez $ mudanças SAFE</span>
</span><span class='line'><span class="nb">trace_var</span><span class="p">(:</span><span class="vg">$SAFE</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;$SAFE set to </span><span class="si">#{</span><span class="n">v</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="nb">caller</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>O último método de rastreamento é <code>Kernel.set_trace_func</code>, que registra um <code>Proc</code> a ser chamado após cada linha de um programa Ruby. <code>set_trace_func</code>
é útil se você quer escrever um módulo depurador que permite que linha por linha de passo através de um programa, mas não vamos cobri-lo em detalhes aqui.</p>

<p>Até a proxima amigos&#8230; =D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Metodos de Visibilidade: Public, Protected, Private - #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/09/09/metodos-de-visibilidade-public/"/>
    <updated>2012-09-09T19:31:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/09/09/metodos-de-visibilidade-public</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Metodos de Visibilidade: Public, Protected, Private</b>&#8230;</p>




<h1>Metodos de Visibilidade: Public, Protected, Private</h1>


<!-- more -->


<p>Métodos de instância podem ser <code>public</code>, <code>private</code> ou <code>protected</code>. Se você já programou com outras linguagens orientadas a objeto, você já pode estar
familiarizado com esses termos. Preste atenção de qualquer maneira, porque estas palavras têm um significado um pouco diferente em Ruby do que em
outras Linguagens.</p>

<p>Métodos são normalmente <code>public</code> a menos que explicitamente declarado ser <code>private</code> ou <code>protected</code>. Uma exceção é o método <code>initialize</code>, que é sempre
implicitamente privada. Outra exceção é qualquer método &#8220;global&#8221; declarado fora de uma definição de classe desses métodos são definidos como métodos
privados de instância de objeto. Um método <code>public</code> pode ser chamado em qualquer lugar, não há restrições sobre seu uso.</p>

<p>Um método <code>private</code> é uma implementação interna de uma classe, e que só pode ser chamada por métodos de outra instância da classe (ou, como veremos
mais tarde, as suas subclasses). Métodos <code>private</code> são implicitamente invocado em si mesmo, e não podem ser explicitamente chamado em um objeto. Se <code>m</code>
é um método <code>private</code>, então você deve chamá-lo em estilo funcional como <code>m</code>. Você não pode escrever <code>o.m</code> ou mesmo <code>self.m</code>.</p>

<p>Um método <code>protected</code> é como um método <code>private</code> em que só pode ser chamado de dentro da implementação de uma classe ou suas subclasses. Ela difere de
um método <code>private</code> na medida em que pode ser explicitamente chamado em qualquer instância da classe, e ele não se restringe a invocação implícita em
si mesmo. Um método <code>protected</code> pode ser usado, por exemplo, para definir um acessor que permite que instâncias de uma classe podem compartilhar o
estado interno com o outro, mas não permite que os utilizadores de classe possam acessar esse estado.</p>

<p>Métodos <code>protected</code> são os menos comumente definido e também o mais difícil de entender. A regra sobre quando um método <code>protected</code> pode ser invocado
pode ser mais formalmente descritos como segue: um método <code>protected</code> definido por uma classe C pode ser invocado em um <code>objeto o</code> através de um método
em um <code>objeto p</code> se e somente se as classes de <code>o</code> e <code>p</code> são ambos subclasses ou iguais para, a classe C.</p>

<p>Métodos de visibilidade é declarado com três métodos chamados <code>public</code>, <code>private</code> e <code>protected</code>. Estes são os métodos de instância da Classe do módulo.
Todas as classes são módulos, e dentro de uma definição de classe, a classe auto-refere-se ao que está sendo definido. Assim, <code>public</code>, <code>private</code> e
<code>protected</code> pode ser usado como se fossem palavras-chave da linguagem. Em fato, no entanto, são chamadas de método em si. Há duas maneiras para chamar
esses métodos. Sem argumentos, eles especificam que todas as definições de método subsequentes terão a visibilidade especificada. Uma classe pode
usá-los como este:</p>

<figure class='code'><figcaption><span>Visibilidade de Metodos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Point</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Métodos públicos aqui</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Os seguintes métodos são protegidos</span>
</span><span class='line'><span class="err">  </span><span class="kp">protected</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Métodos protegidos aqui</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Os seguintes métodos são privados</span>
</span><span class='line'><span class="err">  </span><span class="kp">private</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Métodos privadas aqui</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Os métodos também podem ser invocados com os nomes de um ou mais métodos (como <code>symbols</code> ou <code>strings</code>) como argumentos. Quando chamado assim, eles
alteram a visibilidade dos métodos chamados. Neste uso, a declaração de visibilidade deve vir após a definição do método. Uma abordagem consiste em
declarar todos os métodos <code>private</code> e <code>protected</code> de uma só vez, no final de uma classe. Outra abordagem é declarar a visibilidade de cada método
<code>private</code> ou <code>protected</code> imediatamente após sua definição. Aqui, por exemplo, é uma classe com um método de utilidade <code>private</code> e um método de acesso
<code>protected</code>:</p>

<figure class='code'><figcaption><span>Visibilidade de Metodos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Widget</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">x</span>                       <span class="c1"># método de acesso para @x</span>
</span><span class='line'>    <span class="vi">@x</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="kp">protected</span> <span class="ss">:x</span>                <span class="c1"># Faça-o protegido</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">utility_method</span>          <span class="c1"># Define um método</span>
</span><span class='line'>    <span class="kp">nil</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="kp">private</span> <span class="ss">:utility_method</span>     <span class="c1"># E torná-lo privado</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lembre-se que <code>public</code>, <code>private</code> e <code>protected</code> aplicam-se apenas aos métodos em Ruby. Variáveis de instância e de classe são encapsuladas e
efetivamente <code>private</code>, e constantes são efetivamente <code>public</code>. Não há nenhuma maneira de fazer uma variável de instância acessível a partir de fora de
uma classe (exceto pela definição de um método de acesso, é claro). E não há maneira de definir uma constante que é inacessível para uso externo.</p>

<p>Ocasionalmente, é útil para especificar que um método de classe deve ser privado. Se sua classe define métodos de fábrica, por exemplo, você pode
querer fazer o novo método <code>private</code>. Para fazer isso, use o método <code>private_class_method</code>, especificando um ou mais nomes de métodos como símbolos:</p>

<figure class='code'><figcaption><span>private_class_method</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">private_class_method</span> <span class="ss">:new</span>
</span></code></pre></td></tr></table></div></figure>


<p>Você pode tornar público um método <code>private</code> de classe novamente com <code>public_class_method</code>. Nenhum método pode ser chamado sem argumentos na forma que
o <code>public</code>, <code>protected</code> e <code>private</code> pode ser.</p>

<p>Ruby é, por definição, uma linguagem muito aberta. A capacidade de especificar que alguns métodos são <code>private</code> e <code>protected</code> encoraja p bom estilo de
programação, e evita o uso inadvertido de métodos que não fazem parte da API pública de uma classe. É importante entender, no entanto, que os recursos
de metaprogramação de Ruby tornam trivial para invocar métodos <code>private</code> e <code>protected</code> e até mesmo para acessar variáveis de instância encapsuladas.
Para chamar o método <code>private</code> <code>utility</code> definida no código anterior, você pode usar o método de envio, ou você pode usar <code>instance_eval</code> para avaliar
um bloco no contexto do objeto:</p>

<figure class='code'><figcaption><span>instance_eval</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">w</span> <span class="o">=</span> <span class="no">Widget</span><span class="o">.</span><span class="n">new</span>                      <span class="c1"># Criar um Widget</span>
</span><span class='line'><span class="n">w</span><span class="o">.</span><span class="n">send</span> <span class="ss">:utility_method</span>              <span class="c1"># Invoke método privado!</span>
</span><span class='line'><span class="n">w</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="n">utility_method</span> <span class="p">}</span>  <span class="c1"># Outra forma de invocá-lo</span>
</span><span class='line'><span class="n">w</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="vi">@x</span> <span class="p">}</span>              <span class="c1"># Ler variável de instância de w</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se você quiser chamar um método pelo nome, mas você não quer inadvertidamente invocar um método <code>private</code> que você não sabe aproximadamente, você pode
(no Ruby 1.9) usar <code>public_send</code> em vez de <code>send</code>. Ele funciona como <code>send</code>, mas não invoca métodos <code>private</code> quando chamado com um receptor
específico.</p>

<p>É isso ai amigos&#8230;</p>

<p>Até o proximo.. =D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflexão e Metaprogramação - Hooks - #Ruby 1.9 - Part V]]></title>
    <link href="http://rrmartins.github.com/blog/2012/09/05/reflexao-e-metaprogramacao-hooks-number-ruby-1-dot-9-part-v/"/>
    <updated>2012-09-05T23:04:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/09/05/reflexao-e-metaprogramacao-hooks-number-ruby-1-dot-9-part-v</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Hooks</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Hooks</h1>


<p><code>Class</code>, <code>Module</code>, e os vários métodos de retorno da chamada do <code>Objectimplement</code>, ou <code>hooks</code>. Estes métodos não são definidos por padrão, mas se você
defini-los para um módulo de classe, ou objeto, então eles vão ser invocados quando ocorrerem determinados eventos. Isso lhe dá uma oportunidade para
estender o comportamento de Ruby quando as classes são uma subclasse, quando os módulos estão incluídos, ou quando os métodos são definidos. Métodos de
<code>hook</code> (exceto para alguns mais preteridos não descritos aqui) têm nomes que terminam em &#8220;ed&#8221;.</p>

<!-- more -->


<p>Quando uma nova classe é definida, Ruby chama o método de classe herdada na superclasse da nova classe, passando o objeto da nova classe como
argumento. Isso permite adicionar classes para comportamento ou impor restrições sobre seus descendentes. Lembre-se que os método de classe são
herdados, de modo que a um método herdado será chamado se ele é definido por qualquer um dos antepassados da nova classe. Definir <code>Object.inherited</code>
para receber a notificação de todas as novas classes que são definidas:</p>

<figure class='code'><figcaption><span>Object.inherited</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nc">Object</span><span class="o">.</span><span class="nf">inherited</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;class </span><span class="si">#{</span><span class="n">c</span><span class="si">}</span><span class="s2"> &lt; </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Quando um módulo é incluído numa classe ou em outro módulo, o método da classe incluída do módulo incluído é chamado com o objeto de classe ou módulo
em que foi incluído como um argumento. Isto dá o módulo incluído uma oportunidade para aumentar ou alterar a classe da maneira que ele efetivamente
quer ser permitido que um módulo define o seu próprio significado para incluir. Além da adição de métodos para a classe em que se insere, um módulo com
um método incluído também que pode alterar os métodos existentes dessa classe, por exemplo:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Final</span>             <span class="c1"># Uma classe que inclui Final não pode ser uma subclasse</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>   <span class="c1"># Quando incluídos na classe C</span>
</span><span class='line'>    <span class="n">c</span><span class="o">.</span><span class="n">instance_eval</span> <span class="k">do</span>   <span class="c1"># Defini um método de classe de c</span>
</span><span class='line'>      <span class="k">def</span> <span class="nf">inherited</span><span class="p">(</span><span class="nb">sub</span><span class="p">)</span> <span class="c1"># Para detectar subclasses</span>
</span><span class='line'>        <span class="k">raise</span> <span class="no">Exception</span><span class="p">,</span> <span class="c1"># E abortar com uma exceção</span>
</span><span class='line'>              <span class="s2">&quot;Tentativa de criar subclasse </span><span class="si">#{</span><span class="nb">sub</span><span class="si">}</span><span class="s2"> da classe final </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Da mesma forma, se um módulo de classe define um método chamado <code>extended</code>, este método será invocado em qualquer momento que o módulo é utilizado para
estender um objeto (com <code>Object.extend</code>). O argumento para o método de extensão será o objeto que foi estendido, é claro, e do método estendido pode
tomar quaisquer ações que quer o objeto.</p>

<p>Além de <code>hooks</code> para rastreiar as classes e os módulos que incluem, também existem <code>hooks</code> para rastrear os métodos de classes e módulos e os únicos
métodos de objetos arbitrários. Defini um método de classe chamado <code>method_added</code> para qualquer classe ou módulo e ele será chamado quando um método de
instância é definido para essa classe ou módulo:</p>

<figure class='code'><figcaption><span>method_added</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nc">String</span><span class="o">.</span><span class="nf">method_added</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;New instance method </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> added to String&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que o método da classe <code>method_added</code> é herdado pelas subclasses da classe em que ele está definido. Mas nenhum argumento de classe é passado
para o <code>hook</code>, pelo que não há maneira de dizer se o método chamado foi adicionado à classe que define <code>method_added</code> ou se ela foi adicionada a uma
subclasse desta classe. A solução para este problema é definir um <code>hook</code> que herda em qualquer classe uma definição de um <code>hook</code> <code>method_added</code>.
O método pode então ser herdado um método que defini <code>method_added</code> para cada subclasse.</p>

<p>Quando um método <code>singleton</code> é definido para qualquer objeto, o método <code>singleton_method_added</code> é invocado sobre o objeto, passando o nome do novo
método. Lembre-se que para as classes, métodos <code>singleton</code> são métodos de classe:</p>

<figure class='code'><figcaption><span>singleton_method_added</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nc">String</span><span class="o">.</span><span class="nf">singleton_method_added</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;New class method </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> added to String&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Curiosamente, Ruby invoca esse <code>hook</code> <code>singleton_method_added</code> quando o método de <code>hook</code> em si é definido previamente. Aqui é um outro uso do <code>hook</code>.
Neste caso, <code>singleton_method_added</code> é definido como um método de instância de uma classe que inclui um módulo. É notificado de qualquer métodos
<code>singleton</code> adicionados a instâncias da classe:</p>

<figure class='code'><figcaption><span>singleton_method_added</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Incluindo este módulo em uma classe impede que instâncias da classe</span>
</span><span class='line'><span class="c1"># De ter métodos singleton adicionados a eles. Quaisquer métodos singleton acrescentados</span>
</span><span class='line'><span class="c1"># São imediatamente removidos novamente.</span>
</span><span class='line'><span class="k">module</span> <span class="nn">Strict</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">singleton_method_added</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>    <span class="no">STDERR</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Warning: singleton </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> added to a Strict object&quot;</span>
</span><span class='line'>    <span class="n">eigenclass</span> <span class="o">=</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>    <span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">remove_method</span> <span class="nb">name</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Além de <code>method_added</code> e <code>singleton_method_added</code>, há <code>hook</code> para rastreamento quando os métodos de instância e métodos <code>singleton</code> são removidos ou
indefinidos. Quando um método de instância é removido ou indefinido em uma classe ou módulo, os métodos de classe <code>method_removed</code> e <code>method_undefined</code>
são invocados nesse módulo. Quando um método <code>singleton</code> é removido ou indefinido em um objeto, os métodos <code>singleton_method_removed</code> e
<code>singleton_method_undefined</code> são invocados nesse objeto.</p>

<p>Por fim, note que os métodos <code>method_missing</code> e <code>const_missing</code> também se comportam como métodos de <code>hook</code>.</p>

<p>Até o proximos amigos!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflexão e Metaprogramação - Metodos - #Ruby 1.9 - Part IV]]></title>
    <link href="http://rrmartins.github.com/blog/2012/08/31/reflexao-e-metaprogramacao-metodos-number-ruby-1-dot-9-part-iv/"/>
    <updated>2012-08-31T20:12:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/08/31/reflexao-e-metaprogramacao-metodos-number-ruby-1-dot-9-part-iv</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Métodos</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Métodos</h1>


<p>As classes de <code>Object</code> e <code>Module</code> de definir uma série de métodos para a listagem, de consulta, invocanção, e definição de métodos. Vamos considerar
cada categoria, por sua vez.</p>

<!--more-->


<h3>Listagem e Teste para Métodos</h3>


<p><code>Object</code> define métodos para listar os nomes dos métodos definidos no objeto. Estes métodos retornam <code>arrays</code> de nomes de métodos. Aqueles nomes são
<code>strings</code> em <code>Ruby 1.8</code> e <code>symbols</code> no <code>Ruby 1.9</code>:</p>

<figure class='code'><figcaption><span>Listagem de Metodos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span> <span class="o">=</span> <span class="s2">&quot;a string&quot;</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">methods</span>                <span class="c1"># =&gt; [nomes de todos os métodos públicos]</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">public_methods</span>         <span class="c1"># =&gt; é a mesma coisa</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">public_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>  <span class="c1"># Excluir métodos herdados</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">protected_methods</span>      <span class="c1"># =&gt; []: não há qualquer</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">private_methods</span>        <span class="c1"># =&gt; array de todos os métodos privados</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">private_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="c1"># Excluir herdados métodos privados</span>
</span><span class='line'><span class="k">def</span> <span class="nc">o</span><span class="o">.</span><span class="nf">single</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="k">end</span>     <span class="c1"># Definir um método singleton</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">singleton_methods</span>      <span class="c1"># =&gt; [&quot;single&quot;] (ou: em 1,9 [único])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Também é possível consultar uma classe para os métodos que ele define em vez de consultar uma instância da classe. A seguir os métodos são definidos
por módulo. Como os métodos de objeto, eles retornam <code>arrays</code> de <code>strings</code> em <code>Ruby 1.8</code> e <code>arrays</code> de <code>symbols</code> em <code>Ruby 1.9</code>:</p>

<figure class='code'><figcaption><span>Consultando uma Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">instance_methods</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="o">.</span><span class="n">public_methods</span>                <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="o">.</span><span class="n">public_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>  <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">public_instance_methods</span> <span class="o">==</span> <span class="nb">String</span><span class="o">.</span><span class="n">instance_methods</span>    <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">protected_instance_methods</span>                                                <span class="c1"># =&gt; []</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">private_instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>                                         <span class="c1"># =&gt; [:initialize, :initialize_copy] </span>
</span></code></pre></td></tr></table></div></figure>


<p>Lembre-se que os métodos de classe de uma <code>class</code> ou <code>module</code> são métodos <code>singleton</code> do objeto de <code>class</code> ou <code>module</code>. Então, para listar métodos de
classe, usa <code>Object.singleton_methods</code>:</p>

<figure class='code'><figcaption><span>Singleton</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">singleton_methods</span> <span class="c1"># =&gt; [:atan2, :cos, :sin, :tan, :acos, :asin, :atan, :cosh, :sinh, </span>
</span><span class='line'>                                                       <span class="ss">:tanh</span><span class="p">,</span> <span class="ss">:acosh</span><span class="p">,</span> <span class="ss">:asinh</span><span class="p">,</span> <span class="ss">:atanh</span><span class="p">,</span> <span class="ss">:exp</span><span class="p">,</span> <span class="ss">:log</span><span class="p">,</span> <span class="ss">:log2</span><span class="p">,</span> <span class="ss">:log10</span><span class="p">,</span> <span class="ss">:sqrt</span><span class="p">,</span>
</span><span class='line'>                                                       <span class="ss">:cbrt</span><span class="p">,</span> <span class="ss">:frexp</span><span class="p">,</span> <span class="ss">:ldexp</span><span class="p">,</span> <span class="ss">:hypot</span><span class="p">,</span> <span class="ss">:erf</span><span class="p">,</span> <span class="ss">:erfc</span><span class="p">,</span> <span class="ss">:gamma</span><span class="p">,</span> <span class="ss">:lgamma</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para além destes métodos de listagem, a classe <code>Module</code> define alguns predicados para testar se uma classe especificada ou módulo define um método de
instância nomeada:</p>

<figure class='code'><figcaption><span>Testando metodo de classe</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">public_method_defined?</span> <span class="ss">:reverse</span>     <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">protected_method_defined?</span> <span class="ss">:reverse</span>  <span class="c1"># =&gt; false</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">private_method_defined?</span> <span class="ss">:initialize</span> <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">method_defined?</span> <span class="ss">:upcase!</span>            <span class="c1"># =&gt; true</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Module.method_defined?</code> verifica se o método chamado é definido como um método público ou protegido. Ele serve, essencialmente, com mesma finalidade
que <code>Object.respond_to?</code>. No <code>Ruby 1.9</code>, você pode passar <code>false</code> como o segundo argumento para especificar que os métodos herdados não deve ser
considerados.</p>

<h3>Obtenção de método de objetos</h3>


<p>Para consultar um método específico nomeado, chamar o método em qualquer objeto ou <code>instance_method</code> em qualquer módulo. O primeiro retorna um
objeto do Método exigído pelo receptor, e o último retorna um <code>UnboundMethod</code>. No <code>Ruby 1.9</code>, você pode limitar sua pesquisa aos métodos públicos
métodos chamando <code>public_method</code> e <code>public_instance_method</code>. Nós cobrimos esses métodos e os objetos que eles voltam no Método do Objeto:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;s&quot;</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="ss">:reverse</span><span class="p">)</span>             <span class="c1"># =&gt; objeto Método</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">instance_method</span><span class="p">(</span><span class="ss">:reverse</span><span class="p">)</span> <span class="c1"># =&gt; objeto UnboundMethod</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Invocando Métodos</h3>


<p>Como observado anteriormente, e em métodos de objetos, você pode usar o método <code>method</code> de qualquer objeto para obter um objeto que representa
<code>Method</code> de objeto. Objetos <code>Method</code> têm um método <code>call</code> assim como objetos <code>Proc</code> fazem, você pode usá-lo para chamar o método.</p>

<p>Normalmente, é mais simples para invocar um método chamado de um objeto especificado com <code>send</code>:</p>

<figure class='code'><figcaption><span>Send</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">send</span> <span class="ss">:upcase</span>        <span class="c1"># =&gt; &quot;hello&quot;: invocar um método de instância</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:sin</span><span class="p">,</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># =&gt; 1.0: invocar um método de classe</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>send</code> invoca em seu receptor o método nomeado pelo seu primeiro argumento, passando quaisquer argumentos restantes a esse método. O nome <code>send</code>
deriva da linguagem orientada a objetos em que invocando um método é chamado, enviando uma mensagem, a um objeto.</p>

<p><code>send</code> pode invocar qualquer método chamando um objeto, incluindo métodos privados e protegidos. Vimos <code>send</code> utilizado anteriormente para invocar o
método privado <code>remove_const</code> de um objeto <code>Module</code>. Porque funções globais são realmente métodos privados de <code>Object</code>, podemos usar <code>send</code> para
chamar esses métodos em qualquer objeto (embora isso não é algo que nós, nunca realmente queremos fazer):</p>

<figure class='code'><figcaption><span>Send</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">send</span> <span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;world&quot;</span>         <span class="c1"># imprime &quot;world&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ruby 1.9 define <code>public_send</code> como uma alternativa para <code>send</code>. Este método funciona como <code>send</code>, mas só irá chamar os métodos públicos, não
métodos privados ou protegidos:</p>

<figure class='code'><figcaption><span>public_send_</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">public_send</span> <span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;world&quot;</span>  <span class="c1"># raises NoMethodError</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>send</code> é um método fundamental do objeto, mas tem um nome comum que pode ser substituído em subclasses. Portanto, Ruby
define <code>__send__</code> como um sinônimo, e emite um aviso se você tentar excluir ou redefinir <code>__send__</code>.</p>

<h3>Definindo, Indefinindo e Métodos Alias</h3>


<p>Se você quiser definir um novo método de instância de uma classe ou módulo, utilize <code>define_method</code>. Este método de instância de <code>Module</code> leva o
nome do novo método (como um <code>symbol</code>), como seu primeiro argumento. O corpo do método é fornecido seja por um método importante que entendemos o
<code>define_method</code> que é privado. Você deve estar dentro da classe ou módulo que pretende usá-lo para chamá-lo:</p>

<figure class='code'><figcaption><span>define_method</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Adicione um método de instância chamado m para a Classe C com o corpo b</span>
</span><span class='line'><span class="k">def</span> <span class="nf">add_method</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'>  <span class="n">c</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">define_method</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">add_method</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="ss">:greet</span><span class="p">)</span> <span class="p">{</span> <span class="s2">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="nb">self</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="s2">&quot;world&quot;</span><span class="o">.</span><span class="n">greet</span>   <span class="c1"># =&gt; &quot;Hello, world&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para definir um método de classe (ou qualquer método <code>singleton</code>) com <code>define_method</code>, invocá-lo no <code>eigenclass</code>:</p>

<figure class='code'><figcaption><span>eigenclass</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">add_class_method</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'>  <span class="n">eigenclass</span> <span class="o">=</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>  <span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">define_method</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">add_class_method</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="ss">:greet</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="s2">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="nb">name</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">greet</span><span class="p">(</span><span class="s2">&quot;world&quot;</span><span class="p">)</span>  <span class="c1"># =&gt; &quot;Hello, world&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.9, você pode usar mais facilmente <code>define_singleton_method</code>, que é um método de objeto:</p>

<figure class='code'><figcaption><span>define_singleton_method</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">define_singleton_method</span><span class="p">(</span><span class="ss">:greet</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="s2">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="nb">name</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Uma deficiência do <code>define_method</code> é que ele não permite que você especifique um corpo de método que espera um bloco. Se você precisar dinamicamente
criar um método que aceita um bloco, você vai precisar usar a instrução <code>def</code> com <code>class_eval</code>. E se o método que está criando é suficientemente
dinâmico, você pode não ser capaz de passar um bloco para o <code>class_eval</code> e em vez disso tem de especificar a definição do método como uma seqüência
a ser avaliada.</p>

<p>Para criar um sinônimo ou um <code>alias</code> para um método existente, normalmente você pode usar a declaração <code>alias</code>:</p>

<figure class='code'><figcaption><span>alias </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">alias</span> <span class="s2">&quot;plus&quot;</span> <span class="o">+</span>         <span class="c1"># &quot;plus&quot; é um sinônimo para o operador +</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ao programar dinamicamente, no entanto, às vezes você precisa usar <code>alias_method</code>. Como <code>define_method</code>, <code>alias_method</code> é um método particular do
<code>Module</code>. Como método, ele pode aceitar duas expressões arbitrárias como seus argumentos, em vez de exigir dois identificadores para ser codificado
em seu código fonte. Como método, também requer uma vírgula entre seus argumentos. É <code>alias_method</code> muitas vezes utilizados para métodos de
encadeamento de alias existentes. Aqui está um exemplo simples:</p>

<figure class='code'><figcaption><span>alias_method</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Crie um alias para o método m da classe (ou módulo) c</span>
</span><span class='line'><span class="k">def</span> <span class="nf">backup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="ss">:&quot;</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="ss">_</span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="ss">&quot;</span>    <span class="c1"># Calcule o alias</span>
</span><span class='line'>  <span class="n">c</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span>           <span class="c1"># Porque alias_method é privado</span>
</span><span class='line'>    <span class="n">alias_method</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span>      <span class="c1"># Fazer n um alias para m</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">backup</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="ss">:reverse</span><span class="p">)</span>
</span><span class='line'><span class="s2">&quot;test&quot;</span><span class="o">.</span><span class="n">original_reverse</span> <span class="c1"># =&gt; &quot;tset&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Você pode usar a declaração <code>undef</code> para indefinir um método. Isso só funciona se você pode expressar o nome de um método como um identificador
codificado no programa. Se você precisar excluir dinamicamente um método cujo nome tem sido calculado pelo seu programa, você tem duas opções: ou
<code>remove_method</code> ou <code>undef_method</code>. Ambos são métodos privados de Módulo. <code>remove_method</code> remove a definição do método a partir da classe corrente.
Se existe uma versão definida por uma superclasse, que a versão vai agora ser herdada. <code>undef_method</code> é mais grave, que impede qualquer invocação do
método especificado por meio de uma instância da classe, mesmo se houver uma versão herdada do método.</p>

<p>Se você definir uma classe e quer evitar alterações dinâmicas para ele, simplesmente chame o método <code>freeze</code> da classe. Uma vez &#8220;congelado&#8221;, a classe
não pode ser alterada.</p>

<h3>Manipulação de métodos indefinidos</h3>


<p>Quando o método do algoritmo de resolução de nomes não consegue encontrar um método, ele procura um método chamado <code>method_missing</code> em vez disso.
Quando este método é chamado, o primeiro argumento é um <code>simbol</code> que dá nome ao método que não pôde ser encontrado. Este <code>simbol</code> é seguido por todos
os argumentos que deveriam ser passados para o método original. Se houver um bloqueio associado com o método de invocação, que também é passado para
 o bloco <code>method_missing</code>.</p>

<p>A implementação padrão de <code>method_missing</code>, no módulo de <code>Kernel</code>, simplesmente levanta um <code>NoMethodError</code>. Essa exceção, se não detectada, faz com
que o programa possa sair com uma mensagem de erro, que é o que você normalmente espera que aconteça quando você tenta invocar um que método não
existe.</p>

<p>Definindo seu próprio método <code>method_missing</code> para uma classe que permite a você uma oportunidade de lidar com qualquer tipo de chamada em casos da
classe. O gancho <code>method_missing</code> é um dos mais poderosos do Ruby com capacidades dinâmicas, e um dos mais vulgarmente utilizado nas técnicas
de metaprogramação. O código de exemplo a seguir adiciona um método <code>method_missing</code> à classe <code>Hash</code>. Ela nos permite consultar ou definir o valor de
qualquer chave chamada como se a chave fosse o nome de um método:</p>

<figure class='code'><figcaption><span>Hash Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Hash</span>
</span><span class='line'>  <span class="c1"># Permiti valores de hash para ser consultado e definido como se fossem atributos.</span>
</span><span class='line'>  <span class="c1"># Simulamos getters e setters para atributos de qualquer tecla.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>    <span class="n">text</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="n">text</span><span class="o">[-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span>               <span class="c1"># Se termina com chave = definir um valor</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">[</span><span class="n">text</span><span class="o">.</span><span class="n">chop</span><span class="o">.</span><span class="n">to_sym</span><span class="o">]</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="c1"># Faixa de chave</span>
</span><span class='line'>    <span class="k">else</span> <span class="c1"># Caso contrário ...</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">[</span><span class="n">key</span><span class="o">]</span>                        <span class="c1"># ... apenas retornar o valor da chave</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>                <span class="c1"># Criar um objeto vazio de hash</span>
</span><span class='line'><span class="n">h</span><span class="o">.</span><span class="n">one</span> <span class="o">=</span> <span class="mi">1</span>          <span class="c1"># O mesmo que h[:one] = 1</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">h</span><span class="o">.</span><span class="n">one</span>     <span class="c1"># Imprime 1. Mesmo que põe h[:one]</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Definir Visibilidade do Método</h3>


<p>Visibilidades de método: <code>Public</code>, <code>Protected</code>, <code>Private</code> introduzindo o <code>public</code>, <code>protected</code>, e <code>private</code>. Parecem palavras-chave da linguagem, mas
são na verdade métodos de instância privados definidos pelo módulo. Estes métodos são geralmente utilizados como uma parte estática da definição de
uma classe. Mas, com <code>class_eval</code>, eles também podem ser usados dinamicamente:</p>

<figure class='code'><figcaption><span>class_eval com Visibilidade de Metodo</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="kp">private</span> <span class="ss">:reverse</span> <span class="p">}</span>
</span><span class='line'><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">reverse</span>  <span class="c1"># NoMethodError: private method &#39;reverse&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>private_class_method`` e</code>public_class_method` são semelhantes, exceto que eles operam em métodos de classe e são eles métodos públicos:</p>

<figure class='code'><figcaption><span>Matematica</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Fazer todos os métodos de Matemática privados</span>
</span><span class='line'><span class="c1"># Agora temos que incluem matemática, a fim de chamar seus métodos</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">private_class_method</span> <span class="o">*</span><span class="no">Math</span><span class="o">.</span><span class="n">singleton_methods</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos, um post, para introduzir o #StartupDevRumble .. =D</p>

<p>Até o proximo!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflexão e Metaprogramação - Variáveis e Constantes - #Ruby 1.9 - Part III]]></title>
    <link href="http://rrmartins.github.com/blog/2012/08/29/reflexao-e-metaprogramacao-number-ruby-1-dot-9-part-iii/"/>
    <updated>2012-08-29T23:34:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/08/29/reflexao-e-metaprogramacao-number-ruby-1-dot-9-part-iii</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Variáveis e constantes</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Variáveis e Constantes</h1>


<!-- more -->


<p><code>Kernel</code>, <code>Object</code>, <code>Module</code> definem métodos reflexivos para listar os nomes (como <code>strings</code>) de todas as variáveis definidas globais, atualmente
variáveis locais definidas, todas as variáveis de instância de um objeto, todas as variáveis de classe de uma classe ou módulo, e todas as constantes
de uma classe ou módulo:</p>

<figure class='code'><figcaption><span>Variaveis e Constantes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">global_variables</span>   <span class="c1"># =&gt; [&quot;$DEBUG&quot;, &quot;$SAFE&quot;, ...]</span>
</span><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>              <span class="c1"># Define uma variável local</span>
</span><span class='line'><span class="nb">local_variables</span>    <span class="c1"># =&gt; [&quot;x&quot;]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Define uma classe simples</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Point</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> <span class="vi">@x</span><span class="p">,</span><span class="vi">@y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span> <span class="k">end</span> <span class="c1"># define variáveis de instância</span>
</span><span class='line'><span class="err">  </span><span class="vc">@@classvar</span> <span class="o">=</span> <span class="mi">1</span>                        <span class="c1"># Define uma variável de classe</span>
</span><span class='line'><span class="err">  </span><span class="no">ORIGIN</span> <span class="o">=</span> <span class="no">Point</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>               <span class="c1"># Define uma constante</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Point</span><span class="o">::</span><span class="no">ORIGIN</span><span class="o">.</span><span class="n">instance_variables</span> <span class="c1"># =&gt; [&quot;@y&quot;, &quot;@x&quot;]</span>
</span><span class='line'><span class="no">Point</span><span class="o">.</span><span class="n">class_variables</span>            <span class="c1"># =&gt; [&quot;@@classvar&quot;]</span>
</span><span class='line'><span class="no">Point</span><span class="o">.</span><span class="n">constants</span>                  <span class="c1"># =&gt; [&quot;ORIGIN&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Os <code>global_variables</code>, <code>local_variables</code>, <code>instance_variables</code>, <code>class_variables</code> e métodos constantes retornam <code>arrays</code> de <code>strings</code> em Ruby 1.8 e
<code>arrays</code> de símbolos no Ruby 1.9.</p>

<h3>Consultando, Configuração e testando Variáveis</h3>


<p>Além das variáveis listadas definidos e constantes, <code>object</code> e <code>Module</code> em Ruby também definem métodos de reflexão para consultas, a criação e
remoção de variáveis de instância, variáveis de classe e constantes. Não há métodos de propósito específico para consultar ou definir as variáveis
locais ou variáveis globais, mas você pode usar o método <code>eval</code> para esta finalidade:</p>

<figure class='code'><figcaption><span>Configurando Variavel</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="n">varname</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span>
</span><span class='line'><span class="nb">eval</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>           <span class="c1"># =&gt; 1</span>
</span><span class='line'><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;varname = &#39;$g&#39;&quot;</span><span class="p">)</span>  <span class="c1"># Ajuste o &quot;$g&quot;</span>
</span><span class='line'><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">varname</span><span class="si">}</span><span class="s2"> = x&quot;</span><span class="p">)</span>  <span class="c1"># Seta $g a 1</span>
</span><span class='line'><span class="nb">eval</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note que <code>eval</code> avalia o seu código em um âmbito temporário. <code>eval</code> pode alterar o valor das variáveis locais que já existem. Mas qualquer nova
variável local definida pelo código avaliado, são locais para a invocação do <code>eval</code> e deixam de existir quando ele retorna. (É como se o código
avaliado é executado no corpo de um bloco de variáveis-locais para um bloco não existem fora do bloco.)</p>

<p>Você pode consultar, definir e testar a existência de variáveis de instância em qualquer objeto e de variáveis de classe e constantes em qualquer
classe ou módulo:</p>

<figure class='code'><figcaption><span>Consultar Variavel</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">instance_variable_set</span><span class="p">(</span><span class="ss">:@x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># Nota exigido o prefixo @</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="ss">:@x</span><span class="p">)</span>      <span class="c1"># =&gt; 0</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">instance_variable_defined?</span><span class="p">(</span><span class="ss">:@x</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
</span><span class='line'>
</span><span class='line'><span class="no">Object</span><span class="o">.</span><span class="n">class_variable_set</span><span class="p">(</span><span class="ss">:@@x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Privado no Ruby 1.8</span>
</span><span class='line'><span class="no">Object</span><span class="o">.</span><span class="n">class_variable_get</span><span class="p">(</span><span class="ss">:@@x</span><span class="p">)</span>      <span class="c1"># Privado no Ruby 1.8</span>
</span><span class='line'><span class="no">Object</span><span class="o">.</span><span class="n">class_variable_defined?</span><span class="p">(</span><span class="ss">:@@x</span><span class="p">)</span> <span class="c1"># =&gt; true; Ruby 1.9 e versões mais novas</span>
</span><span class='line'>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">const_set</span><span class="p">(</span><span class="ss">:EPI</span><span class="p">,</span> <span class="no">Math</span><span class="o">::</span><span class="n">E</span><span class="o">*</span><span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">const_get</span><span class="p">(</span><span class="ss">:EPI</span><span class="p">)</span>             <span class="c1"># =&gt; 8,53973422267357</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">const_defined?</span> <span class="ss">:EPI</span>         <span class="c1"># =&gt; true</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.9, você pode passar <code>false</code> como o segundo argumento para <code>const_get</code> e <code>const_defined?</code> para especificar que esses métodos devem olhar
apenas para a classe atual ou módulo e não deve considerar constantes herdadas.</p>

<p>Os métodos para consultar e configurar as variáveis de classe são privadas no Ruby 1.8. Nessa versão, você pode invocá-las com <code>class_eval</code>:</p>

<figure class='code'><figcaption><span>class_eval</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">class_variable_set</span><span class="p">(</span><span class="ss">:@@x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>  <span class="c1"># Seta @@x em String</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">class_variable_get</span><span class="p">(</span><span class="ss">:@@x</span><span class="p">)</span> <span class="p">}</span>     <span class="c1"># =&gt; 1</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Object</code> e <code>Module</code> definem métodos privados para variáveis de instância indefinidas, variáveis de classe e constantes. Todos eles retornam o valor
da variável ou constante removida. Como esses métodos são privados, não pode invocá-los diretamente em um objeto, classe ou módulo, e você deve usar
um método eval ou o método de envio:</p>

<figure class='code'><figcaption><span>instance_eval</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="n">remove_instance_variable</span> <span class="ss">:@x</span> <span class="p">}</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">remove_class_variable</span><span class="p">(</span><span class="ss">:@@x</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">send</span> <span class="ss">:remove_const</span><span class="p">,</span> <span class="ss">:EPI</span>  <span class="c1"># Usa send para chamar o método privado</span>
</span></code></pre></td></tr></table></div></figure>


<p>O método <code>const_missing</code> de um módulo é invocado, se houver um, quando uma referência é feita a uma constante indefinida. Você pode definir este
método para retornar o valor da constante chamada. (Esta característica pode ser usada, por exemplo, para implementar uma facilidade autoload em que
as classes ou módulos são carregados sob demanda). Aqui está um exemplo mais simples:</p>

<figure class='code'><figcaption><span>cons_missing</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nc">Symbol</span><span class="o">.</span><span class="nf">const_missing</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="nb">name</span> <span class="c1"># Retorna o nome da constante como um símbolo</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="no">Symbol</span><span class="o">::</span><span class="no">Test</span>   <span class="c1"># =&gt;: Teste: constante indefinida avalia um símbolo</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos&#8230; Bora continuar estudando!</p>

<p>Em breve, irei postar um pouco sobre Engenharia! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflexão e Metaprogramação - Avaliando Strings e Blocos - #Ruby 1.9 - Part II]]></title>
    <link href="http://rrmartins.github.com/blog/2012/08/29/reflexao-e-metaprogramacao-number-ruby-1-dot-9-part-ii/"/>
    <updated>2012-08-29T22:15:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/08/29/reflexao-e-metaprogramacao-number-ruby-1-dot-9-part-ii</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Avaliando Strings e Blocos</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Avaliando Strings e Blocos</h1>


<!-- more -->


<p>Um dos mais poderosos reflexivos e de características direta do Ruby, é seu método <code>eval</code>. Se o seu programa Ruby pode gerar uma seqüência de código
válido Ruby, o método <code>Kernel.eval</code> pode avaliar que o código:</p>

<figure class='code'><figcaption><span>Kernel.eval</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="nb">eval</span> <span class="s2">&quot;x + 1&quot;</span>  <span class="c1"># =&gt; 2</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>eval</code> é uma função poderosa, mas ao menos que você realmente está escrevendo um programa <code>shell</code> (como irb) que executa as linhas de códigos Ruby
inserido por um usuário é improvável que você realmente precisa. (E em um contexto de rede, quase nunca é seguro para chamar <code>eval</code> no texto recebido
de um usuário, que podia conter um código malicioso). Programadores inexperientes, por vezes, acabam usando eval como uma muleta. Se você tiver que<br/>
usá-lo em seu código, ver se não há uma maneira de evitá-lo. Dito isto, há algumas maneiras mais úteis para usar métodos <code>eval</code> e <code>eval-like</code>.</p>

<h3>Associações e eval</h3>


<p>Um objeto de Associação, representa o estado de variáveis <code>bindings</code> de Ruby em algum momento. O objeto <code>Kernel.binding</code> retorna as ligações em vigor
no local da chamada. Você pode passar um objeto de associação como o segundo argumento para <code>eval</code>, e a <code>String</code> especificada será avaliada no
contexto dessas ligações. Se, por exemplo, definir um método de instância que retorna um objeto <code>Binding</code> que representa a variável de ligações
dentro de um objeto, então nós podemos usar essas ligações para consultar e definir as variáveis de instância do objeto. Podemos conseguir isso como segue:</p>

<figure class='code'><figcaption><span>Binding</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Object</span> <span class="c1"># Abre objeto para adicionar um novo método</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">bindings</span> <span class="c1"># Nota plural sobre este método</span>
</span><span class='line'><span class="err">    </span><span class="nb">binding</span> <span class="c1"># Este é o método de Kernel predefinido</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Test</span> <span class="c1"># Uma classe simples com uma variável de instância</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="vi">@x</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="no">Test</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># Criar um objeto test</span>
</span><span class='line'><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;@x&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">bindings</span><span class="p">)</span>  <span class="c1"># =&gt; 10: Espia dentro t</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note que não é realmente necessário definir um método de <code>Object.bindings</code> deste tipo para observar nas variáveis de instância de um objeto. Vários
outros métodos descritos logo oferecem maneiras mais fáceis de consulta (e de conjunto) do valor das variáveis de instância de um objeto.</p>

<p>Os objetos <code>Proc</code> definem um método público de ligação que retorna uma Associação de objeto que representa a variável ligação em vigor para o corpo
do <code>Proc</code>. Além disso, o método <code>eval</code> permite que você passe um objeto <code>Proc</code> em vez de um objeto de associação como o segundo argumento.</p>

<p>Ruby 1.9 define um método <code>eval</code> em objetos de associação, de modo em vez de passar uma associação como o segundo argumento para o <code>eval</code> global,
você pode, em vez de invocar o método <code>eval</code> em uma ligação. Qual você escolhe é puramente uma questão de estética, as duas técnicas são equivalentes.</p>

<h3>instance_eval e class_eval</h3>


<p>A classe <code>Object</code> define um método chamado <code>instance_eval</code>, e a classe <code>Module</code> define um método chamado <code>class_eval</code>. <code>module_eval</code> é um sinônimo
para <code>class_eval</code>. Ambos os métodos avaliam código Ruby, como o <code>eval</code> faz, mas existem duas diferenças importantes. A primeira diferença é a que eles
avaliam o código no contexto do objecto específico ou no contexto especificado de cada módulo do objecto ou é o valor enquanto o código está sendo
avaliado. Aqui estão alguns exemplos:</p>

<figure class='code'><figcaption><span>instance_eval e class_eval</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">instance_eval</span><span class="p">(</span><span class="s2">&quot;@x&quot;</span><span class="p">)</span>  <span class="c1"># Retorna o valor da variável de instância o @x</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Define um len método de instância de String para retornar comprimento da String</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span><span class="p">(</span><span class="s2">&quot;def len; size; end&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Aqui está outra maneira de fazer isso</span>
</span><span class='line'><span class="c1"># O código citado se comporta como se fosse dentro da &quot;class String&quot; e &quot;end&quot;</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span><span class="p">(</span><span class="s2">&quot;alias len size&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Use instance_eval para definir método de classe String.Empty</span>
</span><span class='line'><span class="c1"># Note que as aspas dentro da aspas fica um pouco complicado ...</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">(</span><span class="s2">&quot;def vazio;&#39;&#39;; fim&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Observe a diferença sutil, mas crucial entre <code>instance_eval</code> e <code>class_eval</code> quando o código que está sendo avaliado contém uma definição de método.
<code>instance_eval</code> define métodos únicos do objeto (e isso resulta em métodos de classe quando for chamado em uma classe de objeto). <code>class_eval</code> define métodos de instância regulare.</p>

<p>A segunda diferença importante entre estes dois métodos e o eval global é que <code>instance_eval</code> e <code>class_eval</code> pode aceitar um bloco de código para
avaliar. Quando passa um bloco em vez de uma <code>String</code>, o código do bloco é executado no contexto apropriado. Aqui, por conseguinte, são alternativas
para as invocações anteriorment mostrada:</p>

<figure class='code'><figcaption><span>instance_eval e class_eval</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="vi">@x</span> <span class="p">}</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">len</span>
</span><span class='line'>    <span class="n">size</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="k">alias</span> <span class="n">len</span> <span class="n">size</span> <span class="p">}</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="k">def</span> <span class="nf">empty</span><span class="p">;</span> <span class="s2">&quot;&quot;</span><span class="p">;</span> <span class="k">end</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<h3>instance_exec e class_exec</h3>


<p>Ruby 1.9 define dois métodos de avaliação a mais: <code>instance_exec</code> e <code>class_exec</code> (e seu alias, <code>module_exec</code>). Estes métodos de avaliação de um bloco
(Mas não uma cadeia) de código, no contexto do objeto receptor, como fazem <code>instance_eval</code> e <code>class_eval</code>. A diferença é que o métodos <code>exec</code> aceita
argumentos e passá para o bloco. Assim, o bloco do código é avaliado no contexto de um objeto determinado, com parâmetros cujos valores vêm a partir
do exterior do objecto.</p>

<p>Até o proximo post amigos! :P</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reflexão e Metaprogramação #Ruby 1.9 - Part I]]></title>
    <link href="http://rrmartins.github.com/blog/2012/08/26/reflexao-e-metaprogramacao-number-ruby-1-dot-9/"/>
    <updated>2012-08-26T19:01:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/08/26/reflexao-e-metaprogramacao-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de <b>Reflexão e Metaprogramação</b>&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Reflexão e Metaprogramação</h1>


<!-- more -->


<p>Vimos que Ruby é uma linguagem muito dinâmica, você pode inserir novos métodos em classes em tempo de execução, criar apelidos
para métodos existentes, e até mesmo definir métodos em objetos individuais. Além disso, ele tem uma rica API para a reflexão.
Reflexão, também chamado de introspecção, significa simplesmente que um programa pode examinar seu estado e sua estrutura. Um
programa Ruby pode, por exemplo, obter a lista de métodos definidos pela classe <code>Hash</code>, consultar o valor de uma variável de
instância nomeada dentro de um objeto especificado, ou percorrer todos os objetos <code>Regexp</code> atualmente definidos pelo intérprete.
A API de reflexão, na verdade, vai além e permite que um programa para alterar o seu estado e estrutura. Um programa Ruby pode
definir dinamicamente variáveis chamadas, invocar métodos nomeados, e até mesmo definir novas classes e novos métodos.</p>

<p>API Reflexão Ruby, juntamente com a sua natureza geral, dinâmica, seu controle de estrutura de blocos iteradores, e a sintaxe
dos seus parênteses opcionais sintaxe torna uma linguagem ideal para metaprogramação. Vagamente definida, metaprogramação está
escrevendo programas (ou frameworks) que ajudam a escrever programas. Para colocar de outra forma, a metaprogramação é um
conjunto de técnicas para estender a sintaxe de Ruby de uma forma que facilita a programação. Metaprogramação está intimamente
ligada à idéia de escrever linguagens específicas de domínio, ou <code>DSL's</code>. <code>DSL's</code> em Ruby normalmente usam invocações de métodos e
blocos, como se fossem palavras-chave em uma extensão de tarefas específicas para a linguagem.</p>

<p>Neste post começo com várias seções que introduzem a API de reflexão do Ruby. Esta API é surpreendentemente rica e consiste de
poucos métodos. Estes métodos são definidos, para a maior parte, pelo <code>Kernel</code>, <code>Module</code> e <code>Object</code>.</p>

<p>Enquanto você lê estas seções introdutórias, tenha em mente que reflexão não é, por si só, a metaprogramação. Metaprogramação
tipicamente estende a sintaxe ou o comportamento de Ruby, de alguma forma, e com frequência envolve mais do que um tipo de
reflexão. Depois de introduzir a reflexão o núcleo da API de Ruby, neste post demonstrarei, por exemplo, técnicas comuns de
metaprogramação que usam essa API.</p>

<p>Note-se que este post aborda tópicos avançados. Você pode ser um programador Ruby produtivo sem nunca ler este post. Você pode
encontrar que é útil para ler os próximos post&#8217;s deste primeiro livro, e depois retornar a este capítulo. Considere este
post uma espécie de exame final: se você entender os exemplos (especialmente os mais queridos no final), então você domina Ruby!</p>

<!--more-->


<h3>Tipos, classes e módulos</h3>


<p>Os métodos mais utilizados são aqueles mais reflexivos para determinar o tipo de um objeto que classe é uma instância e quais
métodos ele responde. Para rever:</p>

<figure class='code'><figcaption><span>Metaprogramming</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">class</span>
</span><span class='line'><span class="c1"># Retorna a classe de do objeto &#39;o&#39;.</span>
</span><span class='line'>
</span><span class='line'><span class="n">c</span><span class="o">.</span><span class="n">superclass</span>
</span><span class='line'><span class="c1"># Retorna a superclasse de uma classe &#39;c&#39;.</span>
</span><span class='line'>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">instance_of?</span> <span class="n">c</span>
</span><span class='line'><span class="c1"># Determina se o objeto &#39;o.class == c&#39;.</span>
</span><span class='line'>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">is_a?</span> <span class="n">c</span>
</span><span class='line'><span class="c1"># Determina se &#39;o&#39; é um exemplo de &#39;c&#39;, ou de qualquer das suas subclasses. Se &#39;c&#39; for um módulo, este método testa se &#39;o.class&#39; (ou qualquer um de seus ancestrais) inclui o módulo.</span>
</span><span class='line'>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">kind_of?</span> <span class="n">c</span>
</span><span class='line'><span class="c1"># kind_of? é um sinônimo para is_a?.</span>
</span><span class='line'>
</span><span class='line'><span class="n">c</span> <span class="o">===</span> <span class="n">o</span>
</span><span class='line'><span class="c1"># Para qualquer classe &#39;c&#39; ou módulo, determina se &#39;o.is_a? (c)&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">respond_to?</span> <span class="n">nome</span>
</span><span class='line'><span class="c1"># Determina se o objeto &#39;o&#39; tem um método público ou protegido com o nome especificado. Passar true como o segundo argumento para verificar métodos privados, também.</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Ancestralidade e Módulos</h3>


<p>Além desses métodos que você já viu, há mais alguns métodos relacionados reflexivos para determinar os ancestrais de uma
classe ou módulo e para determinar quais os módulos que são incluídos por uma classe ou módulo. Esses métodos são fáceis de
entender quando demonstrado:</p>

<figure class='code'><figcaption><span>Alguns demonstrações</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">A</span><span class="p">;</span> <span class="k">end</span>                <span class="c1"># Modulo vazio</span>
</span><span class='line'><span class="k">module</span> <span class="nn">B</span><span class="p">;</span> <span class="kp">include</span> <span class="n">A</span><span class="p">;</span> <span class="k">end</span><span class="p">;</span>    <span class="c1"># Módulo B inclui A</span>
</span><span class='line'><span class="k">class</span> <span class="nc">C</span><span class="p">;</span> <span class="kp">include</span> <span class="n">B</span><span class="p">;</span> <span class="k">end</span><span class="p">;</span>     <span class="c1"># Classe C inclui o módulo B</span>
</span><span class='line'>
</span><span class='line'><span class="n">C</span> <span class="o">&lt;</span> <span class="n">B</span>                <span class="c1"># =&gt; true: C inclui B</span>
</span><span class='line'><span class="n">B</span> <span class="o">&lt;</span> <span class="n">A</span>                <span class="c1"># =&gt; true: B inclui A</span>
</span><span class='line'><span class="n">C</span> <span class="o">&lt;</span> <span class="n">A</span>                <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="no">Fixnum</span> <span class="o">&lt;</span> <span class="nb">Integer</span>     <span class="c1"># =&gt; true: todos os fixnums são inteiros</span>
</span><span class='line'><span class="nb">Integer</span> <span class="o">&lt;</span> <span class="no">Comparable</span> <span class="c1"># =&gt; true: inteiros são comparáveis</span>
</span><span class='line'><span class="nb">Integer</span> <span class="o">&lt;</span> <span class="no">Fixnum</span>     <span class="c1"># =&gt; false: nem todos os números inteiros são fixnums</span>
</span><span class='line'><span class="nb">String</span> <span class="o">&lt;</span> <span class="no">Numeric</span>     <span class="c1"># =&gt; nil: cordas não são números</span>
</span><span class='line'>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">ancestors</span>          <span class="c1"># =&gt; [A]</span>
</span><span class='line'><span class="n">B</span><span class="o">.</span><span class="n">ancestors</span>          <span class="c1"># =&gt; [B, A]</span>
</span><span class='line'><span class="n">C</span><span class="o">.</span><span class="n">ancestors</span>          <span class="c1"># =&gt; [C, B, A, Object, Kernel]</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">ancestors</span>     <span class="c1"># =&gt; [String, Enumerable, Comparable, Object, Kernel]</span>
</span><span class='line'><span class="err">                     </span><span class="c1"># Nota: em Ruby 1.9, String não é mais Enumerable</span>
</span><span class='line'>
</span><span class='line'><span class="n">C</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="n">C</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="n">B</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># =&gt; false</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># =&gt; false</span>
</span><span class='line'>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">included_modules</span> <span class="c1"># =&gt; []</span>
</span><span class='line'><span class="n">B</span><span class="o">.</span><span class="n">included_modules</span> <span class="c1"># =&gt; [A]</span>
</span><span class='line'><span class="n">C</span><span class="o">.</span><span class="n">included_modules</span> <span class="c1"># =&gt; [B, A, Kernel]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este código demonstra <code>include?</code>, que é um método público de instância definido pela classe <code>Module</code>. Mas ele também possui duas
invocações do método <code>include</code> (Sem o sinal de interrogação), que é um método de instância particular de <code>Module</code>. Como um
método particular, pode apenas ser chamado implicitamente em si, o que limita a sua utilização para o corpo de uma definição de
<code>class</code> ou <code>module</code>. Este uso do método <code>include</code>, como se tratasse de uma palavra-chave, é um exemplo de metaprogramação no
núcleo da sintaxe de Ruby.</p>

<p>Um método relacionado com o método <code>include</code>, particular é o público <code>Object.extend</code>. Este método estende um objeto por tornar
os métodos de instância de cada um dos módulos específicos em métodos <code>singleton</code> do objeto:</p>

<figure class='code'><figcaption><span>Singleton</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Greeter</span><span class="p">;</span> <span class="k">def</span> <span class="nf">hi</span><span class="p">;</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span> <span class="k">end</span><span class="p">;</span> <span class="k">end</span> <span class="c1"># módulo Greeter</span>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;objeto de string&quot;</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="no">Greeter</span><span class="p">)</span>       <span class="c1"># Adicione &quot;hello&quot; como um método singleton para s</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">hi</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="no">Greeter</span><span class="p">)</span>  <span class="c1"># Adicione &quot;hello&quot; como método de classe de String</span>
</span><span class='line'><span class="nb">String</span><span class="o">.</span><span class="n">hi</span>               <span class="c1"># =&gt; &quot;hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>O método <code>Module.nesting</code> de classe não está relacionado com a inclusão do módulo ou ascendência, em vez disso, ele retorna um
<code>array</code> que especifica o assentamento de módulos da localização atual. <code>Module.nesting[0]</code> é a classe atual ou módulo, <code>Module.nesting[1]</code> é o quem contém a <code>class</code> ou <code>module</code> e assim por diante:</p>

<figure class='code'><figcaption><span>Module e Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">M</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">C</span>
</span><span class='line'>    <span class="no">Module</span><span class="o">.</span><span class="n">nesting</span>   <span class="c1"># =&gt; [M::C, M]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Definindo Classes e Módulos</h3>


<p>Classes e módulos são instâncias das classes de <code>Class</code> e <code>Module</code>. Como tal, você pode criá-los dinamicamente:</p>

<figure class='code'><figcaption><span>Class e Module dinamicamente</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">M</span> <span class="o">=</span> <span class="no">Module</span><span class="o">.</span><span class="n">new</span>      <span class="c1"># Define um novo módulo M</span>
</span><span class='line'><span class="n">C</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span>       <span class="c1"># Define uma nova classe C</span>
</span><span class='line'><span class="n">D</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="p">{</span>  <span class="c1"># Definir uma subclasse de C</span>
</span><span class='line'><span class="err">  </span><span class="kp">include</span> <span class="n">M</span>         <span class="c1"># inclui o módulo M</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">D</span><span class="o">.</span><span class="n">to_s</span>               <span class="c1"># =&gt; &quot;D&quot;: classe recebe o nome da constante por magia</span>
</span></code></pre></td></tr></table></div></figure>


<p>Um recurso interessante do Ruby é que, quando um criado dinamicamente um módulo anónimo ou classe é atribuído a uma constante,
o nome dessa constante é usado como o nome do módulo ou classe (e é retornado pelo seu nome e método to_s).</p>

<p>É isso ai amigos&#8230;
Hora de dar um <code>break</code>&#8230; :)</p>

<p>Até o proximo!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Blocos em #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/08/19/blocos-em-number-ruby-1-dot-9/"/>
    <updated>2012-08-19T14:02:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/08/19/blocos-em-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `Blocks`&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Blocos em #Ruby 1.9</h1>


<p>O uso de blocos é fundamental para o uso de iteradores. As subseções a seguir explicam:</p>

<ul>
<li>A sintaxe para associar um bloco com uma invocação de método</li>
<li>O &#8220;valor de retorno&#8221; de um bloco</li>
<li>O escopo de variáveis ​​em blocos</li>
<li>A diferença entre os parâmetros dos blocos e parâmetros de método</li>
</ul>


<!--more-->




<h3>Sintaxe bloco</h3>


<p>Os <code>Blocos</code> não podem ser autônomo, pois eles são apenas legal após uma chamada de método. Você pode, no entanto, colocar um
bloco depois de qualquer invocação método, se o método não é um iterador e nunca invoca o bloco com a produção, o bloco será
ignorado. Blocos são delimitados por chaves ou com palavras-chave <code>do/end</code>. A abertura de chave ou a palavra-chave deve ser na
mesma linha com a invocação de método, ou então Ruby interpreta a linha como um terminador de instrução e invoca o método sem
o bloco:</p>

<figure class='code'><figcaption><span>Blocos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Imprima os números 1 a 10</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span> <span class="p">}</span> <span class="c1"># Invocação e bloco em uma linha com aparelho</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>        <span class="c1"># Delimitado bloco com do/end</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">x</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>                 <span class="c1"># Bloco não especificado</span>
</span><span class='line'><span class="err"> </span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span> <span class="p">}</span>        <span class="c1"># Erro na Sintaxe: bloco é permitido não depois de uma invocação</span>
</span></code></pre></td></tr></table></div></figure>


<p>Uma convenção comum é a utilização de chaves quando um bloco se encaixa em uma única linha, e para usar <code>do/end</code> quando o bloco
se estende sobre linhas.  Isso não é totalmente uma questão de convenção, no entanto, o analisador de Ruby liga firmemente
para o símbolo que precede. Se você omitir os parênteses em torno de argumentos de método e usar delimitadores de chaves para
um bloco, em seguida, o bloco vai ser associado com o último argumento do método em vez do método em si, o que não é,
provavelmente, o que deseja. Para evitar neste caso, coloque entre parênteses os argumentos ou delimite o bloco com <code>do</code> e
<code>end</code>:</p>

<figure class='code'><figcaption><span>Blocks</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span><span class="p">}</span> <span class="c1"># Parens e encaracolado chaves trabalhar</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span> <span class="mi">3</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span> <span class="k">end</span>    
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span> <span class="mi">3</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span><span class="p">}</span> <span class="c1"># erro de sintaxe: tentando passar um bloco para 3!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Os blocos podem ser parametrizados, assim como métodos podem. Os parâmetros dos blocos são separados por vírgulas e delimitados
com um par de barra vertical (<code>|</code>), mas eles são de outra maneira muito parecida com os parâmetros do método:</p>

<figure class='code'><figcaption><span>Blocks</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># O iterador Hash.each passa dois argumentos para seu bloco</span>
</span><span class='line'><span class="nb">hash</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">chave</span><span class="p">,</span> <span class="n">valor</span><span class="o">|</span> <span class="c1"># Para cada par (chave, valor) no hash</span>
</span><span class='line'><span class="err">  </span><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">chave</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">valor</span><span class="si">}</span><span class="s2">&quot;</span> <span class="c1"># Imprimir a chave eo valor</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># Fim do bloco</span>
</span></code></pre></td></tr></table></div></figure>


<p>É uma convenção comum para escrever os parâmetros do bloco, na mesma linha, como a invocação do método e da chave de abertura
ou fazer palavra-chave, mas isto não é requerido pela sintaxe.</p>

<h3>O Valor de um Bloco</h3>


<p>Considerando o método <code>Array.sort</code>. Se você associar um bloco com uma invocação deste método, ele irá produzir pares de
elementos para o bloco, e é o trabalho do bloco para classificá-los.</p>

<p>O valor do bloco de retorno <code>(-1, 0 ou 1)</code> indica a ordem dos dois argumentos. O &#8220;valor de retorno&#8221; do bloco está disponível
com o método <code>iterator</code> como o valor da declaração <code>yield</code>.</p>

<p>O &#8220;valor de retorno&#8221; de um bloco é simplesmente o valor da última expressão avaliada no bloco. Assim, para classificar um <code>array</code> de palavras maior de a menor, poderíamos escrever:</p>

<figure class='code'><figcaption><span>Metodo sort</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># O bloco tem duas palavras e &quot;retorna&quot; a sua ordem relativa</span>
</span><span class='line'><span class="n">words</span><span class="o">.</span><span class="n">sort!</span> <span class="p">{</span><span class="o">|</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">|</span> <span class="n">y</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">length</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Nós estamos colocando a expressão &#8220;valor de retorno&#8221; entre aspas por uma razão muito importante: você não deve usar normalmente
a palavra-chave <code>return</code> para retornar um bloco. Um <code>return</code> dentro de um bloco faz com que o método que o contém (não o método
iterador que pertence ao bloco, mas o método que o bloco faz parte) o retorno naquela linha, o Ruby retorna a ultima linha do
bloco. Há, é claro, tem momentos em que isso é exatamente o que você quer fazer. Mas não use o <code>return</code> se você quer apenas
voltar de um bloco para o método que chamou <code>yield</code>. Se você precisar forçar um bloco para voltar ao método invocando antes que
ele atinja a última expressão, ou se você deseja retornar mais de um valor, você pode usar <code>next</code> em vez de retorno. Aqui é um
exemplo que usa <code>next</code> para voltar a partir do bloco:</p>

<figure class='code'><figcaption><span>Usando next</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">array</span><span class="o">.</span><span class="n">collect</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
</span><span class='line'>  <span class="k">next</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="kp">nil</span>  <span class="c1"># Retorna se x é nulo</span>
</span><span class='line'>  <span class="k">next</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>         <span class="c1"># Retorna dois valores</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que não é particularmente comum usar <code>next</code> desta maneira, e o código acima é facilmente reescrito assim:</p>

<figure class='code'><figcaption><span>Reescrevendo bloco</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">array</span><span class="o">.</span><span class="n">collect</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="kp">nil</span>
</span><span class='line'>    <span class="mi">0</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="o">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Blocos e escopo de variáveis</h3>


<p>Blocos que definem um novo escopo de variáveis: variáveis ​​criadas dentro de um bloco só existem dentro desse bloco e estão são
indefinidas fora do bloco. Seja cauteloso, no entanto, as variáveis ​​locais em um método estão disponíveis para todos os blocos
dentro desse método. Então, se um bloco atribui um valor a uma variável que já está definida fora do bloco, este não cria uma
variável local nova, mas em vez disso, atribui um novo valor para a variável já existente. Às vezes, isso é exatamente o
comportamento que queremos:</p>

<figure class='code'><figcaption><span>Escopos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">data</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">x</span> <span class="p">}</span>  <span class="c1"># Some os elementos da matriz de dados</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">total</span>                   <span class="c1"># Impressão do total da soma</span>
</span></code></pre></td></tr></table></div></figure>


<p>Às vezes, no entanto, nós não queremos alterar as variáveis ​​no escopo delimitador, mas fazemos acidentalmente. Este problema é
uma preocupação particular para os parâmetros dos blocos em Ruby 1.8. No Ruby 1.8, se um parâmetro do bloco compartilha o nome
de uma variável existente, então invocações do bloco simplesmente atribuir um valor a essa variável já existente em vez de
criar uma variável de bloco local novo. O seguinte código, por exemplo, é problemático porque utiliza o mesmo identificador <code>i</code>
como o parâmetro para dois blocos nested blocos:</p>

<figure class='code'><figcaption><span>Usando mesma variavel, Ruby 1.8</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>         <span class="c1"># 10 linhas</span>
</span><span class='line'>  <span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>       <span class="c1"># Cada um tem 10 colunas</span>
</span><span class='line'>    <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>         <span class="c1"># Imprimi o número de colunas</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="nb">print</span> <span class="s2">&quot; ==&gt; Row </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="c1"># Número de linhas</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ruby 1.9 é diferente: os parâmetros dos blocos são sempre locais para o seu bloco, e invocações do bloco nunca atribuem valores
a variáveis ​​existentes. Se o Ruby 1.9 é invocado com o flag -w, ele irá avisá-lo se um parâmetro do bloco tem o mesmo nome de
uma variável existente. Isso ajuda a evitar escrever código que funciona de forma diferente em 1.8 e 1.9.</p>

<p>Ruby 1.9 é diferente de outra maneira importante, também. Sintaxe do bloco foi estendida para permitir que você declare
variáveis de blocos locais ​​que são garantidas para ser local, mesmo se uma variável com o mesmo nome já existe no escopo
delimitador. Para fazer, siga a lista de parâmetros do bloco com um ponto e vírgula e uma lista separada por vírgulas de
variáveis ​​do bloco local. Aqui está um exemplo:</p>

<figure class='code'><figcaption><span>Variaveis</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c1"># variáveis ​​locais</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="p">;</span><span class="n">y</span><span class="o">|</span>   <span class="c1"># x e y são locais para bloquear</span>
</span><span class='line'>                     <span class="c1"># x e y são &quot;sombra&quot; das variáveis ​​externas</span>
</span><span class='line'>  <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c1"># Usa y como uma variável que vai receber valores</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span>           <span class="c1"># imprime 4, 9, 16, 25</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="o">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">]</span>                <span class="c1"># =&gt; [0,0]: o bloco não altera essas variaveis.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Neste código, x é um parâmetro de bloco: ele recebe um valor quando o bloco é invocado com a produtividade. y é uma variável de
bloco-local. Ele não receber qualquer valor a partir de uma chamada <code>yield</code>, mas tem o valor nil até que o bloco de fato
atribui outro valor a ele. O ponto de declarar essas variáveis locais no ​​bloco é garantir que você não vai acidentalmente
sub-escrever o valor de alguma variável existente. Se você chamar Ruby 1.9 com o flag -w, ele irá avisá-lo se um bloco de
variável local de uma variável existente.</p>

<p>Os blocos podem ter mais do que um parâmetro e mais de uma variável local, é claro. Aqui é um bloco com dois parâmetros e
três variáveis ​​locais:</p>

<figure class='code'><figcaption><span>Variavel Local</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">;</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">|</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Passando argumentos para um bloco</h3>


<p>Nós dissemos anteriormente que os parâmetros para um bloco são muito parecidos com os parâmetros de um método. Eles não são
rigorosamente iguais, no entanto. Os valores de argumento que seguem a palavra-chave <code>yield</code> são designados para bloquear
parâmetros seguindo as regras que estão mais próximos as regras para a atribuição de variável do que as regras para a invocação
de método. Assim, quando um iterador executa <code>yield k,v</code>, para invocar um bloco declarado com parâmetros <code>|key, value|</code>, é
equivalente a esta instrução de atribuição:</p>

<figure class='code'><figcaption><span>Atribuição de parametros</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span>
</span></code></pre></td></tr></table></div></figure>


<p>O iterador <code>Hash.each_pair</code> produz um par <code>key/value</code> como este:</p>

<figure class='code'><figcaption><span>Hash.each_pair</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span><span class="ss">:one</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">}</span><span class="o">.</span><span class="n">each_pair</span> <span class="p">{</span><span class="o">|</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="o">|</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span> <span class="c1"># key=:one, value=1</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.8, é ainda mais claro que a invocação do bloco usa atribuição de variável. Lembre-se que no Ruby 1.8, os parâmetros
são apenas locais para o bloco se não estiverem já em uso, como variáveis ​​locais do método que a contém. Se eles já são
variáveis locais, em seguida, eles são simplesmente atribuídos. Na verdade, Ruby 1.8 permite que qualquer tipo de variável seja
utilizada como um parâmetro de bloco, incluindo variáveis ​​globais e variáveis ​​de instância:</p>

<figure class='code'><figcaption><span>Variaveis Locais e de Instância</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span><span class="ss">:one</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">}</span><span class="o">.</span><span class="n">each_pair</span> <span class="p">{</span><span class="o">|</span><span class="vg">$key</span><span class="p">,</span> <span class="vi">@value</span><span class="o">|</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span> <span class="c1"># Não funciona mais no Ruby 1.9</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este iterator define a variável global <code>$key</code> para <code>:one</code> e define a variável de instância <code>@value</code> para <code>1</code>. Como já
mencionado, o Ruby 1.9 faz os parâmetros dos blocos locais para o bloco. Isto também significa que os parâmetros dos blocos não
podem mais ser variáveis ​​globais ou de instância.</p>

<p>Os iteradores <code>Hash.each</code> segue um pares de <code>key/value</code> como dois elementos de uma única matriz. É muito comum, no entanto,
para ver o código como esta:</p>

<figure class='code'><figcaption><span>Hash.each</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="o">|</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>  <span class="c1"># Chave e valor atribuído a params k e v</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isso também funciona por atribuição paralela. O valor cedido, um conjunto de dois elementos, é atribuído às variáveis ​​k e v:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="o">[</span><span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Pelas regras de atribuição paralela (ver <a href="http://rrmartins.github.com/blog/2012/06/11/atribuicao-paralela-number-ruby/">Atribuição Paralela</a>), uma única matriz da direita é expandida e seus elementos atribuídos às variáveis ​​múltiplas do lado esquerdo.</p>

<p>Bloco de invocação não funciona exatamente como atribuição paralela. Imagine um iterador que passa dois valores ao seu bloco.
Por as regras de atribuição paralela, podemos esperar para ser capaz de declarar um bloco com um único parâmetro e ter os dois
valores automaticamente preenchido em uma matriz para nós. Mas não é assim que funciona:</p>

<figure class='code'><figcaption><span>Parametros</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">two</span><span class="p">;</span> <span class="k">yield</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">;</span> <span class="k">end</span> <span class="c1"># Um iterador que produz dois valores</span>
</span><span class='line'><span class="n">two</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">p</span> <span class="n">x</span> <span class="p">}</span>          <span class="c1"># Ruby 1.8: avisa e impressões [1,2],</span>
</span><span class='line'><span class="n">two</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">p</span> <span class="n">x</span> <span class="p">}</span>           <span class="c1"># Ruby 1.9: imprime 1, nenhum aviso</span>
</span><span class='line'><span class="n">two</span> <span class="p">{</span><span class="o">|*</span><span class="n">x</span><span class="o">|</span> <span class="nb">p</span> <span class="n">x</span> <span class="p">}</span>          <span class="c1"># versão Ou: impressões [1,2]; nenhum aviso</span>
</span><span class='line'><span class="n">two</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="o">|</span> <span class="nb">p</span> <span class="n">x</span> <span class="p">}</span>           <span class="c1"># versão Ou: impressões 1; nenhum aviso</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.8, vários argumentos são embalados em uma matriz, quando existe um parâmetro único no bloco, mas isso é obsoleto e
gera uma mensagem de aviso. No Ruby 1.9, o primeiro valor é atribuído ao parâmetro do bloco e o segundo valor é descartado. Se
queremos que vários valores podem a ser embalado em uma matriz e atribuído a um único parâmetro do bloco, nós devemos indicar
explicitamente que estamos prefixando o parâmetro com um <code>*</code>, exatamente como faríamos em uma declaração de método. Observe
também que podemos descartar explicitamente o segundo valor ao declarar uma lista de parâmetros de bloco, que termina com uma
vírgula, como se dissesse:</p>

<pre><code>"Há um outro parâmetro, mas não é usado e eu não posso ser incomodado para escolher um nome para ele."
</code></pre>

<p>Embora invocação de bloco não se comporta como a atribuição paralela, neste caso, não se comportam como uma chamada de método,
também. Se declarar um método com um argumento e depois passar dois argumentos para ele, o Ruby não vai apenas imprimir um
aviso, vai também gerar um erro.</p>

<p>A declaração do <code>yield</code> permite que <code>hashes</code> &#8220;nus&#8221; como o valor do último argumento, assim como invocações de métodos. Isto é,
se o último argumento para produzir é um literal de <code>hash</code>, você pode omitir as chaves. Porque não é comum para iteradores para
produzir <code>hashes</code>, temos que maquinar um exemplo para demonstrar isto:</p>

<figure class='code'><figcaption><span>Hashes sem chaves</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">hashiter</span><span class="p">;</span> <span class="k">yield</span> <span class="ss">:a</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">;</span> <span class="k">end</span>  <span class="c1"># Nota final sem chaves</span>
</span><span class='line'><span class="n">hashiter</span> <span class="p">{</span><span class="o">|</span><span class="nb">hash</span><span class="o">|</span> <span class="nb">puts</span> <span class="nb">hash</span><span class="o">[</span><span class="ss">:a</span><span class="o">]</span> <span class="p">}</span>       <span class="c1"># Imprime 1</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Bloquear Parâmetros no Ruby 1.9</h3>


<p>No Ruby 1.8, apenas o último parâmetro do bloco pode ter um prefixo <code>*</code>. Ruby 1.9 levanta essa restrição e permite qualquer
parâmetro do bloco, independentemente da sua posição na lista, para ter um prefixo <code>*</code>:</p>

<figure class='code'><figcaption><span>Prefixo *</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">five</span><span class="p">;</span> <span class="k">yield</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">;</span> <span class="k">end</span>     <span class="c1"># Seguindo os 5 valores</span>
</span><span class='line'><span class="n">five</span> <span class="k">do</span> <span class="o">|</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span> <span class="n">tail</span><span class="o">|</span>        <span class="c1"># Valores extras entrar em matriz corpo</span>
</span><span class='line'>  <span class="nb">print</span> <span class="n">head</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">tail</span>           <span class="c1"># Mostra &quot;1 [2,3,4] 5&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.9 parâmetros do bloco podem ter valores padrões, apenas como parâmetros de método pode. Suponha, por exemplo, que
você deseja iterar os valores de um objeto, mas o que você não sabe se o obejeto é um <code>array</code> ou um <code>hash</code>. Você pode usar um
bloco como este:</p>

<figure class='code'><figcaption><span>Variavel com um valor pré determinado</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">key</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span><span class="n">value</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">value</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se cada iterador produz um único valor, é atribuído ao segundo parâmetro do bloco. Se cada um produz um par de valores,
são atribuídos a ambos os parâmetros.</p>

<p>No Ruby 1.9, o parâmetro do bloco final pode ser prefixado com e para indicar que vai receber qualquer bloco associado com a
invocação do bloco. Lembre, no entanto, que a invocação <code>yield</code> pode não ter um bloco associado.</p>

<p>Até o proximo assunto amigos.. :P</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Filosofia do #Ruby <3]]></title>
    <link href="http://rrmartins.github.com/blog/2012/08/08/a-filosofia-do-number-ruby-3/"/>
    <updated>2012-08-08T22:59:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/08/08/a-filosofia-do-number-ruby-3</id>
    <content type="html"><![CDATA[<p>Nessa noite, eu estava assistindo um jogo na tv, e navegando na internet achei um link muito bom(<a href="http://www.artima.com/intv/ruby.html">http://www.artima.com/intv/ruby.html</a>), que já consegui a 
autorização para colocar aqui para vocês&#8230;</p>


<!-- more -->


<p>Então, abaixo uma entrevista do criador da linguagem de programação <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, o <a href="https://twitter.com/yukihiro_matz">Yukihiro Matsumoto &#8216;Matz&#8217;</a>.</p>




<h2>A Filosofia do #<a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a></h2>




<h6>Resumo</h6>




<p><a href="https://twitter.com/yukihiro_matz">Yukihiro Matsumoto &#8216;Matz&#8217;</a>, como é conhecido online, é o criador da linguagem de programação <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>. <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> é uma linguagem orientada a objeto adequada para escrever scripts do dia-a-dia, assim como em grande escala de aplicações. Matz começou a trabalhar no <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> em 1993, porque ele queria uma linguagem que o fizesse produtivo enquanto fosse divertido de usar. Inicialmente popular no Japão, <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> tem encontrado seu caminho para os corações de programadores em todo o mundo.</p>




<p>Nesta entrevista, Yukihiro Matsumoto discute a filosofia do design do <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, as características da linguagem <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, e se tornar um programador melhor. Neste capítulo inicial, Matz faz filosofias sobre a imperfeição de design, o perigo de <a href="http://pt.wikipedia.org/wiki/Ortogonalidade">ortogonalidade</a>, a concessão de liberdade com a orientação, o princípio da menor surpresa e a importância do ser humano em empreendimentos de computador.</p>


<!--more-->




<h6>Nenhuma Línguagem Perfeita</h6>




<p><b>Bill Venners</b>: Dave Thomas, co-autor de Programming <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>: Um Guia do Programador Pragmático, disse que você não acha que um projeto de linguagem deve ser perfeito. Por que não?</p>




<p><b>Yukihiro Matsumoto</b>: designers de Linguagens querem projetar a linguagem perfeita. Eles querem ser capazes de dizer: &#8220;A minha linguagem é perfeita. Ela pode fazer tudo.&#8221; Mas é simplesmente impossível projetar uma linguagem perfeita, porque existem duas maneiras de olhar para uma mesma linguagem. Uma maneira é olhar para o que pode ser feito com essa linguagem. A outra é olhar para o que sentimos usando essa linguagem, como nos sentimos durante a programação.</p>




<p>Por causa da Teoria da <a href="http://ethosproject.blogspot.com.br/2012/06/preconceito-ignorancia-e-genialidade.html">Integridade de Turing</a>, tudo que uma linguagem pode fazer teoricamente pode ser feito por outra linguagem, mas a um custo diferente. Você pode fazer tudo em <a href="http://pt.wikipedia.org/wiki/Assembly">Assembler</a>, mas ninguém quer programar em assembler mais. Do ponto de vista que você pode fazer, portanto, as línguas diferem entre si, mas as diferenças são limitadas. Por exemplo, <a href="http://www.python.org/">Python</a> e <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> fornecem quase o mesmo poder para o programador.</p>




<p>Em vez de enfatizar o que eu quero enfatizar a parte como: Como nos sentimos durante a programação, essa é a diferença principal do <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> a partir de projetos em outras linguagens. Eu enfatizo a sensação, em particular, como eu me sinto usando <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>. Eu não trabalho duro para tornar <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> perfeito para todos, porque você se sente diferente de mim. Nenhuma linguagem pode ser perfeita para todos. Eu tentei fazer o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> perfeita para mim, mas talvez ela não é perfeito para você. A linguagem perfeita para Guido van Rossum provavelmente é <a href="http://www.python.org/">Python</a>.</p>




<h6><a href="http://www.dicio.com.br/ortogonal/">Ortogonais</a> em relação harmoniosa</h6>




<p><b>Bill Venners</b>: Dave Thomas também afirmou que, se eu pedir para você adicionar um recurso que é ortogonal, você não vai fazer. O que você quer é algo que seje harmonioso. O que significa isso?</p>




<p><b>Yukihiro Matsumoto</b>: Eu acredito que a consistência e ortogonalidade são ferramentas de design, não o objetivo principal no projeto.</p>




<p><b>Bill Venners</b>: O que significa ortogonalidade neste contexto?</p>




<p><b>Yukihiro Matsumoto</b>: Um exemplo de ortogonalidade é permitir qualquer combinação de características de pequeno porte ou de sintaxe. Por exemplo, <a href="http://pt.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)">C</a> suporta ambos os valores de parâmetro padrão para funções e sobrecarga de nomes de função com base em parâmetros. Ambos são boas características  para se ter em uma língua, mas porque elas são ortogonais, você pode aplicar ao mesmo tempo. O compilador sabe como aplicar ao mesmo tempo. Se é ambígua, o compilador irá sinalizar um erro. Mas se eu olhar para o código, eu preciso aplicar a regra com o meu cérebro também. Eu preciso adivinhar como o compilador funciona. Se eu estiver certo, e eu for inteligente o suficiente, não há problema. Mas se eu não sou inteligente o suficiente, e eu não sou realmente, causa confusão. O resultado será inesperado para uma pessoa comum. Este é um exemplo de como ortogonalidade é má.</p>




<p><b>Bill Venners</b>: Em outras palavras, as características ortogonais irá funcionar uma vez que o escritor do compilador entendê-las e recebe-las para trabalhar. Mas é difícil para os programadores entender quando olham para ele, porque é complicado, porque eu tenho que descobrir como essas duas coisas andam juntas.</p>




<p><b>Yukihiro Matsumoto</b>: As funcionalidades ortogonais, quando combinadas, podem explodir em complexidade.</p>




<p><b>Bill Venners</b>: Então, qual é a alternativa? O que seria mais harmonioso?</p>




<p><b>Yukihiro Matsumoto</b>: Basta pegar um dos dois para colocar na linguagem. Você não tem que fazer tudo o que você pode pensar. Você precisa escolher um deles, mesmo que ambos sejam bons.</p>




<h6>Liberdade e Conforto</h6>




<p><b>Bill Venners</b>: Uma das filosofias de design na comunidade <a href="http://www.python.org/">Python</a> está fornecendo uma e apenas uma maneira de fazer as coisas. Se você fornecer cinquenta maneiras diferentes de fazer a mesma coisa, então você forneceu comodidade para os escritores de código. As pessoas podem escrever coisas da sua melhor forma. A troca é para os leitores de código. Quando eu li o seu código, você poderia ter escrito de um jeito. Quando eu li o código de outras pessoas, elas podem ter escrito de outra forma. Então, como um leitor de eu acabar precisando estar familiarizado com todos os meios para realizar a tarefa, não apenas a minha maneira favorita de escrevê-la. Esse é o dilema do design. A comunidade <a href="http://www.python.org/">Python</a> parece preferir a uma e apenas uma maneira de abordagem, mas <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> parece fornecer várias maneiras de fazer a mesma coisa.</p>




<p><b>Yukihiro Matsumoto</b>: <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> herdou a filosofia <a href="http://www.perl.org.br/Main/WebHome">Perl</a> de ter mais de uma maneira de fazer a mesma coisa. Eu herdei essa filosofia de <a href="http://pt.wikipedia.org/wiki/Larry_Wall">Larry Wall</a>, que é o meu herói, na verdade. Eu quero fazer os usuários de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> livre. Eu quero dar-lhes a liberdade de escolher. As pessoas são diferentes. As pessoas escolhem diferentes critérios. Mas se há uma maneira melhor entre muitas alternativas, eu quero encorajar esse caminho, tornando-o confortável. Então é isso que eu tentei fazer. Talvez o código do <a href="http://www.python.org/">Python</a> é um pouco mais legível. Todo mundo pode escrever o mesmo estilo de código <a href="http://www.python.org/">Python</a>, por isso pode ser mais fácil de ler, talvez. Mas a diferença de uma pessoa para outra é tão grande, proporcionando apenas uma maneira de ajudar é pouco, mesmo se você estiver usando o <a href="http://www.python.org/">Python</a>, eu acho. Prefiro fornecer muitas maneiras se é possível, mas encorajar ou orientar os usuários a escolher um caminho melhor, se é possível.</p>




<h6>A alegria do <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a></h6>




<p><b>Bill Venners</b>: Em um artigo introdutório sobre <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, você escreveu: &#8220;Para mim, o propósito da vida é, em parte, para ter alegria de programadores, que muitas vezes se sentem alegres quando eles podem se concentrar no lado criativo da programação, o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, então, é projetado para fazer programadores felizes.. &#8221; Como pode o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> fazer programadores felizes?<p>

<p><b>Yukihiro Matsumoto</b>: Você quer curtir a vida, não é? Se você começa o seu trabalho feito rapidamente e seu trabalho é divertido, isso é bom não é? Esse é o propósito da vida, em parte. Sua vida é melhor.</p>

<p>Eu quero resolver os problemas que encontro no cotidiano usando computadores, então preciso escrever programas. Usando <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, quero me concentrar nas coisas que faço, e não as regras mágicas da linguagem, como começo com algum público vazio, tenho algo a dizer, &#8220;Olá, mundo de impressão.&#8221; Eu só quero dizer, &#8220;imprimir isto!&#8221; Eu não quero todas as palavras mágicas circundantes. Eu só quero concentrar-se na tarefa. Essa é a idéia básica. Então eu tentei fazer o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> conciso e com código suscinto.</p>

<p><b>Bill Venners</b>: permitir que os programadores escrevem códigos que é conciso e suscinto é uma maneira de fazê-los felizes.</p>

<p><b>Yukihiro Matsumoto</b>: Sim, para que eles possam se concentrar no problema em si. Às vezes as pessoas anotam pseudo-código no papel. Se esse pseudo-código é executado diretamente em seus computadores, é melhor, não é? <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> tenta ser assim, como o pseudo-código que é executado. As pessoas dizem que <a href="http://www.python.org/">Python</a> também.</p>

<p><b>Bill Venners</b>: Sim, as pessoas dizem que Pytho é pseudo-código executável. O que mais está em <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> para fazer programadores felizes?</p>

<p><b>Yukihiro Matsumoto</b>: Em nossas vidas diárias como programadores, processamos cadeias de texto muito grandes. Então, eu tentei trabalhar duro em processamento de texto, ou seja, a Classe <a href="http://ruby-doc.org/core-1.9.3/String.html">String</a> e <a href="http://www.ruby-doc.org/core-1.9.3/Regexp.html">Expressões Regulares</a>. As <a href="http://www.ruby-doc.org/core-1.9.3/Regexp.html">Expressões Regulares</a> são incorporadas na linguagem e são muito boas para uso. <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> pode chamar todas as chamadas de sistema em <a href="http://pt.wikipedia.org/wiki/Unix">Unix</a> e mais da API do Windows. Isto traz o poder e função do sistema operacional para o ambiente da linguagem interpretativa. Assim você pode fazer administração de sistemas e programação diária de processamento de texto. Esse é o maior domínio de, pelo menos, a minha vida, então eu trabalhei duro para fazer isso bom.</p>

<p><b>Bill Venners</b>: Então, basicamente, o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> me ajuda a gozar a minha vida, me ajudando a fazer meu trabalho mais rapidamente e com mais diversão?</p>

<p><b>Yukihiro Matsumoto</b>: Ele me ajuda a fazer isso. Eu não tenho certeza se <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> funciona para você, mas eu espero que sim.</p>

<h6>O Fator Humano</h6>

<p><b>Bill Venners</b>: Em uma entrevista, você disse, &#8221; Não subestime o fator humano, ainda penso que nós estamos na frente de computadores, eles são meios que estamos trabalhando para consumo humano, com humana.&#8221; O que você quer dizer com isso?</p>

<p><b>Yukihiro Matsumoto</b>: Imagine que você está escrevendo um e-mail. Está em frente do computador. Você está operando o computador, clica em um mouse e digita em um teclado, mas a mensagem será enviada a um ser humano através da internet. Então você está trabalhando antes do computador, mas com um ser humano por trás do computador. A maioria das tarefas que fazemos são para seres humanos. Por exemplo, um cálculo do imposto é contar números para que o governo possa tirar dinheiro da minha carteira, mas o governo é composto por seres humanos.</p>

<p>A maioria das nossas tarefas estão relacionadas com os seres humanos, afinal. Assim, na programação, ou pedimos ao computador para trabalhar para um ser humano, ou descrevemos nossos pensamentos para um computador de uma maneira muito clara de que até mesmo o computador possa executar. No primeiro caso, tornando o trabalho do computador para os seres humanos, o alvo é um ser humano através do computador. No segundo caso, a expressão dos nossos pensamentos claramente suficiente para ser entendido e executado por computadores, expressa a intenção de nossos cérebros humanos e, como resultado, é executada pelos computadores. Assim, em ambos os casos, o objeto aqui é humano.</p>

<p><b>Bill Venners</b>: O que é importante pensar dessa forma? Você diz: &#8220;Não subestime o fator humano.&#8221; Por quê?</p>

<p><b>Yukihiro Matsumoto</b>: Porque computadores não se importaria se eu devo fazer o esforço para se comunicar com eles ou se é fácil de se comunicar com eles. Eles não se importam se eu colocar o número de sequências de instruções de bytes em um arquivo e alimentá-lo com eles para correr, ou se uma linguagem de alto nível geradas as instruções. Com os computadores não me importo. Nós, seres humanos se preocupam com o esforço que nós pagamos. Muitas vezes as pessoas, especialmente engenheiros de computação, tem o foco sobre as máquinas. Eles pensam: &#8220;Ao fazer isso, a máquina irá correr mais rápido. Ao fazer isso, a máquina vai funcionar mais eficazmente. Ao fazer isso, a máquina algo algo algo.&#8221; Eles estão se concentrando em máquinas. Mas, na verdade temos de nos concentrar em seres humanos, sobre como os seres humanos se preocupam com fazer a programação e operação da aplicação das máquinas. Nós somos os mestres. Eles são os escravos.</p>

<p><b>Bill Venners</b>: Por enquanto, de qualquer maneira.</p>

<p><b>Yukihiro Matsumoto</b>: Por enquanto de qualquer forma, até a idade terminar.</p>

<h6>Princípio da menor surpresa</h6>

<p><b>Bill Venners</b>: Em uma entrevista, você disse &#8220;Eu projetei <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> para minimizar minha surpresa, eu estava muito surpreso quando as pessoas ao redor do mundo me disse que <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>Ruby reduziram a sua surpresa e reforçou a sua alegria de programar. Agora eu tenho certeza de que as mentes dos programadores.. são iguais em todo o mundo. &#8220;Por que o princípio da menor surpresa?</p>

<p><b>Yukihiro Matsumoto</b>: Na verdade, eu não fiz a alegação de que <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> segue o princípio da menor surpresa. Alguém sentiu a concepção de que <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> segue a filosofia, então eles começaram a dizer isso. Eu não trouxe o que, na verdade.</p>

<p>Eu queria minimizar minha frustração durante a programação, assim que eu quero minimizar meu esforço na programação. Esse era o meu objetivo principal no projeto <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>. Quero divertir-me na programação. Depois de libertar as pessoas de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> e muitos ao redor do mundo que conheci <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, eles disseram que sentem o que sinto. Eles vieram para cima com a frase do princípio da menor surpresa. Mas, na verdade, é muitas vezes incompreendido.</p>

<p><b>Bill Venners</b>: Como é mal compreendido?</p>

<p><b>Yukihiro Matsumoto</b>: Todo mundo tem um fundo individual. Alguém pode vir de <a href="http://www.python.org/">Python</a>, alguém pode vir de <a href="http://www.perl.org.br/Main/WebHome">Perl</a>, e podem ser surpreendido por diferentes aspectos da linguagem. Em seguida, eles vêm até mim e dizer: &#8220;Fiquei surpreso com esse recurso da língua, assim, portanto, o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> viola o princípio da menor surpresa&#8221;. Espere. Espere. O princípio da menor surpresa não é apenas para você. O princípio da menor surpresa significa princípio, pelo menos da minha surpresa. E isso significa que o princípio da menor surpresa depois que você aprender <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> muito bem. Por exemplo, eu era um programador <a href="http://pt.wikipedia.org/wiki/C%2B%2B">C++</a> antes de começar a projetar <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>. Eu programei em <a href="http://pt.wikipedia.org/wiki/C%2B%2B">C++</a> exclusivamente dois ou três anos. E depois de dois anos de programação <a href="http://pt.wikipedia.org/wiki/C%2B%2B">C++</a>, ele ainda me surpreendeu.</p>

<p>Fonte: <a href="http://www.artima.com">Artima</a></p>

&#8212;&#8212;
<p>
É isso ai amigos.. uma boa entrevista!

Até a proxima! =D</p>

]]></content>
  </entry>
  
</feed>
