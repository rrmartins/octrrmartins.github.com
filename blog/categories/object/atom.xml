<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Object | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/object/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-05-20T13:39:00-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part IV]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-iv/"/>
    <updated>2012-05-20T13:01:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-iv</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Ordem de Object</h3>


<p></p>

<p>Praticamente todas as classes podem definir o método ==, sendo útil para testar as suas instâncias para a igualdade. Algumas
classes também podem definir uma ordenação. Ou seja: para quaisquer duas instâncias de uma classe, as duas instâncias devem ser iguais,
ou uma instância deve ser "menos que" a outra. Numbers são das classes mais óbvias para que tal ordenação seja definido.
String são também ordena, de acordo com o numéro de ordenação dos códigos de caracteres que compõem as strings. Se uma classe define
uns casos de pedido, em seguida, a classe pode ser comparada e classificada.</p>

<!--more-->


<p>Em Ruby, classes definem um ordenação através da implementação do operador &lt;=>. Este operador deve retornar -1 se o operando da esquerda
é menor que o operando da direita, 0 se os dois operandos são iguais, e 1 se o operando esquerdo é maior que o operando direito.
Se os dois operandos não podem ser  significativamente comparados (se o operando direito é de uma classe diferente, por exemplo),
em seguida, o operador deve retornar nil:</p>

<p><code>ruby Operador &lt;=&gt;
1 &lt;=&gt; 5 # -1
5 &lt;=&gt; 5 # 0
9 &lt;=&gt; 5 # 1
"1" &lt;=&gt; 5 # nil: inteiros e strings não são comparáveis
</code></p>

<p>O operador &lt;=> é tudo que é necessário para comparar os valores. Mas não é particularmente intuitivo. Assim, as classes que definem
este operador tipicamente também incluir o Módulo <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> como um mixin.
(Módulos e mixins são abordados em Módulos como Mixins). O mixin Comparable define o seguinte operador em termos de &lt;=>:</p>

<pre><code>&lt;   -   Menor que
&lt;=  -   Menor ou igual
==  -   Igual
&gt;=  -   Maior ou igual
&gt;   -   Maior que
</code></pre>

<p><a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> não define o operador !=; o Ruby automaticamente define o
operador como a negação do operador ==. Além destes operadores de comparação, <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> também define um método útil de comparação com o between? :</p>

<p><code>ruby Comparable between?
1.between?(0,10) # verdadeiro: 0 &lt;= 1 &lt;= 10
</code></p>

<p>Se o operador &lt;=> retornar nil, todos os operadores de comparação dele derivados retornam falso. O especial Float com valor NaN é um exemplo:</p>

<p><code>ruby Float NaN
nan = 0.0/0.0; # zero dividido por zero não é um número
nan &lt; 0 # false: não é menor que zero
nan &gt; 0 # false: não é maior que zero
nan == 0 # false: não é igual a zero
nan == nan # false: não é mesmo igual a si mesmo!
nan.equal?(nan) # isso é verdade, claro
</code></p>

<p>Observe que a definição de &lt;=> e incluindo o módulo <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> define um operador == para o sua classe. Algumas classes que definem o seu próprio operador ==, normalmente quando eles podem
implementar esta forma mais eficiente do que um teste de igualdade com base no operador &lt;=>. É possível definir classes que
implementam diferentes noções de igualdade em seus operadores == e &lt;=>. Uma classe pode fazer comparações de string case-sensitive
para o operador ==, por exemplo, mas, em seguida, fazem comparações de maiúsculos e minúsculos com &lt;=>, de modo que as instâncias da classe
se classificam com mais naturalidade. Em geral, porém, é melhor se &lt;=> retorna 0 se e somente se == retorna true.</p>

<p>É isso amigos... o proximo post vamos conversar um pouco de Conversões de Object's.</p>

<p>Até Mais..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part III]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-iii/"/>
    <updated>2012-05-19T16:58:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-iii</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Igualdade objeto</h3>


<p>Ruby tem um número surpreendente de maneiras de comparar objetos para igualdade, e é importante entender como eles funcionam, assim você sabe quando usar cada método.</p>

<!--more-->




<h3>O método equal? </h3>


<p>O método equal? é definido pelo objeto para testar se os dois valores referem-se exatamente o mesmo objeto. Para qualquer dos dois
distintos objetos, esse método sempre retorna false:</p>

<p><code>ruby equal?
a = "Ruby" # Uma referência a um objeto String
b = c = "Ruby" # Duas referências a outro objeto String
a.equal?(b) # falsa: a e b são objetos diferentes
b.equal?(c) # verdadeiro: b e c referem-se ao mesmo objeto
</code></p>

<p>Por convenção, nunca subclasses substituem o método equal?.</p>

<p>Outra maneira de determinar se os dois objetos são, de fato, do mesmo objetivo é verificar a sua object_id:</p>

<p><code>ruby equal?
a.object_id == b.object_id # Funciona como a.equal? ​​(b)
</code></p>

<h3>O operador ==</h3>


<p>O operador == é a forma mais comum para testar a igualdade. Na Classe Object, é simplesmente uns testes de sinónimos para equal?, e
se duas referências de objeto são idênticos. A maioria das classes redefinem este operador para permitir instâncias distintas para ser
testado para igualdade:</p>

<p><code>ruby Operador ==
a = "Ruby" # uma string
b = "Ruby" # Um objeto String diferente com o mesmo conteúdo
a.equal?(b) # falsa: a e b não se referem ao mesmo objeto
a == b # verdade: mas estes dois objetos distintos têm valores iguais
</code></p>

<p>Note que o único sinal de igual nesse código é o operador de atribuição. Leva dois sinais de igual para testar a igualdade
em Ruby (esta é uma convenção que compartilha Ruby com muitas outras linguagens de programação).</p>

<p>Padrão de Classes do Ruby definem o operador == para implementar uma razoável definição de igualdade. Isso inclui Array
e as classes de hash. Dois Arrays são iguais de acordo com == se tiverem o mesmo número de elementos,
e se os seus elementos correspondentes são todos iguais de acordo com ==. Dois hashes são == se contiverem o mesmo número de pares
chave/valor, e se as chaves e valores são, eles próprios iguais. (Os valores são comparados com o operador ==,
mas chaves de hash são comparados com o método eql?.)</p>

<pre><code>Igualdade para programadores Java

Se você é um programador Java, você está acostumado a usar o operador == para testar se dois objetos são
o mesmo objeto, e você está acostumado a usar o método equals para testar se dois objetos distintos têm o mesmo valor. 
Convenção do Ruby é apenas sobre o oposto de Java.
</code></pre>

<p>As classes numéricas realizam conversões de tipo simples nas suas operações de ==, de modo que (por exemplo) o
Fixnum 1 e o Float 1.0 comparados como iguais. O operador == de classes, como String e Array, normalmente requerem dois operandos
para ser da mesma classe. Se o operando do lado direito define uma to_str ou função de conversão to_ary, então estes operadores invocam
o operador == definido pelo lado direito operando, e deixam que objeto decidem se é igual ao lado esquerdo, sendo string ou array.
Assim, é possível (embora não comum) para definir classes com comportamento comparação de string ou array.</p>

<p>!= ("Não-igual") é usado em Ruby para testar a desigualdade. Quando o Ruby vê !=, Ele simplesmente usa o operador == e depois
inverte o resultado. Isto significa que uma única classe precisa definir o operador == para definir a sua própria noção de
igualdade. Ruby dá o operador != de graça. No Ruby 1.9, no entanto, as classes podem explicitamente definir os seus próprios operadores !=.</p>

<h3>O método eql?</h3>


<p>O método eql? é definido pelo objeto como um sinônimo para equal?. Classes que se sobrepõem a ele normalmente usá ele como uma
versão rígida do operador == que não faz nenhum tipo de conversão. Por exemplo:</p>

<p><code>ruby eql?
1 == 1.0 # verdade: Fixnum e objetos flutuantes podem ser ==
1.eql (1,0) # falsa: mas eles nunca são eql!
</code></p>

<p>A classe Hash usa eql? para verificar se duas chaves de hash são iguais. Se dois objetos são eql?, os métodos de hash também
deve retornar o mesmo valor. Normalmente, se você criar uma classe e defini o operador ==, você pode simplesmente escrever um
método de hash e definir eql? para usar ==.</p>

<h3>O operador ===</h3>


<p>O operador === é comumente chamado de "caso de igualdade" e é usado para testar se o valor-alvo de uma declaração caso corresponde
a qualquer das cláusulas, quando dessa declaração.</p>

<p>Classe Object define por padrão o operador === para que ele chama o operador ==. Para muitas classes, por conseguinte, a igualdade
caso é o mesmo que == (igualdade). Mas certas classes principais definem === de maneira diferente, e nestes casos, é mais de um membro
ou operador correspondente. Range define === para testar se um valor está dentro do intervalo. Regexp define === para testar se uma
string corresponde à expressão regular. E Class define === para testar se um objeto é uma instância dessa Class. No Ruby 1.9, Symbol
define === retornando true se o operando do lado direito é o mesmo símbolo como o esquerda ou se é uma cadeia guardando o mesmo texto.
Exemplos:</p>

<p><code>ruby Operador ===
(1..10) === 5 # verdadeiro: 5 está na gama de 1 .. 10
/\d+/ === "123" # verdade: a seqüência corresponde à expressão regular
String === "s" # verdade: "s" é uma instância da classe String
:s === "s" # verdadeiro no Ruby 1.9
</code></p>

<p>É raro ver o operador === usado explicitamente como este. Mais comumente, a sua utilização é simplesmente implícita em uma instrução case.</p>

<h3>O operador =~</h3>


<p>O operador =~ é definido pela String e Regexp (e Symbol no Ruby 1.9) para realizar ligações de padrões, e isso não é realmente um
operador de igualdade em tudo. Mas isso não tem um sinal de igual na mesma, de modo que ele está aqui para ser completo.
Objeto define uma versão sem o operador de =~, que sempre retorna false. Você pode definir este operador em sua própria classe,
se essa classe define um tipo de correspondência de operação padrão ou tem uma noção de igualdade aproximada, por exemplo.
!~ é definido como o inverso da =~. É definível em Ruby 1.9 mas não no Ruby 1.8</p>

<p>É isso ai rubistas... Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part II]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-ii/"/>
    <updated>2012-05-19T13:14:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-ii</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Identidade do objeto</h3>


<p>Cada objeto tem um identificador de objeto, um Fixnum, que você pode obter com o método object_id. O valor retornado por este
método é constante e exclusivo para a vida útil do objeto. Enquanto o objeto é acessível, ele terá sempre a mesma identificação, e não
outro objeto que irá partilhar do mesmo ID.</p>

<p>O ID de método é um sinônimo preterido para object_id. Ruby 1.8 emite um aviso se você usá-lo, e ele foi removido em
Ruby 1.9.</p>

<p><strong>id</strong> é um sinônimo válido para object_id. Ele existe como um retorno, assim você pode acessar ID de um objeto, mesmo se o método
object_id foi indefinido ou substituído.</p>

<p>A classe <a href="http://ruby-doc.org/core-1.9.3/Object.html">Object</a> implementa o método de hash para simplesmente retornar um
ID objeto.</p>

<!--more-->




<h3>Classe de Objeto e Tipo de Objeto</h3>


<p>Existem várias maneiras de determinar a classe de um objeto em Ruby. O mais simples é simplesmente perguntar para ele:</p>

<p><code>ruby Class
o = "teste" # Este é um valor
o.class # Retorna um objeto que representa a classe String
</code></p>

<p>Se você estiver interessado na hierarquia de classe de um objeto, você pode perguntar para qualquer classe qual é sua superclasse:</p>

<p><code>ruby Class - Ruby 1.8
o.class # String: o é um objeto String
o.class.superclass # Object: superclasse de String é objeto
o.class.superclass.superclass # nil: Object não tem superclasse
</code></p>

<p>No Ruby 1.9, Object já não é a verdadeira raiz da hierarquia de classes:</p>

<p>``` ruby Class - Ruby 1.9</p>

<h1>Ruby 1.9</h1>

<p>Object.superclass # BasicObject: Object tem uma superclasse em 1.9
BasicObject.superclass # nil: BasicObject não tem nenhuma superclasse
```</p>

<p>Assim, uma forma particularmente simples para verificar a classe de um objeto é, por comparação direta:</p>

<p><code>ruby Class
o.class == String # true se o é uma String
</code></p>

<p>O método instance_of? faz a mesma coisa e é um pouco mais elegante:</p>

<p><code>ruby Class
o.instance_of? String # verdade se o é uma String
</code></p>

<p>Normalmente, quando testamos a classe de um objeto, também gostaríamos saber se o objeto é uma instância de qualquer subclasse
dessa classe. Para testar isso, use o método is_a?, ou seu sinônimo kind_of?</p>

<p><code>ruby Class
x = 1 # Este é o valor que estamos trabalhando com
x.instance_of? Fixnum # verdade: é uma instância de Fixnum
x.instance_of? Numeric # false: instance_of? não verifica a herança
x.is_a? Fixnum # verdadeiro: x é um Fixnum
x.is_a? Integer # verdade: x é um número inteiro
x.is_a? Numeric # verdade: x é um numérico
x.is_a? Comparable # verdade: funciona também com módulos mixin
x.is_a? Object # verdadeira para qualquer valor de x
</code></p>

<p>A classe Class define o operador === em tal modo que ele pode ser usado no lugar do is_a?:</p>

<p><code>ruby Class method ===
Numeric === x # verdade: x is_a Numérico
</code></p>

<p>Essa expressão é exclusivo para Ruby e é, provavelmente, menos legível do que utilizando o mais tradicional método is_a?.</p>

<p>Cada objeto tem uma classe bem definida em Ruby, e que a classe nunca muda durante a vida útil do objeto. Um objeto
type, por outro lado, é mais fluido. O tipo de um objeto está relacionada à sua classe, mas a classe é apenas parte de um
tipo de objeto. Quando falamos sobre o tipo de um objeto, nós entendemos o conjunto de comportamentos que caracterizam o objeto.
Outra maneira é colocar o tipo de um objeto em um conjunto de métodos que podem responder.
(Esta definição torna-se recursiva, porque não é apenas o nome dos métodos que importam, mas também os tipos de argumentos que os
métodos podem aceitar.)</p>

<p>Na programação com Ruby, que muitas vezes não se preocupam com a classe de um objeto, nós só queremos saber se podemos invocar
algum método nele.  Considere-se, por exemplo, o operador &lt;&lt;. Arrays, strings, files e outros I/O relacionados ao definir as classes
isso como um operador de acréscimo. Se estamos escrevendo um método que produz produção textual, podemos escrever, genericamente,
a usar esse operador. Então, o nosso método pode ser invocado com qualquer argumento que implementa &lt;&lt;. Nós não nos importamos com a
classe do argumento, basta que possamos anexá-lo. Nós podemos testar para isto com o método respond_to? :</p>

<p><code>ruby Class respond_to?
o.respond_to? :"&lt;&lt;" # Verdadeiro se o operador tem uma &lt;&lt;
</code></p>

<p>A deficiência desta abordagem é que ela só verifica o nome de um método, não os argumentos para esse método. Por exemplo,
Fixnum e Bignum implementam &lt;&lt; como um operador de deslocamento à esquerda e espera o argumento de ser um número em vez de uma string.
Objetos inteiros parecem ser "appendable" (adicionável) quando usamos um respond_to? de teste, mas que produzem um erro quando
adiciona um código em string. Não há uma solução geral para este problema, mas um recurso ad-hoc, neste caso,
é explicitamente excluir objectos numéricos com o método is_a? :</p>

<p><code>ruby Class
o.respond_to? :"&lt;&lt;" and not o.is_a? Numeric
</code></p>

<p>Outro exemplo do tipo distinção-versus-classe é a classe StringIO<a href="partir%20da%20Biblioteca%20padrão%20do%20Ruby">*</a>. StringIO permite a
leitura e gravação das strings como se fossem Objetos de IO. StringIO[*] imita os objetos IO API-StringIO definem os mesmos métodos
que os objetos IO fazem. Mas StringIO não é uma subclasse de IO. Se você escrever um método que espera um argumento de fluxo,
e testa a classe do argumento com is_a? IO, em seguida, o método não funciona com argumentos StringIO.</p>

<p>[*] -> <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/stringio/rdoc/StringIO.html">StringIO</a></p>

<p>É isso ai rubistas... A cada vez que leio sobre, me apaixono mais. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part I]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2/"/>
    <updated>2012-05-19T10:23:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>


<p>Ruby é uma forma muito pura de linguagem orientada a objetos: todos os valores são
objetos, e não há distinção entre tipos primitivos e tipos de objetos, como existem em muitos
outras línguas. Em Ruby, todos os objetos herdam de uma classe chamada
<a href="http://ruby-doc.org/core-1.9.3/Object.html">Object</a> e compartilhar os métodos definidos
por essa classe. Esta seção explica as características comuns de todos os objetos
em Ruby. Teremos algumas partes para falar desta classe tão poderosa, mas é muito importante para o entendimento de OO em Ruby.</p>

<!--more-->


<h3>Referências de objeto</h3>


<p>Quando trabalhamos com objetos em Ruby, realmente estamos trabalhando com referências a objetos. Não é o
próprio objeto que manipula, mas uma referência a ele<a href="/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2/#referencia">[*]</a>.
Quando atribuir um valor a uma variável, não estamos copiando um objeto "em" variável que, nós
São apenas armazenar uma referência a um objeto para essa variável. Alguns
código deixa isso claro:</p>

<p><code>ruby Objects
s = "Ruby" # Criar um objeto String. Armazenar uma referência a ele em s.
t = s # Copiar a referência a t. s e t referem-se ambos para o mesmo objeto.
t[-1] = "" # Modificar o objeto através da referência t.
print s # Acesse o objeto modificado através de s. Prints "Esfregue".
t = "Java" # t agora se refere a um objeto diferente.
print s, t # Imprime "RubJava".
</code></p>

<p>Quando você passar um objeto para um método em Ruby, é um objeto
referência que é passado para o método. Não é o objeto em si,
e não é uma referência para a referência ao objecto. Outra forma
dizer isso é que os argumentos do método são passados ​​por
valor e não por referência, mas
que os valores passados ​​são referências de objeto.</p>

<p>Porque as referências de objeto são passados ​​para os métodos, os métodos podem usar
essas referências para modificar o objeto subjacente. Essas modificações
são, então, visível quando o método retorna.</p>

<h3>Valores imediatos</h3>


<p>Nós dissemos que todos os valores em Ruby são objetos e todos os objetos
são manipulados por referência. Na implementação de referência, no entanto objetos Fixnum e Symbol são realmente "valores imediatos",
em vez de referências. Nenhuma destas duas classes tem métodos diferenciados, de modo que os
Objetos Fixnum e símbolo são imutáveis, o que significa que não há realmente nenhuma maneira de dizer que eles são manipulados por
valor, e não pela existência de valores de referencia.</p>

<p>A existência de valores imediatos deve ser considerado um detalhe de implementação. A única diferença prática entre
valores imediatos e valores de referência é que os valores imediatos
não pode ter métodos singleton definidas sobre eles.</p>

<h3>Vida útil de objeto</h3>


<p>As classes internas em Ruby descritas neste capítulo têm sintaxes literal e instâncias dessas classes são criadas simplesmente por
inclusão de valores literalmente em seu código. Objetos de outras classes precisam ser explicitamente criados,
e isso é feito na maioria das vezes com um método chamado de new:</p>

<p><code>ruby Class.new
myObject = MyClass.New
</code></p>

<p>new é um método do Classe Class. Atribui na memória para manter o objeto new, então ele inicializa o estado do
recém alocados objetos "vazio", invocando seu método initialize. Os argumentos para new são passadas diretamente para inicializar.
A maioria das classes definem um método initialize para executar qualquer inicialização, sendo necessário para instâncias.</p>

<p>Os métodos new e initialize fornecer o padrão técnico para a criação de novas classes, mas classes também podem definir outros
métodos, conhecidos como "métodos de fábrica", que retornam instâncias.</p>

<p>Objetos Ruby não precisa ser desalocada explicitamente, como o fazem as linguagens C, C++, entre outras. Ruby usa uma técnica chamada
<a href="http://www.rubyinside.com.br/como-o-ruby-gerencia-memoria-e-faz-garbage-collection-3018">garbage collection</a> (coleta de lixo) automaticamente, para destruir objetos que não são mais necessários. Um objeto se torna um candidato para o garbage collection quando é
inacessível, quando não há referências restantes para o objeto com exceção de outros objetos inacessíveis.</p>

<p>O fato de que Ruby usa garbage collection, isso significa que programas em Ruby são menos suscetíveis a vazamentos de memória
que os programas escritos em linguagems que requerem objetos e memória para ser desalocada explicitamente e liberado.
Mas o garbage collection não significa que vazamentos de memória são impossíveis:
qualquer código que cria vida longa tem referências a objetos que de outro modo seria de curta duração pode ser uma fonte de
falhas de memória. Considere um hash usado como um cache. Se o cache não é podado usando algum tipo de algoritmo
menos utilizado recentemente, os objetos em cache permanecem acessíveis enquanto o hash em si é alcançável. Se o hash
é referenciado por uma variável global, então será acessível como desde que o interpretador Ruby está sendo executado.</p>

<p><a href="referencia"></a></p>

<pre><code>[*] -&gt; Se você está familiarizado com C ou C++, você pode pensar de uma
referência como um ponteiro: o endereço do objeto na memória. Ruby
não utiliza ponteiros, no entanto. Referências em Ruby são opacas e
internas para a implementação. Não há maneira de tirar o
tratamento de um valor não referenciado, um valor, ou fazer ponteiro aritmético.
</code></pre>

<p>Um pouco de conceito de Objetos, logo teremos mais na pratica...</p>

<p>Até a proxima</p>
]]></content>
  </entry>
  
</feed>
