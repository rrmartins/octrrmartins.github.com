<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Eloquent Ruby | Rodrigo Martins]]></title>
<<<<<<< HEAD
  <link href="http://rrmartins.github.com/blog/categories/eloquent-ruby/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
<<<<<<< HEAD
  <updated>2013-04-28T19:27:30-03:00</updated>
=======
  <updated>2014-02-27T11:04:59-03:00</updated>
>>>>>>> 55255938ca2a035ba9dea4f1892ebb919702c830
  <id>http://rrmartins.github.com/</id>
=======
  <link href="http://rrmartins.com/blog/categories/eloquent-ruby/atom.xml" rel="self"/>
  <link href="http://rrmartins.com/"/>
  <updated>2015-01-30T14:40:06-02:00</updated>
  <id>http://rrmartins.com/</id>
>>>>>>> 45205015902ee4fa744defb597ae74e0f64ad496
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Não é bem uma String]]></title>
    <link href="http://rrmartins.com/blog/2013/04/28/nao-e-bem-uma-string/"/>
    <updated>2013-04-28T18:35:00-03:00</updated>
    <id>http://rrmartins.com/blog/2013/04/28/nao-e-bem-uma-string</id>
    <content type="html"><![CDATA[<!--more-->


<p>Continuando o ultimo post <a href="/blog/2013/04/28/as-duas-faces-de-string/">As Duas Faces de String</a>
que finaliza com a pergunta:</p>

<pre><code>Então, por que o Ruby nos fornece tanto?
</code></pre>

<p>A resposta é que nós tendemos a usar cadeias de caracteres em nosso código para duas finalidades diferentes:
O primeiro, e mais óbvio, o uso de <code>strings</code> é manter alguns dados que estamos processando. Leia naqueles
objetos livro a partir do banco de dados e você muito provavelmente vai ter suas mãos cheias de dados de
<code>string</code>, coisas como o título do livro, o autor, o nome do AOS, e o texto real.</p>

<p>A segunda maneira que nós usamos cadeias de caracteres é para representar as coisas em nossos programas,
coisas como querer encontrar <code>:all</code> registros em uma tabela. A principal coisa sobre: ​​tudo em nosso exemplo
de <code>Books</code> é que ActiveRecord pode reconhecê-lo quando vê-lo - o código precisa saber quais registros para
voltar, e <code>:all</code> é um flag que diz que ele deve retornar cada um. O bom de usar algo como <code>:all</code> para esse
tipo de "significa" que ele também faz sentido para os seres humanos: Você é muito mais propenso a reconhecer
que <code>:all</code> quando você se depara com ele do que <code>0</code>, ou <code>-1</code>, ou mesmo <code>0x29ef</code>(Deus me perdoe!).</p>

<p>Estes dois usos para cadeias de caracteres - para tarefas de processamento de dados regulares sobre a
um lado, e, postos de trabalho, do tipo marcador simbólicos internos sobre o outro - faz muita
diferença sobre demandas de objetos. Se você estiver processando dados, você vai querer ter toda a gama de
ferramentas de manipulação de <code>string</code> na ponta dos dedos: Você pode querer os dez primeiros caracteres do
título, ou você pode querer obter o seu comprimento ou ver se ele corresponde a alguma expressão regular. Por
outro lado, se você estiver usando alguns caracteres para estar em algo no seu código, você provavelmente não
está muito interessado em brincar com os caracteres reais. Em vez disso, neste segundo caso, você só precisa
saber se essa coisa é o flag que fala para você encontrar todos os registros ou apenas o primeiro registro.
Principalmente, quando você quer alguns caracteres para representar algo, você simplesmente precisa saber se
esta é a forma rápida e confiável.</p>

<p>Até mais galera! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Expressões Regulares em Ruby]]></title>
    <link href="http://rrmartins.com/blog/2013/04/28/expressoes-regulares-em-ruby/"/>
    <updated>2013-04-28T13:52:00-03:00</updated>
    <id>http://rrmartins.com/blog/2013/04/28/expressoes-regulares-em-ruby</id>
    <content type="html"><![CDATA[<!--more-->


<p>Olá amigos,</p>

<p>Ando meio sumido, mas pretendo voltar a fazer os posts, e dar continuidade nos estudos.</p>

<p>Volto falando um pouco de <code>Expressão Regular</code> em Ruby(<a href="http://ruby-doc.org/core-1.9.3/Regexp.html">1.9.3</a>, <a href="http://ruby-doc.org/core-2.0/Regexp.htm">2.0</a>), vou abordar as duas ultimas versões do Ruby, mas gostaria de deixar claro que a nova versão <a href="http://ruby-doc.org/core-2.0/">2.0</a> é a que estou usando, e não esta me deixando na mão.</p>

<p>Em Ruby, a expressão regular, ou <code>Regexp</code>(<a href="http://ruby-doc.org/core-1.9.3/Regexp.html">1.9.3</a>, <a href="http://ruby-doc.org/core-2.0/Regexp.htm">2.0</a>), tem sua própria sintaxe literal especial. Para fazer uma expressão regular em Ruby que você encerra o seu padrão entre as barras. Então, em Ruby nossa expressão regular seria:</p>

<p><code>ruby Regexp
/\d\d:\d\d (AM|PM)/
</code></p>

<p>Você usa o operador <code>=~</code> para testar se uma expressão regular corresponde a uma string. Assim, se quisermos corresponder à expressão regular acima com um tempo real que seria executado:</p>

<p>``` ruby Regexp</p>

<h1>1.9.3 e 2.0</h1>

<blockquote><p>puts /\d\d:\d\d (AM|PM)/ =~ '10:24 PM'
=> 0
```</p></blockquote>

<p>Que o zero está tentando nos dizer muitas coisas. Primeiro, ele está dizendo que a expressão correspondente, esta começando no
índice zero. Em segundo lugar, o zero está nos dizendo é que, quando você combinar uma expressão regular, Ruby verifica ao longo
da String, procurando um conjunto em qualquer lugar da string. Podemos ver a digitalização em ação com este exemplo seguinte:</p>

<p>``` ruby Regexp</p>

<h1>1.9.3 e 2.0</h1>

<blockquote><p>puts /PM/ =~ '10:24 PM'
=> 6
```</p></blockquote>

<p>Que seis é uma indicação de onde o Regexp encontrou, mas só depois de Ruby digitalizar bem a string. Se não houver
correspondência, então você não vai ter um retorno para o seu problema, de modo a que este:</p>

<p>``` ruby Regexp</p>

<h1>1.9.3 e 2.0</h1>

<blockquote><p>/May/ =~ 'Sometime in June'
=> nil
```</p></blockquote>

<p>Voltará <code>nil</code>. Desde o operador <code>=~</code> retorna um número quando se encontra uma correspondência e <code>nil</code> se não, você pode usar
conjuntos de expressões regulares como booleanos:</p>

<p>```ruby Regexp</p>

<h1>1.9.3 e 2.0</h1>

<blockquote><p>the_time = '10:24 AM'
puts "É de manhã!" if /AM/ =~ the_time
=> É de manhã!
```</p></blockquote>

<p>O operador <code>=~</code> também é ambidestro: Não importa se a string ou a expressão regular vem em primeiro lugar, para que pudéssemos
refazer o último exemplo, como:</p>

<p>```ruby Regexp</p>

<h1>1.9.3 e 2.0</h1>

<blockquote><p>puts "É de manhã!" if '10:24 AM' =~ /AM/
=> É de manhã!
```</p></blockquote>

<p>Como disse, as expressões regulares são por padrão <code>case sensitive</code>: <code>/AM/</code> não corresponde <code>/am/</code>. Felizmente, você pode
transformar esse <code>case sensitive</code> colocando um i no fim de sua expressão, de modo que este:</p>

<p>```ruby Regexp</p>

<h1>1.9.3 e 2.0</h1>

<blockquote><p>puts "É de manhã!" if /AM/i =~ 'am'
=> É de manhã!
```</p></blockquote>

<p>Irá imprimir algo!</p>

<p>Além de seu uso mais ou menos independente com o operador <code>=~</code>, expressões regulares também entram em jogo nos métodos de <code>string</code>
que envolvem a pesquisa. Assim, você pode passar uma expressão regular para o método <a href="http://ruby-doc.org/core-2.0/String.html#method-i-gsub">gsub</a> da classe <code>string</code>, talvez para apagar todo o conteúdo de um documento:</p>

<p>```ruby Regexp
class Document
  # A maioria da classe omitida...</p>

<p>  def obscure_times!</p>

<pre><code>@content.gsub!( /\d\d:\d\d (AM|PM)/, '**:** **' )
</code></pre>

<p>  end
end
```</p>

<p>Expressão Regular é muito usado e em alguns momentos ajuda a reduzir bastante as condicionais.</p>

<p>Até mais... :)</p>
]]></content>
  </entry>
  
</feed>
