<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-05-08T23:05:34-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte II - Hashs Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2-parte-ii-hashs-literais/"/>
    <updated>2012-05-08T22:28:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2-parte-ii-hashs-literais</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Na primeira parte eu fiz uma introdução do Hash:
-> <a href="/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2/">O Mundo Hash no Ruby 1.9.2 - Parte I</a></p>

<p>Vamos lá!</p>

<p>Um literal de hash é escrita como uma lista separada por vírgulas de chave/valor de
pares, colocados dentro de chaves. Chaves e valores são separados
com um caractere de dois "arrow": '=>'. O objeto Hash criado anteriormente também pode ser
criado com o literal seguinte:</p>

<!--more-->


<p><code>ruby Hash Literal
números = {"um" =&gt; 1, "dois" =&gt; 2, "três" =&gt; 3}
</code></p>

<p>Em geral, objetos <a href="http://www.ruby-doc.org/core-1.9.2/Symbol.html">Símbolos</a> trabalham mais eficientemente como chaves de hash de strings, fazem assim:</p>

<p><code>ruby Hash Literal
números = {:um =&gt; 1,:dois =&gt; 2,:três =&gt; 3}
</code></p>

<p>Os <a href="http://www.ruby-doc.org/core-1.9.2/Symbol.html">Símbolos</a> são imutáveis, escrito como
prefixados identificadores, que serão explicados em maior detalhe em um outro post.</p>

<p>Ruby 1.8 permite vírgulas em lugar de setas, mas isso não teve a sintaxe substituída, mais suportado no Ruby 1.9:</p>

<p><code>ruby Hash Literal
 numeros = {:um, 1, :dois, 2, :tres, 3} # Igual, mas mais difícil de ler
</code></p>

<p>Tanto Ruby 1.8 quanto no Ruby 1.9 permite uma única vírgula à direita do
final da lista de chave / valor:</p>

<p><code>ruby Hash Literal
números = {: um =&gt; 1,: dois =&gt; 2} # vírgula extra ignorado
</code></p>

<p>Ruby 1.9 suporta muito útil e sucinto a sintaxe literal de Hash
quando as chaves são símbolos. Neste caso, move-se para o fim da chave de hash e substitui a seta:</p>

<p><code>ruby Hash Literal
números = {um: 1, dois: 2, tres: 3}
</code></p>

<p>Note-se que pode não haver qualquer espaço entre a chave Hash
identificador e dos dois pontos.</p>

<p>Até breve!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte I]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2/"/>
    <updated>2012-05-08T21:27:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Um hash é uma estrutura de dados que mantém um conjunto de objetos conhecidos
como chaves, e associa um valor com cada chave. Hashs são também conhecidos como mapas porque mapeam as chaves para
valores. Eles às vezes são chamados de matrizes associativas, porque eles
associam valores com cada uma das chaves, e pode ser pensado como matrizes
em que o índice da matriz pode ser qualquer objeto em vez de um inteiro. um
exemplo torna isso mais claro:</p>

<p>```ruby Hash</p>

<h1>Este hash irá mapear os nomes dos dígitos para os dígitos se</h1>

<p>números = Hash.new # Criar um novo objeto, vazio de hash
números["um"] = 1 # Mapa do String "um" para o Fixnum 1
números["dois"] = 2 # Note que estamos usando a notação de matriz aqui
números["três"] = 3</p>

<p>soma = números["um"] + números["dois"] # soma os valores e resulta em "3"
```</p>

<p>Esta introdução à sintaxe hashes de hash documentos Ruby literal
e explica os requisitos para um objeto a ser usado como uma chave hash.
Mais informações sobre a API definida pela classe Hash é fornecido em <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html">Hashes</a>.</p>

<p>Em breve, mais conteudo de Hash!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Um pouco de Array no Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/07/um-pouco-de-array-no-ruby/"/>
    <updated>2012-05-07T13:02:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/07/um-pouco-de-array-no-ruby</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Um Array é uma seqüência de valores que permite que os valores serem acessados ​​por sua posição, ou índice, na seqüência. Em Ruby, o primeiro valor em um array tem índice 0. Os métodos size e length, retornam o número de elementos em um Array. O último
elemento do Array é no índice de size-1. Valores de índice negativo contar a partir do
final do Array, de modo que o último elemento de uma Array também pode ser acessado
com um índice de -1. O segundo ao último tem um índice de -2,
e assim por diante. Se você tentar ler um elemento além do final de uma Array
(Com um index >= size), ou antes
o início de um Array (com um index &lt; size), Ruby simplesmente retorna nil e não lançará uma exceção.</p>

<!--more-->


<p>Arrays de Ruby não são tipados e mutáveis. Os elementos de um Array
não precisam de ser todos da mesma classe, e eles podem ser alterados em qualquer momento.
Além disso, os Arrays são dinamicamente redimensionáveis, você pode acrescentar elementos
a eles e crescer conforme necessário. Se você atribuir um valor a um elemento
além do final do Array, a Array é automaticamente prorrogado com
elementos nil. (É um erro, No entanto, para atribuir um valor para um elemento antes do início de um
Array.)</p>

<p>Uma Array literal é uma lista separada por vírgulas de valores, dentro de
parênteses:</p>

<p><code>ruby Arrays Literal
[1, 2, 3] # Uma Array que contém três objetos Fixnum
[-10 ... 0, 0 .. 10,] # Uma Array de duas faixas; vírgulas extras são permitidos
[[1,2], [3,4], [5]] # Uma Array de Arrayes aninhadas
[X + y, xy, x * y] # array os elementos podem ser expressões arbitrárias
[] # O array vazio tem o tamanho 0
</code></p>

<p>Ruby inclui uma sintaxe especial, no caso para expressar literais de Array
cujos elementos são seqüências curtas sem espaços:</p>

<p><code>ruby Arrays
palavras = %w[este é um teste] # O mesmo que: ['este', 'é', 'um', 'teste']
aberto = %w| ( [ { &lt; | # O mesmo que: ['(', '[', '{', '&lt;']
branco = %W(\s \t \r \n) # O mesmo que: ["\ s", "\ t", "\ r", "\ n"]
</code></p>

<p>%w e %W introduzir uma Array literal, bem como %q e %Q introduzir uma string literal. Em
particular, as regras delimitadores para %w e %W são as mesmos que para %q e %Q. Dentro dos delimitadores, sem aspas
são necessários em torno das cadeias de elementos do array, e sem vírgulas são
requerido entre os elementos. Elementos do Array são delimitados por espaço em branco.</p>

<p>Você também pode criar Arrays com o construtor Array.new, e isso proporciona
opções de programação inicializando os elementos de Array:</p>

<p><code>ruby Initiallize Array
vazio = Array.new # []: retorna um novo array vazio
nils = Array.new(3) # [nil, nil, nil]: nova Array com 3 elementos nulos
zeros = Array.new(4, 0) # [0, 0, 0, 0]: nova Array com 4 elementos 0
cópia = Array.new(nils) # Faça uma nova cópia de uma Array existente
count = Array.new(3) {| i | i +1} # [1,2,3]: 3 elementos calculado a partir do índice
</code></p>

<p>Para obter o valor de um elemento do Array, use um único número inteiro
entre colchetes:</p>

<p><code>ruby Valores com Array
a = [0, 1, 4, 9, 16] # O Array mantém os quadrados dos índices
a[0] # primeiro elemento é 0
a[-1] # O ultimo elemento é de 16
a[-2] # segundo ao último elemento é 9
a[a.size-1] # Outra forma de consultar o último elemento
a[-a.size] # Outra forma de consultar o primeiro elemento
a[8] # Consultando além do fim retorna nil
a[-8] # Consultando antes do início retorna nil, também
</code>
Todas as expressões acima, exceto para a última, pode também ser
utilizado no lado esquerdo de uma atribuição:</p>

<p><code>ruby Arrays
a[0] = "zero" # a é ["zero", 1, 4, 9, 16]
a[-1] = 1..16 # a é ["zero", 1, 4, 9, 1 .. 16]
a[8] = 64 # a é ["zero", 1, 4, 9, 1 .. 16, nil, nil, nil, 64]
a[-10] = 100 # erro: não é possível atribuir antes do início de um array
</code></p>

<p>Como strings, Arrayes também podem ser indexados com dois números inteiros que
representam um índice de partida e um número de elementos, ou um objeto de intervalo. Em qualquer caso, a expressão
retorna o sub-array especificado:</p>

<p><code>ruby Array
a = ('a'..'e').to_a # Faixa convertido para ['a', 'b', 'c', 'd', 'e']
a[0,0] # []: este subarray tem zero elementos
a[1,1] # ['b']: uma Array de um elemento
a[-2,2] # ['d', 'e']: os últimos dois elementos do array
a[0..2] # ['a', 'b', 'c']: os primeiros três elementos
a[-2 .. -1] # ['d', 'e']: os últimos dois elementos do array
a [0 ... -1] # ['a', 'b', 'c', 'd']: a totalidade, mas o último elemento
</code></p>

<p>Quando utilizado no lado esquerdo de uma atribuição, um sub-array pode ser
substituído pelos elementos do Array do lado direito. Esta básica
operação funciona para inserções e exclusões, bem como:</p>

<p><code>ruby Arrays
a[0,2] = ['A', 'B'] # se torna ['A', 'B', 'c', 'd', 'e']
a[2 ... 5] = ['C', 'D', 'E'] # se torna ['A', 'B', 'C', 'D', 'E']
a[0,0] = [1,2,3] # Inserir elementos no início de a
a[0 .. 2] = [] # Excluir os elementos
a[-1,1] = ['Z'] # Substitua último elemento com outro
a[-1,1] = 'Z' # Para os elementos individuais, a Array é opcional
a[-2,2] = nil # Excluir últimos 2 elementos em 1,8; substituir com nil em 1,9
</code></p>

<p>Além disso para o operador colchete para indexar um Array,
a classe Array define uma série de outros operadores úteis. Use + para
concatenar dois Arrays:</p>

<p><code>ruby Concatenar Arrays
a = [1, 2, 3] + [4, 5] # [1, 2, 3, 4, 5]
a = a + [[6, 7, 8]] # [1, 2, 3, 4, 5, [6, 7, 8]]
a = a + 9 # erro: lado direito deve ser um array
</code></p>

<p>O operador + cria um novo Array que contém os elementos de ambos os seus operandos. Use &lt;&lt; para acrescentar um elemento para o final de um
Array existente, e usar a concat anexar os elementos de um array:</p>

<p><code>ruby Array + e concat
a = [] # Comece com uma Array vazia
a &lt;&lt; 1 # a é [1]
a &lt;&lt; 2 &lt;&lt; 3 # a é [1, 2, 3]
a &lt;&lt; [4,5,6] # a é [1, 2, 3, [4, 5, 6]]
a.concat [7,8] # a é [1, 2, 3, [4, 5, 6], 7, 8]
</code></p>

<p>O operador - subtrai um Array do outro. Começa por fazer uma cópia de sua Array da esquerda,
e, em seguida, remove todos os elementos de que a cópia se que apareçam em qualquer
a Array do lado direito:</p>

<p><code>ruby Array -
['A', 'b', 'c', 'b', 'a'] - ['b', 'c', 'd'] # ['A', 'a']
</code></p>

<p>Como a classe String, Array também usa o operador de multiplicação
para a repetição:</p>

<p><code>ruby Array *
a = [0] * 8 # [0, 0, 0, 0, 0, 0, 0, 0]
</code></p>

<p>A classe Array contem tambem os Operadores booleanos (| , &amp;) e usa-los para a união e
interseção. | Concatena seu argumentos e, em seguida, remove todos os elementos repetidos no resultado.
&amp; retorna uma Array que contém elementos que aparecem em ambas as Arrayes de operando. A Array retornada
não contém elementos duplicados:</p>

<p><code>ruby Array
a = [1, 1, 2, 2, 3, 3, 4]
b = [5, 5, 4, 4, 3, 3, 2]
a | b # [1, 2, 3, 4, 5]: duplicatas são removidas
b | a # [5, 4, 3, 2, 1]: elementos são os mesmos, mas a ordem é diferente
a &amp; b # [2, 3, 4]
b &amp; a # [4, 3, 2]
</code></p>

<p>Note-se que estes operadores não são transitivos: a | b não é o mesmo que b | a, por exemplo. Se você ignorar o ordenamento
dos elementos, no entanto, e considerar os Arrays para ser ordenado os conjuntos,
então estes operadores fazem mais sentido. Note também que o algoritmo
que a união e intersecção são realizados não é especificado, e não
existem garantias sobre a ordem dos elementos no retornou dos
Arrays.</p>

<p>A classe Array define um bom número de alguns métodos úteis. O único que vamos discutir aqui é o iterador each, usada para loop através ds
elementos de um Array:</p>

<p><code>ruby Array each
a = ('A' .. 'Z').to_a # Comece com uma série de cartas
a.each {| x | print x} # Imprimir o alfabeto, uma letra de cada vez
</code></p>

<p>Outros métodos do Array você pode deseja procurar,  incluindo: clear,
compact!, delete_if, each_index, empty?, fill, flatten!, include?, index, join, pop,
push, reverse, reverse_each, rindex, shift, sort, sort!, uniq!, e unshift.</p>

<p><a href="http://www.ruby-doc.org/core-1.9.2/Array.html">www.ruby-doc.org/core-1.9.2/Array.html</a></p>

<p>Até a proxima amigos... :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A classe Encoding]]></title>
    <link href="http://rrmartins.github.com/blog/2012/04/30/a-classe-encoding/"/>
    <updated>2012-04-30T10:04:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/04/30/a-classe-encoding</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>A classe Encoding de Ruby 1.9 representa uma codificação de caracteres. Objetos de codificação para agir como identificadores opacos para uma codificação e não têm muitos métodos próprios. O nome do método retorna o nome de uma codificação. to_s é um sinônimo para o name, e inspect converte um objeto em uma seqüência de codificação de uma forma mais detalhada do que o name faz.</p>




<p>Ruby define uma constante para cada uma das codificações built-in's que ele suporta, e estes são a maneira mais fácil de especificar uma codificação em seu programa. As constantes predefinidas incluem pelo menos o seguinte:</p>


<p><code>ruby Encoding
Encoding::ASCII_8BIT     # Also ::BINARY
Encoding::UTF_8          # UTF-8-encoded Unicode characters
Encoding::EUC_JP         # EUC-encoded Japanese
Encoding::SHIFT_JIS      # Japanese: also ::SJIS, ::WINDOWS_31J, ::CP932
</code></p>

<!--more-->


<p>Observe que, como estas são constantes, eles devem ser escritos em letras maiúsculas e hífens nos nomes de codificação devem ser convertidos para sublinhados. Ruby 1.9 também suporta a codificação US-ASCII, as codificações européias ISO-8859-1 através da ISO-8859-15, e o Unicode UTF-16 e UTF-32 codificações em variantes big-endian e little-endian.</p>




<p>Se você tiver um nome de codificação como uma string e deseja obter o objeto de codificação correspondente, use o método de fábrica Encoding.find:</p>


<p><code>ruby Encoding
encoding = Encoding.find("utf-8")
</code></p>

<p>
Usando Encoding.find faz com que a codificação passa a ser carregada dinamicamente, se necessário. Encoding.find aceita names de codificação que são qualquer maiúsculo ou minúsculo. Chame o método name de uma codificação para obter o nome da codificação como uma string.</p>




<p>Encoding.list retorna uma matriz de todos os objetos de codificação disponíveis. Encoding.name_list retorna um array de nomes (como strings) de todas as codificações disponíveis. Codificações muito têm mais de um nome de uso comum, e Encoding.aliases retorna um hash que mapeia aliases de codificação para os names de codificação oficial pelos quais são sinônimos. A matriz retornada por Encoding.name_list inclui os aliases nos Encoding.aliases hash.</p>


<p><code>ruby Encoding.name_list
Encoding.name_list
 =&gt; ["ASCII-8BIT", "UTF-8", "US-ASCII", "Big5", "Big5-HKSCS", "Big5-UAO", "CP949", "Emacs-Mule", "EUC-JP",
 "EUC-KR", "EUC-TW", "GB18030", "GBK", "ISO-8859-1", "ISO-8859-2", "ISO-8859-3", "ISO-8859-4", "ISO-8859-5",
 "ISO-8859-6", "ISO-8859-7", "ISO-8859-8", "ISO-8859-9", "ISO-8859-10", "ISO-8859-11", "ISO-8859-13",
 "ISO-8859-14", "ISO-8859-15", "ISO-8859-16", "KOI8-R", "KOI8-U", "Shift_JIS", "UTF-16BE","UTF-16LE",
 "UTF-32BE", "UTF-32LE", "Windows-1251", "BINARY", "IBM437", "CP437", "IBM737", "CP737", "IBM775",
 "CP775", "CP850","IBM850", "IBM852", "CP852", "IBM855", "CP855", "IBM857", "CP857", "IBM860", "CP860",
 "IBM861", "CP861", "IBM862", "CP862", "IBM863","CP863", "IBM864", "CP864", "IBM865", "CP865", "IBM866",
 "CP866", "IBM869", "CP869", "Windows-1258", "CP1258", "GB1988","macCentEuro", "macCroatian", "macCyrillic",
 "macGreek", "macIceland", "macRoman", "macRomania", "macThai", "macTurkish","macUkraine", "CP950", "CP951",
 "stateless-ISO-2022-JP", "eucJP", "eucJP-ms", "euc-jp-ms", "CP51932", "eucKR", "eucTW", "GB2312","EUC-CN",
 "eucCN", "GB12345", "CP936", "ISO-2022-JP", "ISO2022-JP", "ISO-2022-JP-2", "ISO2022-JP2", "CP50220", "CP50221",
"ISO8859-1", "Windows-1252", "CP1252", "ISO8859-2", "Windows-1250", "CP1250", "ISO8859-3", "ISO8859-4",
"ISO8859-5", "ISO8859-6","Windows-1256", "CP1256", "ISO8859-7", "Windows-1253", "CP1253", "ISO8859-8",
"Windows-1255", "CP1255", "ISO8859-9", "Windows-1254", "CP1254", "ISO8859-10", "ISO8859-11", "TIS-620",
"Windows-874", "CP874", "ISO8859-13", "Windows-1257", "CP1257","ISO8859-14", "ISO8859-15", "ISO8859-16",
"CP878", "SJIS", "Windows-31J", "CP932", "csWindows31J", "MacJapanese", "MacJapan","ASCII", "ANSI_X3.4-1968",
"646", "UTF-7", "CP65000", "CP65001", "UTF8-MAC", "UTF-8-MAC", "UTF-8-HFS", "UCS-2BE", "UCS-4BE","UCS-4LE",
"CP1251", "UTF8-DoCoMo", "SJIS-DoCoMo", "UTF8-KDDI", "SJIS-KDDI", "ISO-2022-JP-KDDI",
"stateless-ISO-2022-JP-KDDI","UTF8-SoftBank", "SJIS-SoftBank", "locale", "external", "filesystem", "internal"]
</code></p>

<p>``` ruby Encoding.aliases</p>

<pre><code>Encoding.aliases
</code></pre>

<p> => {"BINARY"=>"ASCII-8BIT", "CP437"=>"IBM437", "CP737"=>"IBM737", "CP775"=>"IBM775", "IBM850"=>"CP850",
  "CP857"=>"IBM857", "CP860"=>"IBM860", "CP861"=>"IBM861", "CP862"=>"IBM862", "CP863"=>"IBM863",
  "CP864"=>"IBM864", "CP865"=>"IBM865", "CP866"=>"IBM866", "CP869"=>"IBM869", "CP1258"=>"Windows-1258",
  "CP950"=>"Big5", "CP951"=>"Big5-HKSCS", "eucJP"=>"EUC-JP", "euc-jp-ms"=>"eucJP-ms", "eucKR"=>"EUC-KR",
  "eucTW"=>"EUC-TW", "EUC-CN"=>"GB2312", "eucCN"=>"GB2312", "CP936"=>"GBK", "ISO2022-JP"=>"ISO-2022-JP",
  "ISO2022-JP2"=>"ISO-2022-JP-2", "ISO8859-1"=>"ISO-8859-1", "CP1252"=>"Windows-1252", "ISO8859-2"=>"ISO-8859-2",
  "CP1250"=>"Windows-1250", "ISO8859-3"=>"ISO-8859-3", "ISO8859-4"=>"ISO-8859-4", "ISO8859-5"=>"ISO-8859-5",
  "ISO8859-6"=>"ISO-8859-6", "CP1256"=>"Windows-1256", "ISO8859-7"=>"ISO-8859-7", "CP1253"=>"Windows-1253",
  "ISO8859-8"=>"ISO-8859-8", "CP1255"=>"Windows-1255", "ISO8859-9"=>"ISO-8859-9", "CP1254"=>"Windows-1254",
  "ISO8859-10"=>"ISO-8859-10", "ISO8859-11"=>"ISO-8859-11", "CP874"=>"Windows-874", "ISO8859-13"=>"ISO-8859-13",
  "CP1257"=>"Windows-1257", "ISO8859-14"=>"ISO-8859-14", "ISO8859-15"=>"ISO-8859-15", "ISO8859-16"=>"ISO-8859-16",
  "CP878"=>"KOI8-R", "SJIS"=>"Shift_JIS", "CP932"=>"Windows-31J", "csWindows31J"=>"Windows-31J",
  "MacJapan"=>"MacJapanese", "ASCII"=>"US-ASCII", "ANSI_X3.4-1968"=>"US-ASCII", "646"=>"US-ASCII",
  "CP65000"=>"UTF-7", "CP65001"=>"UTF-8", "UTF-8-MAC"=>"UTF8-MAC", "UTF-8-HFS"=>"UTF8-MAC",
  "UCS-2BE"=>"UTF-16BE", "UCS-4BE"=>"UTF-32BE", "UCS-4LE"=>"UTF-32LE", "CP1251"=>"Windows-1251",
  "locale"=>"UTF-8", "external"=>"UTF-8", "filesystem"=>"UTF-8"}
```</p>

<p>Use Encoding.default_external e Encoding.default_internal para obter os objetos de codificação que representam os padrões externos e internos de codificação padrão. Para obter a codificação para o local atual, chame Encoding.locale_charmap e passar a seqüência resultante para Encoding.find.</p>


<p><code>ruby Encoding.default_external
Encoding.default_external
 =&gt; #&lt;Encoding:UTF-8&gt;
</code></p>

<p><code>ruby Encoding.default_internal
Encoding.default_internal
 =&gt; nil
</code></p>

<p><code>ruby Encoding.locale_charmap
Encoding.locale_charmap
 =&gt; "UTF-8"
</code></p>

<p>A maioria dos métodos que esperam um objeto Encoding também aceitará um nome de codificação maiúsculas e minúsculas (como ascii, binário, UTF-8, EUC-JP, ou sjis) no lugar de um objeto de codificação.</p>


<p>É isso ai... até a proxima... :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Caracteres multibyte no Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/04/25/caracteres-multibyte-no-ruby-1-dot-9/"/>
    <updated>2012-04-25T22:27:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/04/25/caracteres-multibyte-no-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>A classe String foi reescrita no Ruby 1.9 para estar ciente e para
lidar corretamente com caracteres multibyte. Embora o apoio de vários bytes é
a maior mudança no Ruby 1,9, não é uma mudança altamente visível:
código que usa string multibyte simplesmente funciona. Vale a pena
entender por que ele funciona, no entanto, e esta seção explica o
detalhes.</p>




<p>Se uma string contém caracteres de vários bytes, então o número de
bytes não corresponde ao número de caracteres. No Ruby 1.9,
o comprimento ea
métodos tamanho retornar o número de
caracteres em uma seqüência, eo método novo tamanho byte
retorna o número de bytes. [] E [] = operadores permitem consultar e definir
os caracteres de uma string, e os novos métodos e getByte setbyte permitem que você
para consultar e definir bytes individuais (embora você não deve muitas vezes precisam
para fazer isso):</p>


<p>``` ruby Encode</p>

<h1>- * - Coding: utf-8 - * - # Especifique Unicode UTF-8 caracteres</h1>

<h1>Esta é uma string literal contendo uma personagem multiplicação multibyte</h1>

<p>s = "2 × 2 = 4"</p>

<h1>A seqüência contém 6 bytes que codificam 5 caracteres</h1>

<p>s.bytesize # => 6
s.bytesize.times {|i| puts s.getbyte(i), ""} # Mostra "50 195 151 50 61 52"
s.length # => 5
s.length.times {|i| print s[i], ""} # imprime "2 × 2 = 4"
s.setbyte(5, s.getbyte(5) +1); # s é agora "2 × 2 = 5"
```</p>

<p>Note-se que a primeira linha deste código é um comentário de codificação que define a codificação de origem (consulte Especificando Encoding Program) para UTF-8. Sem este comentário, o Ruby intérprete não saberia como decodificar a seqüência de bytes
na seqüência literal em uma seqüência de caracteres.</p>




<p>Quando uma string contém caracteres codificados com números variados
de bytes, já não é possível mapear diretamente do personagem
índice para deslocamento de byte na seqüência. Na seqüência acima, para
exemplo, o segundo carácter começa no segundo byte. Mas o
terceiro personagem começa no quarto byte. Isto significa que você
não pode assumir que o acesso aleatório a caracteres arbitrários dentro de um
string é uma operação rápida. Quando você usa o operador [], como
fizemos no código acima, para acessar um caractere ou substring dentro
uma string multibyte, a implementação de Ruby deve internamente iterar
sequencialmente na cadeia para encontrar o índice do caractere desejado.
Em geral, portanto, você deve tentar fazer o seu processamento de cadeia
utilizando algoritmos seqüenciais, quando possível. Ou seja: usar o iterator each_char quando possível, em vez
de chamadas repetidas para o []
operador. Por outro lado, não é geralmente necessário se preocupar
muito sobre isso. Implementações Ruby otimizar os casos que
pode ser otimizado, e se uma string é composta inteiramente de 1 byte
personagens, o acesso aleatório a esses personagens vão ser eficiente. Se
você quiser tentar suas próprias otimizações, você pode usar a instância
método ascii_only? para determinar
se uma seqüência consiste inteiramente de 7-bit ASCII.</p>




<p>A classe String no Ruby 1.9
define uma codificação
método que retorna a codificação de uma string (o retorno
valor é um objeto de codificação,
o qual é descrito em baixo):</p>


<p>``` ruby</p>

<h1>- * - Coding: utf-8 - * -</h1>

<p>s = "2 × 2 = 4" # caráter multiplicação #  Note multibyte
s.encoding # => &lt;Encoding: UTF-8>
```</p>

<p>A codificação de strings é sempre o mesmo que o
codificação de origem do arquivo, exceto que os literais que contêm
Escapes \u sempre são codificados em
UTF-8, independentemente da fonte de codificação.</p>




<p>Determinadas operações de corda, tais como concatenação e padrão
correspondência, exigem que duas strings (ou uma corda e um regular
expressão) possuem uma codificação compatíveis. Se você concatenar um ASCII
string com uma string UTF-8, por exemplo, obter uma string UTF-8.
Não é possível, no entanto, para concatenar uma string UTF-8 e um
SJIS string: as codificações não são compatíveis, e uma exceção será
ser levantada. Você pode testar se duas strings (ou uma corda e um
expressão regular) possuem uma codificação compatíveis usando a classe
método Encoding.compatible?.
Se as codificações dos dois argumentos são compatíveis,
retorna a uma que é o superconjunto do outro. Se o
codificações são incompatíveis, ela retorna nil.</p>




<p>Você pode definir explicitamente a codificação de uma string com force_encoding. Isso é útil se você tiver
uma seqüência de bytes (leia-se de um fluxo de I / O, talvez) e quer
dizer Ruby como eles devem ser interpretados como caracteres. Ou, se você
ter uma seqüência de caracteres de vários bytes, mas você deseja indexar
bytes individuais com []:</p>


<p><code>ruby
text = stream.readline.force_encoding("utf-8")
bytes = text.dup.force_encoding("binário")
</code></p>

<p>
<b>force_encoding</b>
não fazer uma cópia de seu receptor, que modifica o
codificação da string e retorna a string. Este método não
que qualquer caractere conversão dos bytes subjacentes da cadeia são
não mudou, apenas a interpretação de Ruby deles é alterado. O
argumento para force_encoding pode ser
o nome de uma codificação ou um objeto de codificação.
</p>




<p>O force_encoding não faz validação, mas não verifica se os bytes subjacentes do
cadeia de representar uma seqüência válida de caracteres especificada no
de codificação. Use valid_encoding? para
executar a validação. Este método de instância não tem argumentos e verifica se
os bytes de uma cadeia pode ser interpretada como uma seqüência válida de
caracteres usando codificação da seqüência:</p>


<p><code>ruby
s = "\xa4".force_encoding ("utf-8") # Este não é um UTF-8 válido cadeia
s.valid_encoding? # =&gt; False
</code></p>

<p>O método de codificar de uma string é bastante
diferente da force_encoding. Ele retorna uma string que representa a mesma seqüência de caracteres como
seu receptor, mas usando uma codificação diferente. A fim de alterar o
codificação de ou-transcodificar uma string como esta,
o método de codificar deve alterar o
bytes subjacentes que compõem a cadeia. Aqui está um exemplo:
</p>


<p>``` ruby</p>

<h1>- * - Coding: utf-8 - * -</h1>

<p>EURO1 = "\u20AC" # Comece com o personagem Euro Unicode
puts EURO1 # Imprime "€"
euro1.encoding # => &lt;Encoding:UTF-8>
euro1.bytesize # => 3</p>

<p>euro2 = euro1.encode ("iso-8859-15") # transcode para a América-15
puts euro2.inspect # Imprime "\xA4"
euro2.encoding # => &lt;Encoding:iso-8859-15>
euro2.bytesize # => 1</p>

<p>euro3 = euro2.encode ("utf-8") # transcode de volta para UTF-8
EURO1 == euro3 # => true
```</p>

<p>Note que você não deve muitas vezes precisa usar o método de codificação. O tempo mais comum para
transcode cordas é antes de escrevê-las em um arquivo ou enviá-los
através de uma conexão de rede. E, como veremos em Streams e codificações, classes Ruby I/O, apoiar o
transcodificação automática de texto quando ele é gravado.</p>




<p>Se a seqüência que você está chamando de codificar consiste de bytes não codificados, vocês
precisa especificar a codificação, que para interpretar esses bytes
antes de transcodificação-los para outra codificação. Faça isso passando dois
argumentos para codificar. O primeiro
argumento é a codificação desejada, eo segundo argumento é o
codificação atual da cadeia. Por exemplo:</p>


<p>``` ruby</p>

<h1>Interpretar um byte como um codepoint iso-8859-15, e transcodificar para UTF-8</h1>

<p>byte = "\xA4"
char = byte.encode("utf-8", "iso-8859-15")
```</p>

<p>Isto é, as duas seguintes linhas de código tem o mesmo efeito:</p>


<p><code>ruby
text = bytes.encode(to, from)
text = bytes.dup.force_encoding(from).encode(to)
</code></p>

<p>Se você ligar para codificar sem
argumentos, ele transcodifica seu receptor para o padrão interno
codificação, caso tenha sido definido com o E-ou-U opções intérprete (ver Opções de codificação). Isso permite que os módulos de biblioteca (por
exemplo) para transcodificar suas constantes de cadeias públicas para um comum
codifica para a interoperabilidade.</p>




<p>Codificações de caracteres diferentes não só no seu mapeamento de
bytes para caracteres, mas no conjunto de caracteres que podem
representam. Unicode (também conhecido como UCS-o Universal Character Set) tenta
permitir que todos os personagens, mas codificações de caracteres não baseadas em Unicode
só pode representar um subconjunto de caracteres. Não é possível,
portanto, para transcodificar todos os UTF-8 cordas para EUC-JP (por exemplo);
Caracteres Unicode que não são nem latim, nem japonês não pode ser
traduzida.</p>




<p>Se a codificar ou codificar! método encontra um personagem que não pode transcodificar, ele gera uma exceção:</p>


<p><code>ruby
"\U20AC".Encode("iso-8859-1") # Nenhum sinal de euros em Latin-1, para levantar exceção
</code></p>

<p>codificar e codificar! aceitar um hash de transcodificação
opções como seu argumento final. No momento da redação deste texto, o
Nome de opção só é definido: inválido, eo único valor definido para
essa chave é :ignore. "ri
String.encode "dará mais detalhes quando as opções são mais
implementadas.
</p>

]]></content>
  </entry>
  
</feed>
