<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-05-19T14:05:22-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part II]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-ii/"/>
    <updated>2012-05-19T13:14:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-ii</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Identidade do objeto</h3>


<p>Cada objeto tem um identificador de objeto, um Fixnum, que você pode obter com o método object_id. O valor retornado por este
método é constante e exclusivo para a vida útil do objeto. Enquanto o objeto é acessível, ele terá sempre a mesma identificação, e não
outro objeto que irá partilhar do mesmo ID.</p>

<p>O ID de método é um sinônimo preterido para object_id. Ruby 1.8 emite um aviso se você usá-lo, e ele foi removido em
Ruby 1.9.</p>

<p><strong>id</strong> é um sinônimo válido para object_id. Ele existe como um retorno, assim você pode acessar ID de um objeto, mesmo se o método
object_id foi indefinido ou substituído.</p>

<p>A classe <a href="http://ruby-doc.org/core-1.9.3/Object.html">Object</a> implementa o método de hash para simplesmente retornar um
ID objeto.</p>

<!--more-->




<h3>Classe de Objeto e Tipo de Objeto</h3>


<p>Existem várias maneiras de determinar a classe de um objeto em Ruby. O mais simples é simplesmente perguntar para ele:</p>

<p><code>ruby Class
o = "teste" # Este é um valor
o.class # Retorna um objeto que representa a classe String
</code></p>

<p>Se você estiver interessado na hierarquia de classe de um objeto, você pode perguntar para qualquer classe qual é sua superclasse:</p>

<p><code>ruby Class - Ruby 1.8
o.class # String: o é um objeto String
o.class.superclass # Object: superclasse de String é objeto
o.class.superclass.superclass # nil: Object não tem superclasse
</code></p>

<p>No Ruby 1.9, Object já não é a verdadeira raiz da hierarquia de classes:</p>

<p>``` ruby Class - Ruby 1.9</p>

<h1>Ruby 1.9</h1>

<p>Object.superclass # BasicObject: Object tem uma superclasse em 1.9
BasicObject.superclass # nil: BasicObject não tem nenhuma superclasse
```</p>

<p>Assim, uma forma particularmente simples para verificar a classe de um objeto é, por comparação direta:</p>

<p><code>ruby Class
o.class == String # true se o é uma String
</code></p>

<p>O método instance_of? faz a mesma coisa e é um pouco mais elegante:</p>

<p><code>ruby Class
o.instance_of? String # verdade se o é uma String
</code></p>

<p>Normalmente, quando testamos a classe de um objeto, também gostaríamos saber se o objeto é uma instância de qualquer subclasse
dessa classe. Para testar isso, use o método is_a?, ou seu sinônimo kind_of?</p>

<p><code>ruby Class
x = 1 # Este é o valor que estamos trabalhando com
x.instance_of? Fixnum # verdade: é uma instância de Fixnum
x.instance_of? Numeric # false: instance_of? não verifica a herança
x.is_a? Fixnum # verdadeiro: x é um Fixnum
x.is_a? Integer # verdade: x é um número inteiro
x.is_a? Numeric # verdade: x é um numérico
x.is_a? Comparable # verdade: funciona também com módulos mixin
x.is_a? Object # verdadeira para qualquer valor de x
</code></p>

<p>A classe Class define o operador === em tal modo que ele pode ser usado no lugar do is_a?:</p>

<p><code>ruby Class method ===
Numeric === x # verdade: x is_a Numérico
</code></p>

<p>Essa expressão é exclusivo para Ruby e é, provavelmente, menos legível do que utilizando o mais tradicional método is_a?.</p>

<p>Cada objeto tem uma classe bem definida em Ruby, e que a classe nunca muda durante a vida útil do objeto. Um objeto
type, por outro lado, é mais fluido. O tipo de um objeto está relacionada à sua classe, mas a classe é apenas parte de um
tipo de objeto. Quando falamos sobre o tipo de um objeto, nós entendemos o conjunto de comportamentos que caracterizam o objeto.
Outra maneira é colocar o tipo de um objeto em um conjunto de métodos que podem responder.
(Esta definição torna-se recursiva, porque não é apenas o nome dos métodos que importam, mas também os tipos de argumentos que os
métodos podem aceitar.)</p>

<p>Na programação com Ruby, que muitas vezes não se preocupam com a classe de um objeto, nós só queremos saber se podemos invocar
algum método nele.  Considere-se, por exemplo, o operador &lt;&lt;. Arrays, strings, files e outros I/O relacionados ao definir as classes
isso como um operador de acréscimo. Se estamos escrevendo um método que produz produção textual, podemos escrever, genericamente,
a usar esse operador. Então, o nosso método pode ser invocado com qualquer argumento que implementa &lt;&lt;. Nós não nos importamos com a
classe do argumento, basta que possamos anexá-lo. Nós podemos testar para isto com o método respond_to? :</p>

<p><code>ruby Class respond_to?
o.respond_to? :"&lt;&lt;" # Verdadeiro se o operador tem uma &lt;&lt;
</code></p>

<p>A deficiência desta abordagem é que ela só verifica o nome de um método, não os argumentos para esse método. Por exemplo,
Fixnum e Bignum implementam &lt;&lt; como um operador de deslocamento à esquerda e espera o argumento de ser um número em vez de uma string.
Objetos inteiros parecem ser "appendable" (adicionável) quando usamos um respond_to? de teste, mas que produzem um erro quando
adiciona um código em string. Não há uma solução geral para este problema, mas um recurso ad-hoc, neste caso,
é explicitamente excluir objectos numéricos com o método is_a? :</p>

<p><code>ruby Class
o.respond_to? :"&lt;&lt;" and not o.is_a? Numeric
</code></p>

<p>Outro exemplo do tipo distinção-versus-classe é a classe StringIO<a href="partir%20da%20Biblioteca%20padrão%20do%20Ruby">*</a>. StringIO permite a
leitura e gravação das strings como se fossem Objetos de IO. StringIO[*] imita os objetos IO API-StringIO definem os mesmos métodos
que os objetos IO fazem. Mas StringIO não é uma subclasse de IO. Se você escrever um método que espera um argumento de fluxo,
e testa a classe do argumento com is_a? IO, em seguida, o método não funciona com argumentos StringIO.</p>

<p>[*] -> <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/stringio/rdoc/StringIO.html">StringIO</a></p>

<p>É isso ai rubistas... A cada vez que leio sobre, me apaixono mais. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part I]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2/"/>
    <updated>2012-05-19T10:23:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>


<p>Ruby é uma forma muito pura de linguagem orientada a objetos: todos os valores são
objetos, e não há distinção entre tipos primitivos e tipos de objetos, como existem em muitos
outras línguas. Em Ruby, todos os objetos herdam de uma classe chamada
<a href="http://ruby-doc.org/core-1.9.3/Object.html">Object</a> e compartilhar os métodos definidos
por essa classe. Esta seção explica as características comuns de todos os objetos
em Ruby. Teremos algumas partes para falar desta classe tão poderosa, mas é muito importante para o entendimento de OO em Ruby.</p>

<!--more-->


<h3>Referências de objeto</h3>


<p>Quando trabalhamos com objetos em Ruby, realmente estamos trabalhando com referências a objetos. Não é o
próprio objeto que manipula, mas uma referência a ele<a href="/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2/#referencia">[*]</a>.
Quando atribuir um valor a uma variável, não estamos copiando um objeto "em" variável que, nós
São apenas armazenar uma referência a um objeto para essa variável. Alguns
código deixa isso claro:</p>

<p><code>ruby Objects
s = "Ruby" # Criar um objeto String. Armazenar uma referência a ele em s.
t = s # Copiar a referência a t. s e t referem-se ambos para o mesmo objeto.
t[-1] = "" # Modificar o objeto através da referência t.
print s # Acesse o objeto modificado através de s. Prints "Esfregue".
t = "Java" # t agora se refere a um objeto diferente.
print s, t # Imprime "RubJava".
</code></p>

<p>Quando você passar um objeto para um método em Ruby, é um objeto
referência que é passado para o método. Não é o objeto em si,
e não é uma referência para a referência ao objecto. Outra forma
dizer isso é que os argumentos do método são passados ​​por
valor e não por referência, mas
que os valores passados ​​são referências de objeto.</p>

<p>Porque as referências de objeto são passados ​​para os métodos, os métodos podem usar
essas referências para modificar o objeto subjacente. Essas modificações
são, então, visível quando o método retorna.</p>

<h3>Valores imediatos</h3>


<p>Nós dissemos que todos os valores em Ruby são objetos e todos os objetos
são manipulados por referência. Na implementação de referência, no entanto objetos Fixnum e Symbol são realmente "valores imediatos",
em vez de referências. Nenhuma destas duas classes tem métodos diferenciados, de modo que os
Objetos Fixnum e símbolo são imutáveis, o que significa que não há realmente nenhuma maneira de dizer que eles são manipulados por
valor, e não pela existência de valores de referencia.</p>

<p>A existência de valores imediatos deve ser considerado um detalhe de implementação. A única diferença prática entre
valores imediatos e valores de referência é que os valores imediatos
não pode ter métodos singleton definidas sobre eles.</p>

<h3>Vida útil de objeto</h3>


<p>As classes internas em Ruby descritas neste capítulo têm sintaxes literal e instâncias dessas classes são criadas simplesmente por
inclusão de valores literalmente em seu código. Objetos de outras classes precisam ser explicitamente criados,
e isso é feito na maioria das vezes com um método chamado de new:</p>

<p><code>ruby Class.new
myObject = MyClass.New
</code></p>

<p>new é um método do Classe Class. Atribui na memória para manter o objeto new, então ele inicializa o estado do
recém alocados objetos "vazio", invocando seu método initialize. Os argumentos para new são passadas diretamente para inicializar.
A maioria das classes definem um método initialize para executar qualquer inicialização, sendo necessário para instâncias.</p>

<p>Os métodos new e initialize fornecer o padrão técnico para a criação de novas classes, mas classes também podem definir outros
métodos, conhecidos como "métodos de fábrica", que retornam instâncias.</p>

<p>Objetos Ruby não precisa ser desalocada explicitamente, como o fazem as linguagens C, C++, entre outras. Ruby usa uma técnica chamada
<a href="http://www.rubyinside.com.br/como-o-ruby-gerencia-memoria-e-faz-garbage-collection-3018">garbage collection</a> (coleta de lixo) automaticamente, para destruir objetos que não são mais necessários. Um objeto se torna um candidato para o garbage collection quando é
inacessível, quando não há referências restantes para o objeto com exceção de outros objetos inacessíveis.</p>

<p>O fato de que Ruby usa garbage collection, isso significa que programas em Ruby são menos suscetíveis a vazamentos de memória
que os programas escritos em linguagems que requerem objetos e memória para ser desalocada explicitamente e liberado.
Mas o garbage collection não significa que vazamentos de memória são impossíveis:
qualquer código que cria vida longa tem referências a objetos que de outro modo seria de curta duração pode ser uma fonte de
falhas de memória. Considere um hash usado como um cache. Se o cache não é podado usando algum tipo de algoritmo
menos utilizado recentemente, os objetos em cache permanecem acessíveis enquanto o hash em si é alcançável. Se o hash
é referenciado por uma variável global, então será acessível como desde que o interpretador Ruby está sendo executado.</p>

<p><a href="referencia"></a></p>

<pre><code>[*] -&gt; Se você está familiarizado com C ou C++, você pode pensar de uma
referência como um ponteiro: o endereço do objeto na memória. Ruby
não utiliza ponteiros, no entanto. Referências em Ruby são opacas e
internas para a implementação. Não há maneira de tirar o
tratamento de um valor não referenciado, um valor, ou fazer ponteiro aritmético.
</code></pre>

<p>Um pouco de conceito de Objetos, logo teremos mais na pratica...</p>

<p>Até a proxima</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[True, False e Nil]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/18/true/"/>
    <updated>2012-05-18T12:58:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/18/true</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de True, False e Nil, é hora de nos aprofundar.</p>




<h2>True, False e Nil</h2>


<p>Ruby tem alguma das palavras-chave, as palavras: True, False e nil(nulo). True e False são os dois valores booleanos, e eles
representar a verdade e a falsidade, sim e não, ligado e desligado, de um objeto. nil é um valor especial reservado para indicar
a ausência de valor.</p>

<p>Cada uma dessas palavras-chave avaliada como um objeto especial. True avalia a um objeto que é uma instância de <a href="http://ruby-doc.org/stdlib-1.9.2/libdoc/singleton/rdoc/Singleton.html">Singleton</a> de TrueClass. Da mesma forma, False e nil são exemplos de FalseClass e NilClass. Note que não há nenhuma classe Boolean em Ruby. TrueClass e False Class ambos têm como objeto de sua superclasse.</p>

<p>Se você quiser verificar se um valor é nulo, você pode simplesmente compará-lo a nil, ou usar o método nil?</p>

<p><code>ruby NilClass
o == nil # o é nil
o.nil? # Outra maneira de testar
</code></p>

<p>Note que True, False e nil se referem a objetos, e não números. False e nil não são a mesma coisa que 0, e True
não é a mesma coisa que 1. Quando o Ruby exige um valor booleano, nil se comporta como False e qualquer valor diferente de
nil ou False se comporta como True.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Symbols - Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/16/symbols-ruby-1-dot-9-2/"/>
    <updated>2012-05-16T21:37:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/16/symbols-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de Symbol, é hora de nos aprofundar.</p>




<h2>Symbol</h2>


<p>Uma implementação típica de um interpretador Ruby mantém um símbolo em tabela
que ele armazena os nomes de todas as classes, métodos e variáveis ​​que ele conhece.
Isso permite que tal intérprete evite mais comparações de string: refere-se a nomes de métodos (por exemplo) pelo sua
posição na presente tabela de símbolos. Isso transforma uma string relativamente pesada em uma certa operação, e relativamente leve com operação de números inteiro.</p>

<!--more-->


<p>Esses símbolos não são puramente interno para o intérprete, pois eles podem também ser usado por
programas Ruby. Um objeto de Symbol refere-se a um símbolo. Um símbolo literal é escrito prefixando um identificador ou uma string com um
dois pontos:</p>

<p><code>ruby Symbol
:symbol # Symbol Um literal
:"symbol" # O mesmo literal
:'another long symbol' "# são úteis para símbolos com espaços
s = "string"
sym = :"#{s}" # O Symbol :string
</code></p>

<p>Símbolos têm também uma sintaxe literal %s que permite delimitadores arbitrários da mesma maneira
que %q e %Q pode ser usado para strings:</p>

<p><code>ruby Symbol
%s["] # O mesmo que: '"'
</code></p>

<p>Os símbolos são usados ​​frequentemente para se referir a nomes de métodos no reflexivo
código. Por exemplo, suponha que queremos para saber se algum objeto tem um método each:</p>

<p><code>ruby Symbol
o.respond_to? :each
</code></p>

<p>Aqui está outro exemplo. Ele testa se um determinado objeto responde a um método especificado, e, em caso afirmativo, invoca o método:</p>

<p><code>ruby Symbol
nome = :size
if o.respond_to? nome
  o.send (nome)
end
</code></p>

<p>Você pode converter uma String para um Symbol utilizando os métodos intern ou to_sym. E você pode converter um Symbol de volta para uma String com o método to_s ou sue alias id2name:</p>

<p><code>ruby Symbol
str = "string" # Comece com uma string
sym = str.intern  # Converter para um símbolo
sym = str.to_sym # Outra maneira de fazer a mesma coisa
str = sym.to_s # converter de volta para uma string
str = sym.id2name # Outra maneira de fazê-lo
</code></p>

<p>Duas seqüências podem ter o mesmo conteúdo e ainda ser completamente de objetos distintos. Este nunca é o caso com símbolos.
Duas strings com o mesmo conteúdo irá tanto converter para exatamente o mesmo objeto symbol. Dois objetos distintos Symbols terá sempre conteúdo diferente.</p>

<p>Sempre que você escrever código que usa string não para o seu conteúdo textual,
mas como uma espécie de identificador único, considere o uso de symbols em vez disso.
Ao invés de escrever um método que espera um argumento para ser ou a string de "AM" ou "PM", por exemplo, você poderia escrevê-lo para
esperar o símbolo :AM ou o símbolo :PM. Comparando-se dois objetos Symbols de igualdade, é muito mais rápido
de comparar duas strings para a igualdade. Por esta razão, os símbolos são geralmente preferido para strings como chaves de hash.</p>

<p>No Ruby 1.9, a classe símbolo define um número de métodos String, como length, o size, os operadores de comparação, e mesmo os operadores
[] e =~. Isto faz com que os símbolos sejam um pouco permutável com string e permite a sua utilização como uma espécie de imutável
(E não garbage-collected) string.</p>

<p>É isso ai amigos até a proxima.. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testando Associações em Range - Part II]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/15/testando-associacoes-em-range/"/>
    <updated>2012-05-15T21:49:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/15/testando-associacoes-em-range</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de Range, é hora de nos aprofundar.</p>




<h2>Teste Associação em um intervalo</h2>


<p>A classe Range define métodos para determinar se um valor arbitrário é um membro de (isto é, está incluído no) um Range. Antes de entrar em
detalhes sobre estes métodos, é necessário explicar que associaçãoem range pode ser definido de duas maneiras diferentes que estão relacionadas com a diferença entre os intervalos contínuos e discretos. Um valor x é um membro do range entre begin..end pela primeira definição se:</p>

<p><code>ruby Range
begin &lt;= x &lt;= end
</code></p>

<!--more-->


<p>E X é um membro do range begin...end (com três pontos), se:</p>

<p><code>ruby Range
begin &lt;= x &lt; end
</code></p>

<p>Todos os valores de ponto de extremidade deve implementar o operador &lt;=>, assim que esta definição de associação funciona para qualquer objeto Range e não requer um ponto final para implementar o método succ. Esse é o teste de associação contínua.</p>

<p>A segunda definição de filiação discreta independe succ. Ele trata um intervalo begin..end como um conjunto que inclui begin, begin.succ, begin.succ.succ, e assim por diante. Por esta definição, a associação do Range é ajustada a associação, e um valor de x está incluído numa range apenas se for um valor retornado por uma das invocações de succ. Observe que os testes de associação discreta é potencialmente
uma operação muito mais cara do que os testes de associação contínua.</p>

<p>Com isso de fundo, podemos descrever os métodos de distribuição para testar a associação. Ruby 1.8 suporta dois métodos, include?
e member?. Eles são sinônimos, e ambos usam a associação contínua, teste:</p>

<p><code>ruby Range
r = 0...100 # O intervalo de números inteiros de 0 a 99
r.member? 50 # =&gt; verdadeira: 50 é um membro da range
r.include? 100 # =&gt; falso: 100 está excluída a partir do intervalo
r.include? 99.9 # =&gt; verdadeira: 99,9 é inferior a 100
</code></p>

<p>A situação é diferente no Ruby 1.9. Essa versão da linguagem introduz um novo método, cover?, que
funciona como include? e member? do Ruby 1.8, ele sempre usa o teste de associação contínua.
include? e member? ainda são sinônimos no Ruby 1.9. Se os pontos finais do intervalo são números, estes métodos utilizam o
teste de associação contínua, assim como eles fizeram no Ruby 1.8. Se os desfechos não são numéricas, no entanto, eles ao invés de
usar o teste de associação discreta. Podemos ilustrar estas mudanças com um Range discreto de Srintgs (você pode querer usar ri entender como String.succ funciona):</p>

<p>``` ruby ri String.succ
= String.succ</p>

<h2>(from ruby site)</h2>

<p>  str.succ   -> new_str
  str.next   -> new_str</p>

<hr />

<p>Returns the successor to str. The successor is calculated by
incrementing characters starting from the rightmost alphanumeric (or the
rightmost character if there are no alphanumerics) in the string. Incrementing
a digit always results in another digit, and incrementing a letter results in
another letter of the same case. Incrementing nonalphanumerics uses the
underlying character set's collating sequence.</p>

<p>If the increment generates a ``carry,'' the character to the left of it is
incremented. This process repeats until there is no carry, adding an
additional character if necessary.</p>

<p>  "abcd".succ        #=> "abce"
  "THX1138".succ     #=> "THX1139"
  "&lt;<koala>>".succ   #=> "&lt;<koalb>>"
  "1999zzz".succ     #=> "2000aaa"
  "ZZZ9999".succ     #=> "AAAA0000"
  "<strong>*".succ         #=> "</strong>+"</p>

<p>(END)
```</p>

<p><code>ruby Range
triplica = "AAA".."ZZZ"
triplica.include? "ABC" # verdade, rápido em 1.8 e lento em 1.9
triplica.include? "ABCD" # verdadeira em 1.8, false em 1.9
triplica.cover? "ABCD" # verdadeiro e rápido em 1.9
triplica.to_a.include? "ABCD" # false e lento em 1.8 e 1.9
</code></p>

<p>Na prática, a maioria dos Ranges têm pontos de extremidade numéricos, e o Range de mudanças na API entre Ruby 1.8
e 1.9 têm pouco impacto.</p>

<p>É isso ai, até a proxima... :D</p>

<p>E bons estudos..</p>
]]></content>
  </entry>
  
</feed>
