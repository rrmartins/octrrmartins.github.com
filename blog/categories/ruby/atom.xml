<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-05-10T13:29:34-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte III - Hashs Codes]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/10/o-mundo-hash-no-ruby-1-dot-9-2-parte-iii-hashs-codes/"/>
    <updated>2012-05-10T13:01:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/10/o-mundo-hash-no-ruby-1-dot-9-2-parte-iii-hashs-codes</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Hoje vamos falar um pouco mais de Hash, é hora de nos aprofundar.</p>




<h3>Códigos de Hash, Igualdade e mutáveis ​​Chaves</h3>


<p>Hashs[1] de Ruby são implementadas, sem surpresa, com um conjunto de dados de
estrutura conhecida como uma tabela hash. Objetos usados como chaves em um hash deve ter um método chamado de hash que retorna <a href="http://www.ruby-doc.org/core-1.9.2/Fixnum.html">Fixnum</a> hashcode para a chave. Se duas chaves são iguais, elas devem ter o mesmo
hashcode. Chaves desiguais também pode ter a mesma hashcode, mas hash's de tabelas são mais eficientes quando hashcodes duplicados são raros.</p>

<p>A classe Hash compara chaves igualdade com o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-eql-3F">eql?</a>. Para
outras classes Ruby, eql? obras como o operador == . Se você definir uma nova classe que
substitui o método eql?, você deve também substituir o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-hash">hash</a>, ou se não as instâncias de sua classe não vam funcionar como chaves em um hash.</p>

<p>Se você definir uma classe e não sobreescrever o método eql?, em seguida, as instâncias dessa classe são
comparadas com a identidade do objeto quando usado como chave de hash. Duas instâncias distintas de sua classe são distintas chaves de hash mesmo que eles representam o mesmo conteúdo. Neste caso, o método padrão hash é apropriado: retorna a única object_id do objeto.</p>

<p>Note-se que objetos mutáveis ​​são problemáticos como chaves de hash. Mudar o conteúdo de um objeto geralmente muda seu hashcode. Se você usar um objeto como uma chave e então alterar esse objeto, a tabela de hash ficará corrompida, e o hash não funciona corretamente.</p>

<p>Porque strings são mutáveis, mas comumente usamos chaves de hash, Ruby trata eles como um caso especial e faz cópias privadas de todas as cadeias utilizadas como chaves. Este é o único caso especial, no entanto, você deve ser muito cuidado ao usar qualquer outro objeto mutável como uma chave hash. Considera fazendo uma cópia privada ou chamando o método <a href="http://ruby-doc.org/core-1.9.2/Object.html#method-i-freeze">freeze</a>.
Se você deve usar chaves de hash mutável, chame o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-rehash">rehash</a> do Hash cada vez que você alterar uma chave.</p>

<p>-> <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html">Hash</a></p>

<p>Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte II - Hashs Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2-parte-ii-hashs-literais/"/>
    <updated>2012-05-08T22:28:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2-parte-ii-hashs-literais</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Na primeira parte eu fiz uma introdução do Hash:
-> <a href="/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2/">O Mundo Hash no Ruby 1.9.2 - Parte I</a></p>

<p>Vamos lá!</p>

<p>Um literal de hash é escrita como uma lista separada por vírgulas de chave/valor de
pares, colocados dentro de chaves. Chaves e valores são separados
com um caractere de dois "arrow": '=>'. O objeto Hash criado anteriormente também pode ser
criado com o literal seguinte:</p>

<!--more-->


<p><code>ruby Hash Literal
números = {"um" =&gt; 1, "dois" =&gt; 2, "três" =&gt; 3}
</code></p>

<p>Em geral, objetos <a href="http://www.ruby-doc.org/core-1.9.2/Symbol.html">Símbolos</a> trabalham mais eficientemente como chaves de hash de strings, fazem assim:</p>

<p><code>ruby Hash Literal
números = {:um =&gt; 1,:dois =&gt; 2,:três =&gt; 3}
</code></p>

<p>Os <a href="http://www.ruby-doc.org/core-1.9.2/Symbol.html">Símbolos</a> são imutáveis, escrito como
prefixados identificadores, que serão explicados em maior detalhe em um outro post.</p>

<p>Ruby 1.8 permite vírgulas em lugar de setas, mas isso não teve a sintaxe substituída, mais suportado no Ruby 1.9:</p>

<p><code>ruby Hash Literal
 numeros = {:um, 1, :dois, 2, :tres, 3} # Igual, mas mais difícil de ler
</code></p>

<p>Tanto Ruby 1.8 quanto no Ruby 1.9 permite uma única vírgula à direita do
final da lista de chave / valor:</p>

<p><code>ruby Hash Literal
números = {: um =&gt; 1,: dois =&gt; 2} # vírgula extra ignorado
</code></p>

<p>Ruby 1.9 suporta muito útil e sucinto a sintaxe literal de Hash
quando as chaves são símbolos. Neste caso, move-se para o fim da chave de hash e substitui a seta:</p>

<p><code>ruby Hash Literal
números = {um: 1, dois: 2, tres: 3}
</code></p>

<p>Note-se que pode não haver qualquer espaço entre a chave Hash
identificador e dos dois pontos.</p>

<p>Até breve!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte I]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2/"/>
    <updated>2012-05-08T21:27:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Um hash é uma estrutura de dados que mantém um conjunto de objetos conhecidos
como chaves, e associa um valor com cada chave. Hashs são também conhecidos como mapas porque mapeam as chaves para
valores. Eles às vezes são chamados de matrizes associativas, porque eles
associam valores com cada uma das chaves, e pode ser pensado como matrizes
em que o índice da matriz pode ser qualquer objeto em vez de um inteiro. um
exemplo torna isso mais claro:</p>

<p>```ruby Hash</p>

<h1>Este hash irá mapear os nomes dos dígitos para os dígitos se</h1>

<p>números = Hash.new # Criar um novo objeto, vazio de hash
números["um"] = 1 # Mapa do String "um" para o Fixnum 1
números["dois"] = 2 # Note que estamos usando a notação de matriz aqui
números["três"] = 3</p>

<p>soma = números["um"] + números["dois"] # soma os valores e resulta em "3"
```</p>

<p>Esta introdução à sintaxe hashes de hash documentos Ruby literal
e explica os requisitos para um objeto a ser usado como uma chave hash.
Mais informações sobre a API definida pela classe Hash é fornecido em <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html">Hashes</a>.</p>

<p>Em breve, mais conteudo de Hash!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Um pouco de Array no Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/07/um-pouco-de-array-no-ruby/"/>
    <updated>2012-05-07T13:02:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/07/um-pouco-de-array-no-ruby</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Um Array é uma seqüência de valores que permite que os valores serem acessados ​​por sua posição, ou índice, na seqüência. Em Ruby, o primeiro valor em um array tem índice 0. Os métodos size e length, retornam o número de elementos em um Array. O último
elemento do Array é no índice de size-1. Valores de índice negativo contar a partir do
final do Array, de modo que o último elemento de uma Array também pode ser acessado
com um índice de -1. O segundo ao último tem um índice de -2,
e assim por diante. Se você tentar ler um elemento além do final de uma Array
(Com um index >= size), ou antes
o início de um Array (com um index &lt; size), Ruby simplesmente retorna nil e não lançará uma exceção.</p>

<!--more-->


<p>Arrays de Ruby não são tipados e mutáveis. Os elementos de um Array
não precisam de ser todos da mesma classe, e eles podem ser alterados em qualquer momento.
Além disso, os Arrays são dinamicamente redimensionáveis, você pode acrescentar elementos
a eles e crescer conforme necessário. Se você atribuir um valor a um elemento
além do final do Array, a Array é automaticamente prorrogado com
elementos nil. (É um erro, No entanto, para atribuir um valor para um elemento antes do início de um
Array.)</p>

<p>Uma Array literal é uma lista separada por vírgulas de valores, dentro de
parênteses:</p>

<p><code>ruby Arrays Literal
[1, 2, 3] # Uma Array que contém três objetos Fixnum
[-10 ... 0, 0 .. 10,] # Uma Array de duas faixas; vírgulas extras são permitidos
[[1,2], [3,4], [5]] # Uma Array de Arrayes aninhadas
[X + y, xy, x * y] # array os elementos podem ser expressões arbitrárias
[] # O array vazio tem o tamanho 0
</code></p>

<p>Ruby inclui uma sintaxe especial, no caso para expressar literais de Array
cujos elementos são seqüências curtas sem espaços:</p>

<p><code>ruby Arrays
palavras = %w[este é um teste] # O mesmo que: ['este', 'é', 'um', 'teste']
aberto = %w| ( [ { &lt; | # O mesmo que: ['(', '[', '{', '&lt;']
branco = %W(\s \t \r \n) # O mesmo que: ["\ s", "\ t", "\ r", "\ n"]
</code></p>

<p>%w e %W introduzir uma Array literal, bem como %q e %Q introduzir uma string literal. Em
particular, as regras delimitadores para %w e %W são as mesmos que para %q e %Q. Dentro dos delimitadores, sem aspas
são necessários em torno das cadeias de elementos do array, e sem vírgulas são
requerido entre os elementos. Elementos do Array são delimitados por espaço em branco.</p>

<p>Você também pode criar Arrays com o construtor Array.new, e isso proporciona
opções de programação inicializando os elementos de Array:</p>

<p><code>ruby Initiallize Array
vazio = Array.new # []: retorna um novo array vazio
nils = Array.new(3) # [nil, nil, nil]: nova Array com 3 elementos nulos
zeros = Array.new(4, 0) # [0, 0, 0, 0]: nova Array com 4 elementos 0
cópia = Array.new(nils) # Faça uma nova cópia de uma Array existente
count = Array.new(3) {| i | i +1} # [1,2,3]: 3 elementos calculado a partir do índice
</code></p>

<p>Para obter o valor de um elemento do Array, use um único número inteiro
entre colchetes:</p>

<p><code>ruby Valores com Array
a = [0, 1, 4, 9, 16] # O Array mantém os quadrados dos índices
a[0] # primeiro elemento é 0
a[-1] # O ultimo elemento é de 16
a[-2] # segundo ao último elemento é 9
a[a.size-1] # Outra forma de consultar o último elemento
a[-a.size] # Outra forma de consultar o primeiro elemento
a[8] # Consultando além do fim retorna nil
a[-8] # Consultando antes do início retorna nil, também
</code>
Todas as expressões acima, exceto para a última, pode também ser
utilizado no lado esquerdo de uma atribuição:</p>

<p><code>ruby Arrays
a[0] = "zero" # a é ["zero", 1, 4, 9, 16]
a[-1] = 1..16 # a é ["zero", 1, 4, 9, 1 .. 16]
a[8] = 64 # a é ["zero", 1, 4, 9, 1 .. 16, nil, nil, nil, 64]
a[-10] = 100 # erro: não é possível atribuir antes do início de um array
</code></p>

<p>Como strings, Arrayes também podem ser indexados com dois números inteiros que
representam um índice de partida e um número de elementos, ou um objeto de intervalo. Em qualquer caso, a expressão
retorna o sub-array especificado:</p>

<p><code>ruby Array
a = ('a'..'e').to_a # Faixa convertido para ['a', 'b', 'c', 'd', 'e']
a[0,0] # []: este subarray tem zero elementos
a[1,1] # ['b']: uma Array de um elemento
a[-2,2] # ['d', 'e']: os últimos dois elementos do array
a[0..2] # ['a', 'b', 'c']: os primeiros três elementos
a[-2 .. -1] # ['d', 'e']: os últimos dois elementos do array
a [0 ... -1] # ['a', 'b', 'c', 'd']: a totalidade, mas o último elemento
</code></p>

<p>Quando utilizado no lado esquerdo de uma atribuição, um sub-array pode ser
substituído pelos elementos do Array do lado direito. Esta básica
operação funciona para inserções e exclusões, bem como:</p>

<p><code>ruby Arrays
a[0,2] = ['A', 'B'] # se torna ['A', 'B', 'c', 'd', 'e']
a[2 ... 5] = ['C', 'D', 'E'] # se torna ['A', 'B', 'C', 'D', 'E']
a[0,0] = [1,2,3] # Inserir elementos no início de a
a[0 .. 2] = [] # Excluir os elementos
a[-1,1] = ['Z'] # Substitua último elemento com outro
a[-1,1] = 'Z' # Para os elementos individuais, a Array é opcional
a[-2,2] = nil # Excluir últimos 2 elementos em 1,8; substituir com nil em 1,9
</code></p>

<p>Além disso para o operador colchete para indexar um Array,
a classe Array define uma série de outros operadores úteis. Use + para
concatenar dois Arrays:</p>

<p><code>ruby Concatenar Arrays
a = [1, 2, 3] + [4, 5] # [1, 2, 3, 4, 5]
a = a + [[6, 7, 8]] # [1, 2, 3, 4, 5, [6, 7, 8]]
a = a + 9 # erro: lado direito deve ser um array
</code></p>

<p>O operador + cria um novo Array que contém os elementos de ambos os seus operandos. Use &lt;&lt; para acrescentar um elemento para o final de um
Array existente, e usar a concat anexar os elementos de um array:</p>

<p><code>ruby Array + e concat
a = [] # Comece com uma Array vazia
a &lt;&lt; 1 # a é [1]
a &lt;&lt; 2 &lt;&lt; 3 # a é [1, 2, 3]
a &lt;&lt; [4,5,6] # a é [1, 2, 3, [4, 5, 6]]
a.concat [7,8] # a é [1, 2, 3, [4, 5, 6], 7, 8]
</code></p>

<p>O operador - subtrai um Array do outro. Começa por fazer uma cópia de sua Array da esquerda,
e, em seguida, remove todos os elementos de que a cópia se que apareçam em qualquer
a Array do lado direito:</p>

<p><code>ruby Array -
['A', 'b', 'c', 'b', 'a'] - ['b', 'c', 'd'] # ['A', 'a']
</code></p>

<p>Como a classe String, Array também usa o operador de multiplicação
para a repetição:</p>

<p><code>ruby Array *
a = [0] * 8 # [0, 0, 0, 0, 0, 0, 0, 0]
</code></p>

<p>A classe Array contem tambem os Operadores booleanos (| , &amp;) e usa-los para a união e
interseção. | Concatena seu argumentos e, em seguida, remove todos os elementos repetidos no resultado.
&amp; retorna uma Array que contém elementos que aparecem em ambas as Arrayes de operando. A Array retornada
não contém elementos duplicados:</p>

<p><code>ruby Array
a = [1, 1, 2, 2, 3, 3, 4]
b = [5, 5, 4, 4, 3, 3, 2]
a | b # [1, 2, 3, 4, 5]: duplicatas são removidas
b | a # [5, 4, 3, 2, 1]: elementos são os mesmos, mas a ordem é diferente
a &amp; b # [2, 3, 4]
b &amp; a # [4, 3, 2]
</code></p>

<p>Note-se que estes operadores não são transitivos: a | b não é o mesmo que b | a, por exemplo. Se você ignorar o ordenamento
dos elementos, no entanto, e considerar os Arrays para ser ordenado os conjuntos,
então estes operadores fazem mais sentido. Note também que o algoritmo
que a união e intersecção são realizados não é especificado, e não
existem garantias sobre a ordem dos elementos no retornou dos
Arrays.</p>

<p>A classe Array define um bom número de alguns métodos úteis. O único que vamos discutir aqui é o iterador each, usada para loop através ds
elementos de um Array:</p>

<p><code>ruby Array each
a = ('A' .. 'Z').to_a # Comece com uma série de cartas
a.each {| x | print x} # Imprimir o alfabeto, uma letra de cada vez
</code></p>

<p>Outros métodos do Array você pode deseja procurar,  incluindo: clear,
compact!, delete_if, each_index, empty?, fill, flatten!, include?, index, join, pop,
push, reverse, reverse_each, rindex, shift, sort, sort!, uniq!, e unshift.</p>

<p><a href="http://www.ruby-doc.org/core-1.9.2/Array.html">www.ruby-doc.org/core-1.9.2/Array.html</a></p>

<p>Até a proxima amigos... :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A classe Encoding]]></title>
    <link href="http://rrmartins.github.com/blog/2012/04/30/a-classe-encoding/"/>
    <updated>2012-04-30T10:04:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/04/30/a-classe-encoding</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>A classe Encoding de Ruby 1.9 representa uma codificação de caracteres. Objetos de codificação para agir como identificadores opacos para uma codificação e não têm muitos métodos próprios. O nome do método retorna o nome de uma codificação. to_s é um sinônimo para o name, e inspect converte um objeto em uma seqüência de codificação de uma forma mais detalhada do que o name faz.</p>




<p>Ruby define uma constante para cada uma das codificações built-in's que ele suporta, e estes são a maneira mais fácil de especificar uma codificação em seu programa. As constantes predefinidas incluem pelo menos o seguinte:</p>


<p><code>ruby Encoding
Encoding::ASCII_8BIT     # Also ::BINARY
Encoding::UTF_8          # UTF-8-encoded Unicode characters
Encoding::EUC_JP         # EUC-encoded Japanese
Encoding::SHIFT_JIS      # Japanese: also ::SJIS, ::WINDOWS_31J, ::CP932
</code></p>

<!--more-->


<p>Observe que, como estas são constantes, eles devem ser escritos em letras maiúsculas e hífens nos nomes de codificação devem ser convertidos para sublinhados. Ruby 1.9 também suporta a codificação US-ASCII, as codificações européias ISO-8859-1 através da ISO-8859-15, e o Unicode UTF-16 e UTF-32 codificações em variantes big-endian e little-endian.</p>




<p>Se você tiver um nome de codificação como uma string e deseja obter o objeto de codificação correspondente, use o método de fábrica Encoding.find:</p>


<p><code>ruby Encoding
encoding = Encoding.find("utf-8")
</code></p>

<p>
Usando Encoding.find faz com que a codificação passa a ser carregada dinamicamente, se necessário. Encoding.find aceita names de codificação que são qualquer maiúsculo ou minúsculo. Chame o método name de uma codificação para obter o nome da codificação como uma string.</p>




<p>Encoding.list retorna uma matriz de todos os objetos de codificação disponíveis. Encoding.name_list retorna um array de nomes (como strings) de todas as codificações disponíveis. Codificações muito têm mais de um nome de uso comum, e Encoding.aliases retorna um hash que mapeia aliases de codificação para os names de codificação oficial pelos quais são sinônimos. A matriz retornada por Encoding.name_list inclui os aliases nos Encoding.aliases hash.</p>


<p><code>ruby Encoding.name_list
Encoding.name_list
 =&gt; ["ASCII-8BIT", "UTF-8", "US-ASCII", "Big5", "Big5-HKSCS", "Big5-UAO", "CP949", "Emacs-Mule", "EUC-JP",
 "EUC-KR", "EUC-TW", "GB18030", "GBK", "ISO-8859-1", "ISO-8859-2", "ISO-8859-3", "ISO-8859-4", "ISO-8859-5",
 "ISO-8859-6", "ISO-8859-7", "ISO-8859-8", "ISO-8859-9", "ISO-8859-10", "ISO-8859-11", "ISO-8859-13",
 "ISO-8859-14", "ISO-8859-15", "ISO-8859-16", "KOI8-R", "KOI8-U", "Shift_JIS", "UTF-16BE","UTF-16LE",
 "UTF-32BE", "UTF-32LE", "Windows-1251", "BINARY", "IBM437", "CP437", "IBM737", "CP737", "IBM775",
 "CP775", "CP850","IBM850", "IBM852", "CP852", "IBM855", "CP855", "IBM857", "CP857", "IBM860", "CP860",
 "IBM861", "CP861", "IBM862", "CP862", "IBM863","CP863", "IBM864", "CP864", "IBM865", "CP865", "IBM866",
 "CP866", "IBM869", "CP869", "Windows-1258", "CP1258", "GB1988","macCentEuro", "macCroatian", "macCyrillic",
 "macGreek", "macIceland", "macRoman", "macRomania", "macThai", "macTurkish","macUkraine", "CP950", "CP951",
 "stateless-ISO-2022-JP", "eucJP", "eucJP-ms", "euc-jp-ms", "CP51932", "eucKR", "eucTW", "GB2312","EUC-CN",
 "eucCN", "GB12345", "CP936", "ISO-2022-JP", "ISO2022-JP", "ISO-2022-JP-2", "ISO2022-JP2", "CP50220", "CP50221",
"ISO8859-1", "Windows-1252", "CP1252", "ISO8859-2", "Windows-1250", "CP1250", "ISO8859-3", "ISO8859-4",
"ISO8859-5", "ISO8859-6","Windows-1256", "CP1256", "ISO8859-7", "Windows-1253", "CP1253", "ISO8859-8",
"Windows-1255", "CP1255", "ISO8859-9", "Windows-1254", "CP1254", "ISO8859-10", "ISO8859-11", "TIS-620",
"Windows-874", "CP874", "ISO8859-13", "Windows-1257", "CP1257","ISO8859-14", "ISO8859-15", "ISO8859-16",
"CP878", "SJIS", "Windows-31J", "CP932", "csWindows31J", "MacJapanese", "MacJapan","ASCII", "ANSI_X3.4-1968",
"646", "UTF-7", "CP65000", "CP65001", "UTF8-MAC", "UTF-8-MAC", "UTF-8-HFS", "UCS-2BE", "UCS-4BE","UCS-4LE",
"CP1251", "UTF8-DoCoMo", "SJIS-DoCoMo", "UTF8-KDDI", "SJIS-KDDI", "ISO-2022-JP-KDDI",
"stateless-ISO-2022-JP-KDDI","UTF8-SoftBank", "SJIS-SoftBank", "locale", "external", "filesystem", "internal"]
</code></p>

<p>``` ruby Encoding.aliases</p>

<pre><code>Encoding.aliases
</code></pre>

<p> => {"BINARY"=>"ASCII-8BIT", "CP437"=>"IBM437", "CP737"=>"IBM737", "CP775"=>"IBM775", "IBM850"=>"CP850",
  "CP857"=>"IBM857", "CP860"=>"IBM860", "CP861"=>"IBM861", "CP862"=>"IBM862", "CP863"=>"IBM863",
  "CP864"=>"IBM864", "CP865"=>"IBM865", "CP866"=>"IBM866", "CP869"=>"IBM869", "CP1258"=>"Windows-1258",
  "CP950"=>"Big5", "CP951"=>"Big5-HKSCS", "eucJP"=>"EUC-JP", "euc-jp-ms"=>"eucJP-ms", "eucKR"=>"EUC-KR",
  "eucTW"=>"EUC-TW", "EUC-CN"=>"GB2312", "eucCN"=>"GB2312", "CP936"=>"GBK", "ISO2022-JP"=>"ISO-2022-JP",
  "ISO2022-JP2"=>"ISO-2022-JP-2", "ISO8859-1"=>"ISO-8859-1", "CP1252"=>"Windows-1252", "ISO8859-2"=>"ISO-8859-2",
  "CP1250"=>"Windows-1250", "ISO8859-3"=>"ISO-8859-3", "ISO8859-4"=>"ISO-8859-4", "ISO8859-5"=>"ISO-8859-5",
  "ISO8859-6"=>"ISO-8859-6", "CP1256"=>"Windows-1256", "ISO8859-7"=>"ISO-8859-7", "CP1253"=>"Windows-1253",
  "ISO8859-8"=>"ISO-8859-8", "CP1255"=>"Windows-1255", "ISO8859-9"=>"ISO-8859-9", "CP1254"=>"Windows-1254",
  "ISO8859-10"=>"ISO-8859-10", "ISO8859-11"=>"ISO-8859-11", "CP874"=>"Windows-874", "ISO8859-13"=>"ISO-8859-13",
  "CP1257"=>"Windows-1257", "ISO8859-14"=>"ISO-8859-14", "ISO8859-15"=>"ISO-8859-15", "ISO8859-16"=>"ISO-8859-16",
  "CP878"=>"KOI8-R", "SJIS"=>"Shift_JIS", "CP932"=>"Windows-31J", "csWindows31J"=>"Windows-31J",
  "MacJapan"=>"MacJapanese", "ASCII"=>"US-ASCII", "ANSI_X3.4-1968"=>"US-ASCII", "646"=>"US-ASCII",
  "CP65000"=>"UTF-7", "CP65001"=>"UTF-8", "UTF-8-MAC"=>"UTF8-MAC", "UTF-8-HFS"=>"UTF8-MAC",
  "UCS-2BE"=>"UTF-16BE", "UCS-4BE"=>"UTF-32BE", "UCS-4LE"=>"UTF-32LE", "CP1251"=>"Windows-1251",
  "locale"=>"UTF-8", "external"=>"UTF-8", "filesystem"=>"UTF-8"}
```</p>

<p>Use Encoding.default_external e Encoding.default_internal para obter os objetos de codificação que representam os padrões externos e internos de codificação padrão. Para obter a codificação para o local atual, chame Encoding.locale_charmap e passar a seqüência resultante para Encoding.find.</p>


<p><code>ruby Encoding.default_external
Encoding.default_external
 =&gt; #&lt;Encoding:UTF-8&gt;
</code></p>

<p><code>ruby Encoding.default_internal
Encoding.default_internal
 =&gt; nil
</code></p>

<p><code>ruby Encoding.locale_charmap
Encoding.locale_charmap
 =&gt; "UTF-8"
</code></p>

<p>A maioria dos métodos que esperam um objeto Encoding também aceitará um nome de codificação maiúsculas e minúsculas (como ascii, binário, UTF-8, EUC-JP, ou sjis) no lugar de um objeto de codificação.</p>


<p>É isso ai... até a proxima... :D</p>
]]></content>
  </entry>
  
</feed>
