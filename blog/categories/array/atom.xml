<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Array | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/array/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-07-27T22:56:57-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objetos Enumeráveis #Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/07/25/objetos-enumeraveis-number-ruby-1-dot-9-2/"/>
    <updated>2012-07-25T22:50:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/07/25/objetos-enumeraveis-number-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `Objetos Enumeráveis`... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Objetos Enumeráveis</h1>


<p><code>Array</code>, <code>Range</code>, <code>Hash</code>, e um número de outras classes definem um iterador <code>each</code> que passa cada elemento da
coleção para o bloco associado. Este é talvez o mais comumente usado iterador em Ruby, o loop só funciona para
iterar sobre objetos que têm o método <code>each</code>. Exemplos de iteradores <code>each</code>:</p>

<p><code>ruby Metodo each
[1,2,3].each {|x| print x }   # =&gt; prints "123"
(1..3).each  {|x| print x }   # =&gt; prints "123" Same as 1.upto(3)
</code></p>

<!--more-->


<p>O iterador <code>each</code> não é só para as classes tradicionais "de estrutura de dados". Classes <code>IO</code> Ruby definem um
iterador <code>each</code> que cada linha de texto lido do objeto produz <code>Input/Output</code>. Assim, você pode processar as linhas
de um arquivo em Ruby com um código como esse:</p>

<p><code>ruby Metodo each para File
File.open(filename) do |f|       # Abrir arquivo nomeado, passando f como parametro
  f.each {|line| print line }    # Imprimir f em cada linha
end
</code></p>

<p>A maioria das classes que definem um método <code>each</code> também incluem o módulo <code>Enumerable</code>, que define um número de
iteradores mais especializados que são implementados em cima do método <code>each</code>. Um iterador é útil tal <code>each_with_index</code>, o que nos permite adicionar a linha de numeração para o exemplo anterior:</p>

<p>``` ruby Metodo each com Index
File.open(filename) do |f|
  f.each_with_index do |line,number|</p>

<pre><code>print "#{number}: #{line}"
</code></pre>

<p>  end
end
```</p>

<p>Alguns dos iteradores mais comumentes utilizados são os métodos <code>Enumerable</code>, <code>collect</code>, <code>select</code>, <code>reject</code>, e
<code>inject</code>. O método <code>collect</code> (também conhecido como <code>map</code>) executa o seu bloco associado para cada elemento do objeto
enumerável, e coleta os valores de retorno dos blocos em um <code>array</code>:</p>

<p><code>ruby Metodo Collect
quadrados = [1,2,3].collect {|x| x*x}   # =&gt; [1,4,9]
</code></p>

<p>O método <code>select</code> invoca o bloco associado para cada elemento no objeto enumerável, e retorna uma matriz de
elementos para a qual o bloco retorna um outro valor <code>false</code> ou <code>nil</code>. Por exemplo:</p>

<p><code>ruby Metodo Select
nivela = (1..10).select{|x| x%2 == 0} # =&gt; [2,4,6,8,10]
</code></p>

<p>O método <code>reject</code> é simplesmente o oposto de <code>select</code>, ele retorna uma matriz de elementos para a qual o bloco
retorna <code>nil</code> ou <code>false</code>. Por exemplo:</p>

<p><code>ruby Metodo reject
odds = (1..10).reject{|x| x%2 == 0} # =&gt; [1,3,5,7,9]
</code></p>

<p>O método <code>inject</code> é um pouco mais complicado do que os outros. Ele invoca o bloco associado com dois argumentos.
O primeiro argumento é um valor acumulado de algum tipo das iterações anteriores. O segundo argumento é o próximo
o objeto enumerável. O valor de retorno do bloco é o primeiro argumento bloqueado para a próxima iteração, ou torna-
se o valor de retorno do iterador após a última iteração. O valor inicial da variável acumula ou é o argumento de
<code>inject</code>, se houver um, ou o primeiro elemento do objeto enumerável. (Neste caso, o bloco é invocado. Apenas uma vez durante os primeiros dois elementos). Exemplos para <code>injects</code> mais claros:</p>

<p><code>ruby Metodo Inject
data = [2, 5, 3, 4]
sum = data.inject{|sum, x| sum + x }      # =&gt; 14    (2+5+3+4)
floatprod = data.inject(1.0){|p,x| p*x }  # =&gt; 120.0 (1.0*2*5*3*4)
max = data.inject{|m,x| m&gt;x ? m : x }     # =&gt; 5     (elemento maior)
</code></p>

<p>Veja <a href="http://ruby-doc.org/core-1.9.2/Enumerable.html">Objetos Enumeráveis</a> ​​para obter mais detalhes sobre o <code>Módulo Enumerable</code> e a seus iteradores.</p>

<p>Até a proxima amigos...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Iteradores Numéricos #Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/07/14/iteradores-numericos/"/>
    <updated>2012-07-14T22:52:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/07/14/iteradores-numericos</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `Iteradores Numéricos`... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Iteradores Numéricos</h1>


<p>O núcleo do <code>Ruby API</code> fornece um número de iteradores padrão. Os métodos de loops do Kernel se comporta como um
loop infinito, executando seu bloco associado repetidamente até que o bloco executa um <code>return</code>, <code>break</code>, ou outra
declaração que sai do laço.</p>

<p>A classe <code>Integer</code> define três iteradores usados. O método <code>upto</code> chama seu bloco associado uma vez para cada número
inteiro entre o número inteiro no qual ele é invocado e o número inteiro que é passado como um argumento.
Por exemplo:</p>

<p><code>ruby upto
4.upto(6){|x| print x} # =&gt; prints "456"
</code></p>

<p>Como você pode ver, <code>upto</code> intera cada número inteiro para o bloco associado, e inclui tanto o ponto de partida e o
ponto final na iteração. Em geral, <code>n.upto(m)</code> é executado o bloco <code>m-n +1</code> vezes.</p>

<p>O método <code>downto</code> é como <code>upto</code> mas itera a partir de um maior número para um número menor.</p>

<p>Quando o método <code>Integer.times</code> é chamado no <code>n</code> inteiro, invoque o seu bloco de <code>n vezes</code>, passando os valores de
<code>0 a n-1</code> em iterações sucessivas. Por exemplo:</p>

<p><code>ruby times
3.times {|x| print x }    # =&gt; prints "012"
</code></p>

<p>Em geral, é <code>n.times</code> equivalente a <code>0.upto(n-1)</code>.</p>

<p>Se você quer fazer uma iteração numérica usando um ponto flutuante de números, você pode usar o método <code>step</code> mais
complexo definido pela classe numérica. O iterador a seguir, por exemplo, começa a 0 e itera em passos de 0.1 até
atingir <code>Math::PI</code>:</p>

<p><code>ruby metodo step
0.step(Math::PI, 0.1){|x| puts Math.sin(x)}
</code></p>

<p>Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[unless #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/07/05/unless-number-ruby-1-dot-9/"/>
    <updated>2012-07-05T01:57:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/07/05/unless-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `unless`... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Unless</h1>


<p><code>unless</code>, como uma declaração ou um modificador, é o oposto do <code>case</code>: ele executa o código apenas se uma expressão
associada é avaliada como <code>false</code> ou <code>nil</code>. Sua sintaxe é como <code>if</code>, exceto que as cláusulas <code>elsif</code>, que não são
permitidas:</p>

<p>``` ruby Declaração unless</p>

<h1>Uma maneira, declaração unless</h1>

<p>unless condition
  code
end</p>

<h1>Duas vias da declaração unless</h1>

<p>unless condition
  code
else
  code
end</p>

<h1>modificador unless</h1>

<p>code unless condition
```</p>

<p>A declaração <code>unless</code>, como a declaração <code>if</code>, exige que a condição e o código são separados por uma mudança de linha,
uma vírgula, ou a palavra-chave <code>then</code>. Também como <code>if</code>, as declarações <code>unless</code> são expressões e retornam o valor do
código que são executados, ou <code>nil</code> se executar nada:</p>

<p>``` ruby Declaração unless</p>

<h1>Chama o método to_s sobre o objeto, a menos que o objeto 'o' for nulo</h1>

<p>s = unless o.nil?                        # Nova linha de separação
  o.to_s
end</p>

<p>s = unless o.nil? then o.to_s end        # separador então
```</p>

<p>Para uma única linha condicionais como esta, a forma do modificador <code>unless</code> é geralmente mais clara:</p>

<p><code>ruby Unless
s = o.to_s unless o.nil?
</code></p>

<p>Ruby não tem nenhum equivalente da cláusula <code>elsif</code> para a condicional <code>unless</code>. Você ainda pode escrever um multiway da instrução <code>unless</code>, no entanto, se você está disposto a ser um pouco mais detalhado:</p>

<p>``` ruby unless
unless x == 0
  puts "x is not 0"
else
  unless y == 0</p>

<pre><code>puts "y is not 0"
</code></pre>

<p>  else</p>

<pre><code>unless z == 0
  puts "z is not 0"
else
  puts "all are 0"
end
</code></pre>

<p>  end
end
```</p>

<p>É isso ai amigos!</p>

<p>Para todos aqueles que não sabiam ao certo o que seria o <code>unless</code>, e que tipo de monstro é isso..</p>

<p>Esta ai..</p>

<p>Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Demonstrações e Estruturas de controle - Part I #Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/18/demonstracoes-e-estruturas-de-controle/"/>
    <updated>2012-06-18T08:43:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/18/demonstracoes-e-estruturas-de-controle</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Demonstrações e estruturas de controle</p>




<h1>Demonstrações e estruturas de controle</h1>


<p>Considere o programa Ruby seguinte. Acrescenta dois números passados ​​para na linha de comando e imprime a soma:</p>

<p><code>ruby Programa Simples
x = ARGV[0].to_f # Converter primeiro argumento para um número
y = ARGV[1].to_f # Converter segundo argumento para um número
soma = x + y # Adicione os argumentos
puts soma # Imprimir a soma
</code></p>

<p>Este é um programa simples que consiste essencialmente em invocar variável de atribuição e método. O que o torna
particularmente simples é sua execução puramente seqüencial. As quatro linhas de código são executadas uma após a outra
sem ramificação ou repetição. É um programa raro que pode ser tão simples.</p>

<h3>Condicionais</h3>


<p>A estrutura de controle mais comum, em qualquer linguagem de programação, é a condicional. Esta é uma forma de dizer ao
computador para condicionalmente executar alguns códigos: para executar ele, só se alguma condição for satisfeita.
A condição é uma expressão, se for avaliada como qualquer valor diferente de falso ou nulo, então a condição é satisfeita.</p>

<p>Ruby tem um vocabulário rico para expressar condicionais. Algumas sintaxes são descritas abaixo. Ao escrever código Ruby,
você pode escolher o que parece mais elegante para a tarefa.</p>

<!--more-->




<h5>if</h5>


<p>Ele é a mais simples das condicionais. Em sua forma mais simples, parece que isso:</p>

<p><code>ruby Condicional IF
if expression
  code
end
</code></p>

<p>O código entre <code>if</code> e <code>end</code>é executado se (e somente se) o <code>expression</code> é avaliada como algo diferente que <code>falso</code> ou
<code>nulo</code>. O código deve ser separado a partir da expressão com uma nova linha ou ponto e vírgula ou a palavra-chave, em
seguida. Aqui estão duas maneiras de escrever a mesma condicional <code>if</code> de forma simples:</p>

<p>```ruby Condicional IF</p>

<h1>Se x é menor que 10, incrementá-lo</h1>

<p>if x &lt; 10 # nova linha de separação
  x + = 1
end
if x &lt; 10 then x += 1 end # the separato
```</p>

<p>Você também pode usar <code>then</code> como o símbolo de separação, e segui-lo com uma nova linha. Isso torna o seu código robusto.</p>

<p><code>ruby Condicional IF
if x &lt; 10 then
  x + = 1
end
</code></p>

<p>Os programadores que estão acostumados a C, ou linguagens cuja sintaxe é derivada de C, deve observar duas coisas
importantes sobre if no Ruby:</p>

<ul>
<li><p>Parênteses não é necessário (e normalmente não utilizado) em torno da expressão condicional. O ponto e vírgula, quebra
de linha, ou então palavra-chave serve para delimitar a expressão.</p></li>
<li><p>A palavra-chave <code>end</code> é exigida, mesmo quando o código a ser executado condicionalmente consiste de uma única instrução.
A forma modificador do <code>if</code>, descrito abaixo, fornece uma maneira para gravar condicionais simples sem a palavra-chave <code>end</code>.</p></li>
</ul>


<h5>else</h5>


<p>Uma declaração <code>if</code> pode incluir uma cláusula <code>else</code> para especificar o código para ser executado se a condição não é
<code>true</code>:</p>

<p><code>ruby Condicional else
if expression
  code
else
  code
end
</code></p>

<p>O código entre <code>if</code> e <code>else</code> é executado se <code>expression</code> é avaliada como qualquer outra coisa que <code>false</code> ou <code>nil</code>. Caso
contrário (se expression é <code>false</code> ou <code>nil</code>), o código entre o <code>else</code> e o <code>end</code> é executado. Como na forma simples
de <code>if</code>, na expressão deve ser separado do código que o segue por uma nova linha, um ponto e vírgula, ou a palavra-chave <code>then</code>. As palavras-chave <code>else</code> e <code>end</code>, totalmente delimitam o segundo pedaço de código, e sem novas linhas ou
delimitadores adicionais são exigido.</p>

<p>Aqui é um exemplo de um condicional que inclui uma cláusula <code>else</code>:</p>

<p><code>ruby Condicional if - else
if dados # Se o array existe
  dados &lt;&lt; x # em seguida, acrescentar um valor a ela.
else # Caso contrário ...
  data = [x] # criar uma nova matriz que contém o valor.
end # Este é o fim do condicional
</code></p>

<h5>elsif</h5>


<p>Se você quiser testar mais de uma condição dentro de uma condicional, você pode adicionar um ou mais cláusulas <code>elsif</code>
entre um <code>if</code> e um <code>else</code>. <code>elsif</code> é uma forma abreviada de <code>else if</code>. Note que há apenas um <code>else</code> em <code>elsif</code>. A condicional <code>elsif</code> usando parecido com este:</p>

<p><code>ruby Expressão elsif
if expression1
  code1
elsif expression2
  code2
      .
      .
      .
elsif expressionN
  codeN
else
  code
end
</code></p>

<p>Se <code>expression1</code> for avaliado não sendo <code>false</code> ou <code>nil</code>, então <code>code1</code> é executado. Caso contrário, <code>expression2</code> é
avaliada. Se for outra coisa senão <code>false</code> ou <code>nil</code>, então code2 é executado. Este processo continua até que uma expressão
é avaliada como algo diferente de <code>false</code> ou <code>nil</code>, ou até que todas as cláusulas <code>elsif</code> foram testadas. Se a expressão
associada com a última cláusula <code>elsif</code> for <code>false</code> ou <code>nil</code>, e da cláusula <code>elsif</code> é seguido por uma cláusula <code>else</code>, em
seguida, o código entre <code>else</code> e no <code>end</code> é executado. Se nenhuma cláusula mais está presente, em seguida, nenhum código é
executado.</p>

<p><code>elsif</code> é como se: a expressão deve ser separada do código por uma nova linha, uma vírgula ou uma palavra-chave, em seguida
. Aqui é um exemplo de uma multi condicional usando <code>elsif</code>:</p>

<p><code>ruby Condicional elsif
if x == 1
  name = "um"
elsif x == 2
  name = "dois"
elsif x == 3 then name = "três"
elsif x == 4; name = "quatro"
else
  name = "muitos"
end
</code></p>

<h5>Valor de retorno</h5>


<p>Na maioria das linguagens, a condicional <code>if</code> é uma afirmação. Em Ruby, no entanto, tudo é uma expressão, mesmo as
estruturas de controle que são comumente chamadas de declarações. O valor <code>return</code> de uma "declaração" <code>if</code>, é o valor da
última expressão no código que foi executado, ou <code>nil</code> se nenhum bloco de código foi executado.</p>

<p>O fato de que, as declarações <code>if</code> devolvem um valor significa que, por exemplo, a muilti condicional mostrado
anteriormente pode ser elegantemente reescrito como este abaixo:</p>

<p><code>ruby Valor de Retorno
name = if x == 1 then "um"
       elsif x == 2 then "dois"
       elsif x == 3 then "três"
       elsif x == 4 then "quatro"
       else "muitos"
       end
</code></p>

<p>É isso aí amigos..</p>

<p>Bons estudos e até a proxima! :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atribuição Paralela #Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/11/atribuicao-paralela-number-ruby/"/>
    <updated>2012-06-11T19:36:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/11/atribuicao-paralela-number-ruby</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Atribuições Paralelas</p>




<h1>Atribuições Paralelas</h1>


<p>Atribuição paralela é qualquer atribuição de expressão que tem mais do que um <code>lvalue</code>, mais do que um <code>rvalue</code>, ou ambos. Múltiplos <code>lvalues</code> e ​​múltiplos <code>rvalues</code> são separados uns dos outros com uma vírgula. <code>lvalues</code> e <code>rvalues</code> ​​pode ser prefixado com <code>*</code>, que às vezes é chamado de operador <code>splat</code>, embora não seja um verdadeiro operador. O significado de <code>*</code> é explicado mais adiante neste post.</p>

<p>Expressões de atribuição mais paralelas são simples, e é óbvio que eles significam. Existem alguns casos complicados, no entanto, e os subtitulos seguintes explicam todas as possibilidades.</p>

<!--more-->




<h5>Mesmo número de lvalues ​​e rvalues</h5>


<p>Atribuição paralela é a sua forma mais simples quando não são os mesmos número de <code>lvalues</code> ​​e <code>rvalues</code>:</p>

<p><code>ruby Atribuição de Mesmo número
x, y, z = 1, 2, 3 # x = 1; y = 2; z = 3
</code></p>

<p>Neste caso, o primeiro <code>rvalue</code> é atribuído ao primeiro <code>lvalue</code>; o segundo <code>rvalue</code> é atribuído ao segundo <code>lvalue</code>, e assim por diante.</p>

<p>Estas atribuições são efetivamente executadas em paralelo, não seqüencialmente. Por exemplo, as seguintes duas linhas não são as mesmas:</p>

<p><code>ruby Atribuição
x, y = y, x # Paralela: trocar o valor de duas variáveis
x = y; y = x # seqüencial: ambas as variáveis ​​têm o mesmo valor
</code></p>

<h5>Um lvalue, ​​múltiplos rvalues</h5>


<p>Quando há um único <code>lvalue</code> e mais do que um <code>rvalue</code>, Ruby cria um <code>array</code> para armazenar os <code>rvalues</code> ​​e atribui esse <code>array</code> para o <code>lvalue</code>:</p>

<p><code>ruby Um lvalue e Múltiplos rvalues
x = 1, 2, 3 # x = [1,2,3]
</code></p>

<p>Você pode colocar um <code>*</code> antes do lvalue sem alterar o significado ou o valor de retorno desta atribuição.</p>

<p>Se você quiser impedir que os ​múltiplos <code>rvalues</code> de serem combinados em um único <code>array</code>, siga o <code>lvalue</code> com uma vírgula. Mesmo sem um lvalue depois da vírgula, isto torna que o Ruby se comporte como se há ​​múltiplos lvalues:</p>

<p><code>ruby Atribuições
x, = 1, 2, 3 # x = 1; outros valores são descartados
</code></p>

<h5>M​últiplos lvalues, array único de rvalue</h5>


<p>Quando existem múltiplos <code>lvalues​</code> e apenas um único <code>rvalue</code>, Ruby tenta expandir o rvalue em uma <code>lista</code> de valores a atribuir. Se o <code>rvalue</code> é um <code>array</code>, Ruby expande o <code>array</code> para que cada elemento torna-se seu próprio <code>rvalue</code>. Se o <code>rvalue</code> não é um <code>array</code>, mas implementa um método <code>to_ary</code>, Ruby invoca esse método e, em seguida, se expande o <code>array</code> no retorno:</p>

<p><code>ruby Atribuição
x, y, z = [1, 2, 3] # mesmo que x, y, z = 1,2,3
</code></p>

<p>A atribuição paralela foi transformado de modo que há ​​múltiplos <code>lvalues</code> e zero (se expandida o <code>array</code> estando <code>empty</code>) ou mais <code>rvalues</code>. Se o número de <code>lvalues</code> ​​e <code>rvalues</code> ​​são os mesmos, então a atribuição ocorre conforme descrito anteriormente, Mesmo número de lvalues ​​e rvalues<code>. Se os números são diferentes, então a atribuição ocorre como descrito a seguir em</code>Diferentes números de lvalues ​​e rvalues`.</p>

<p>Podemos usar o truque de fuga por vírgula descrito acima para transformar uma sessão ordinária não paralela em uma atribuição que automaticamente descompacta um <code>array</code> à direita:</p>

<p><code>ruby Atribuição
x = [1,2] # x torna-se [1,2]: isso não é atribuição paralela
x, = [1,2] # x torna-se 1: da vírgula torna paralelo
</code></p>

<h5>Diferentes números de lvalues ​​e rvalues</h5>


<p>Se houver <code>lvalues</code> mais do que ​​<code>rvalues</code>, e nenhum operador <code>splat</code> é envolvido, em seguida, o primeiro <code>rvalue</code> é atribuído ao primeiro <code>lvalue</code>, o segundo <code>rvalue</code> é atribuído ao segundo <code>lvalue</code>, e assim por diante, até todos os <code>rvalues</code> ​​forem atribuídos. Em seguida, cada um dos restantes <code>lvalues</code> ​​é atribuído nil, substituindo qualquer valor existente para que <code>lvalue</code>:</p>

<p><code>ruby Atribuição
x, y, z = 1, 2 # x = 1; y = 2; z = nil
</code></p>

<p>Se houver <code>rvalues</code> mais do que ​<code>​lvalues</code>, e nenhum operador <code>splat</code> é envolvido, em seguida, os <code>rvalues</code> ​são atribuídos em ordem a cada um dos <code>lvalues</code>, e os restantes <code>rvalues</code> são descartados :</p>

<p><code>ruby Atribuição
x, y = 1, 2, 3 # x = 1; y = 2, 3 não é atribuído
</code></p>

<h5>O operador splat</h5>


<p>Quando um <code>rvalue</code> é precedido por um asterisco(<code>*</code>), isso significa que o referido valor é um <code>array</code> e que seus elementos devem ser cada um <code>rvalues</code>. Os elementos do <code>array</code> substituem o <code>array</code> na lista original do <code>rvalue</code>, e a atribuição procede como descrito abaixo:</p>

<p><code>ruby Atribuição
x, y, z = 1, * [2,3] # mesmo que x, y, z = 1,2,3
</code></p>

<p>No Ruby 1.8, um splat só pode aparecer antes do último <code>rvalue</code> em uma atribuição. No Ruby 1.9, a lista de <code>rvalues</code> ​​em uma atribuição paralela pode ter qualquer número de <code>splats</code>, e eles podem aparecer em qualquer posição na lista. Não é legal, porém, em qualquer versão da linguagem, para tentar um "splat double" em uma lista aninhada:</p>

<p><code>ruby Erro de Atribuição
x,y = **[[1,2]]   # SyntaxError!
</code></p>

<p>Os <code>rvalues</code> com i​ntervalo de <code>arrays</code> e de <code>hash</code> pode ser <code>splatted</code>. Em geral, qualquer <code>rvalue</code> que define um método <code>to_a</code> pode ser prefixado com um <code>splat</code>. Qualquer objeto <a href="http://ruby-doc.org/core-1.9.3/Enumerable.html"><code>Enumerable</code></a>, incluindo enumeradores pode ser <code>splatted</code>, por exemplo. Quando um <code>splat</code> é aplicado a um objecto que não define um método <code>to_a</code>, nenhuma expansão é realizada e o <code>splat</code> avaliado como o próprio objeto.</p>

<p>Quando um <code>lvalue</code> é precedido por um asterisco(<code>*</code>), isso significa que todos ​​os adicionais <code>rvalues</code> devem ser colocados em um <code>array</code> e atribuído ao <code>lvalue</code>. O valor atribuído a esse <code>lvalue</code> é sempre um <code>array</code>, e ele pode ter zero, um ou mais elementos:</p>

<p><code>ruby Atribuição
x,*y = 1, 2, 3  # x=1; y=[2,3]
x,*y = 1, 2     # x=1; y=[2]
x,*y = 1        # x=1; y=[]
</code></p>

<p>No Ruby 1.8, um <code>splat</code> só pode preceder o <code>lvalue</code> passado na lista. No Ruby 1.9, do lado esquerdo de uma atribuição paralela pode incluem um operador <code>splat</code>, mas pode aparecer em qualquer posição na lista:</p>

<p>``` ruby Atribuição</p>

<h1>Ruby 1.9 somente</h1>

<p><em>x,y = 1, 2, 3  # x=[1,2]; y=3
</em>x,y = 1, 2     # x=[1]; y=2
*x,y = 1        # x=[]; y=1
```</p>

<p>Note-se que <code>splats</code> pode aparecer em ambos os lados de uma expressão paralela de atribuição:</p>

<p><code>ruby Atribuição
x, y, *z = 1, *[2,3,4]  # x=1; y=2; z=[3,4].
</code></p>

<p>Finalmente, lembre-se que anteriormente descrevemos dois casos simples de atribuição paralela em que há um <code>lvalue</code> único ou uma única <code>rvalue</code>. Note-se que ambos os casos se comportam como se existe um <code>splat</code> antes da única <code>lvalue</code> ou <code>rvalue</code>. Explicitamente, incluindo um <code>splat</code> em nestes casos não tem qualquer efeito adicional.</p>

<h5>Parênteses na atribuição paralelo</h5>


<p>Uma das características menos compreendidas da atribuição paralela é que o lado esquerdo pode usar parênteses para "sub atrobuição". Se um grupo de dois ou mais <code>lvalues</code> ​​é colocado entre parênteses, então é inicialmente tratada como um <code>lvalue</code> único. Uma vez que o <code>rvalue</code> correspondente foi determinado, as regras de atribuição paralela são aplicadas recursivamente, o <code>rvalue</code> que é atribuído ao grupo de <code>lvalues</code> ​​que foi em parênteses. Considere o seguinte exercício:</p>

<p><code>ruby Atribuição
x, (y, z) = a, b
</code></p>

<p>Este é efetivamente executam dois trabalhos ao mesmo tempo:</p>

<p><code>ruby Atribuição
x = a
y,z = b
</code></p>

<p>Mas note que a segunda tarefa é em si uma atribuição paralela. Como usamos parênteses no lado esquerdo, uma atribuição paralela recursiva é executada. Em ordem para que ele funcione, b deve ser um objeto <code>splattable</code> como um <code>array</code> ou <code>enumerador</code>.</p>

<p>Aqui estão alguns exemplos concretos que devem tornar isso mais claro. Note que os parênteses no ato da esquerda a "desembrulhar" um nível de <code>array</code> alinhado à direita:</p>

<p>```ruby Atribuição
x,y,z = 1,[2,3]             # Sem parenteses: x=1;y=[2,3];z=nil
x,(y,z) = 1,[2,3]           # Parenteses: x=1;y=2;z=3</p>

<p>a,b,c,d = [1,[2,[3,4]]]     # Sem parenteses: a=1;b=[2,[3,4]];c=d=nil
a,(b,(c,d)) = [1,[2,[3,4]]] # Parenteses: a=1;b=2;c=3;d=4
```</p>

<p>É isso aí amigos..</p>

<p>Bons estudos e até a proxima! :D</p>
]]></content>
  </entry>
  
</feed>
