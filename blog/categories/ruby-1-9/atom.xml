<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby 1.9 | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/ruby-1-9/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-06-14T13:31:59-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Atribuição Paralela #Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/11/atribuicao-paralela-number-ruby/"/>
    <updated>2012-06-11T19:36:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/11/atribuicao-paralela-number-ruby</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Atribuições Paralelas</p>




<h1>Atribuições Paralelas</h1>


<p>Atribuição paralela é qualquer atribuição de expressão que tem mais do que um <code>lvalue</code>, mais do que um <code>rvalue</code>, ou ambos. Múltiplos <code>lvalues</code> e ​​múltiplos <code>rvalues</code> são separados uns dos outros com uma vírgula. <code>lvalues</code> e <code>rvalues</code> ​​pode ser prefixado com <code>*</code>, que às vezes é chamado de operador <code>splat</code>, embora não seja um verdadeiro operador. O significado de <code>*</code> é explicado mais adiante neste post.</p>

<p>Expressões de atribuição mais paralelas são simples, e é óbvio que eles significam. Existem alguns casos complicados, no entanto, e os subtitulos seguintes explicam todas as possibilidades.</p>

<!--more-->




<h5>Mesmo número de lvalues ​​e rvalues</h5>


<p>Atribuição paralela é a sua forma mais simples quando não são os mesmos número de <code>lvalues</code> ​​e <code>rvalues</code>:</p>

<p><code>ruby Atribuição de Mesmo número
x, y, z = 1, 2, 3 # x = 1; y = 2; z = 3
</code></p>

<p>Neste caso, o primeiro <code>rvalue</code> é atribuído ao primeiro <code>lvalue</code>; o segundo <code>rvalue</code> é atribuído ao segundo <code>lvalue</code>, e assim por diante.</p>

<p>Estas atribuições são efetivamente executadas em paralelo, não seqüencialmente. Por exemplo, as seguintes duas linhas não são as mesmas:</p>

<p><code>ruby Atribuição
x, y = y, x # Paralela: trocar o valor de duas variáveis
x = y; y = x # seqüencial: ambas as variáveis ​​têm o mesmo valor
</code></p>

<h5>Um lvalue, ​​múltiplos rvalues</h5>


<p>Quando há um único <code>lvalue</code> e mais do que um <code>rvalue</code>, Ruby cria um <code>array</code> para armazenar os <code>rvalues</code> ​​e atribui esse <code>array</code> para o <code>lvalue</code>:</p>

<p><code>ruby Um lvalue e Múltiplos rvalues
x = 1, 2, 3 # x = [1,2,3]
</code></p>

<p>Você pode colocar um <code>*</code> antes do lvalue sem alterar o significado ou o valor de retorno desta atribuição.</p>

<p>Se você quiser impedir que os ​múltiplos <code>rvalues</code> de serem combinados em um único <code>array</code>, siga o <code>lvalue</code> com uma vírgula. Mesmo sem um lvalue depois da vírgula, isto torna que o Ruby se comporte como se há ​​múltiplos lvalues:</p>

<p><code>ruby Atribuições
x, = 1, 2, 3 # x = 1; outros valores são descartados
</code></p>

<h5>M​últiplos lvalues, array único de rvalue</h5>


<p>Quando existem múltiplos <code>lvalues​</code> e apenas um único <code>rvalue</code>, Ruby tenta expandir o rvalue em uma <code>lista</code> de valores a atribuir. Se o <code>rvalue</code> é um <code>array</code>, Ruby expande o <code>array</code> para que cada elemento torna-se seu próprio <code>rvalue</code>. Se o <code>rvalue</code> não é um <code>array</code>, mas implementa um método <code>to_ary</code>, Ruby invoca esse método e, em seguida, se expande o <code>array</code> no retorno:</p>

<p><code>ruby Atribuição
x, y, z = [1, 2, 3] # mesmo que x, y, z = 1,2,3
</code></p>

<p>A atribuição paralela foi transformado de modo que há ​​múltiplos <code>lvalues</code> e zero (se expandida o <code>array</code> estando <code>empty</code>) ou mais <code>rvalues</code>. Se o número de <code>lvalues</code> ​​e <code>rvalues</code> ​​são os mesmos, então a atribuição ocorre conforme descrito anteriormente, Mesmo número de lvalues ​​e rvalues<code>. Se os números são diferentes, então a atribuição ocorre como descrito a seguir em</code>Diferentes números de lvalues ​​e rvalues`.</p>

<p>Podemos usar o truque de fuga por vírgula descrito acima para transformar uma sessão ordinária não paralela em uma atribuição que automaticamente descompacta um <code>array</code> à direita:</p>

<p><code>ruby Atribuição
x = [1,2] # x torna-se [1,2]: isso não é atribuição paralela
x, = [1,2] # x torna-se 1: da vírgula torna paralelo
</code></p>

<h5>Diferentes números de lvalues ​​e rvalues</h5>


<p>Se houver <code>lvalues</code> mais do que ​​<code>rvalues</code>, e nenhum operador <code>splat</code> é envolvido, em seguida, o primeiro <code>rvalue</code> é atribuído ao primeiro <code>lvalue</code>, o segundo <code>rvalue</code> é atribuído ao segundo <code>lvalue</code>, e assim por diante, até todos os <code>rvalues</code> ​​forem atribuídos. Em seguida, cada um dos restantes <code>lvalues</code> ​​é atribuído nil, substituindo qualquer valor existente para que <code>lvalue</code>:</p>

<p><code>ruby Atribuição
x, y, z = 1, 2 # x = 1; y = 2; z = nil
</code></p>

<p>Se houver <code>rvalues</code> mais do que ​<code>​lvalues</code>, e nenhum operador <code>splat</code> é envolvido, em seguida, os <code>rvalues</code> ​são atribuídos em ordem a cada um dos <code>lvalues</code>, e os restantes <code>rvalues</code> são descartados :</p>

<p><code>ruby Atribuição
x, y = 1, 2, 3 # x = 1; y = 2, 3 não é atribuído
</code></p>

<h5>O operador splat</h5>


<p>Quando um <code>rvalue</code> é precedido por um asterisco(<code>*</code>), isso significa que o referido valor é um <code>array</code> e que seus elementos devem ser cada um <code>rvalues</code>. Os elementos do <code>array</code> substituem o <code>array</code> na lista original do <code>rvalue</code>, e a atribuição procede como descrito abaixo:</p>

<p><code>ruby Atribuição
x, y, z = 1, * [2,3] # mesmo que x, y, z = 1,2,3
</code></p>

<p>No Ruby 1.8, um splat só pode aparecer antes do último <code>rvalue</code> em uma atribuição. No Ruby 1.9, a lista de <code>rvalues</code> ​​em uma atribuição paralela pode ter qualquer número de <code>splats</code>, e eles podem aparecer em qualquer posição na lista. Não é legal, porém, em qualquer versão da linguagem, para tentar um "splat double" em uma lista aninhada:</p>

<p><code>ruby Erro de Atribuição
x,y = **[[1,2]]   # SyntaxError!
</code></p>

<p>Os <code>rvalues</code> com i​ntervalo de <code>arrays</code> e de <code>hash</code> pode ser <code>splatted</code>. Em geral, qualquer <code>rvalue</code> que define um método <code>to_a</code> pode ser prefixado com um <code>splat</code>. Qualquer objeto <a href="http://ruby-doc.org/core-1.9.3/Enumerable.html"><code>Enumerable</code></a>, incluindo enumeradores pode ser <code>splatted</code>, por exemplo. Quando um <code>splat</code> é aplicado a um objecto que não define um método <code>to_a</code>, nenhuma expansão é realizada e o <code>splat</code> avaliado como o próprio objeto.</p>

<p>Quando um <code>lvalue</code> é precedido por um asterisco(<code>*</code>), isso significa que todos ​​os adicionais <code>rvalues</code> devem ser colocados em um <code>array</code> e atribuído ao <code>lvalue</code>. O valor atribuído a esse <code>lvalue</code> é sempre um <code>array</code>, e ele pode ter zero, um ou mais elementos:</p>

<p><code>ruby Atribuição
x,*y = 1, 2, 3  # x=1; y=[2,3]
x,*y = 1, 2     # x=1; y=[2]
x,*y = 1        # x=1; y=[]
</code></p>

<p>No Ruby 1.8, um <code>splat</code> só pode preceder o <code>lvalue</code> passado na lista. No Ruby 1.9, do lado esquerdo de uma atribuição paralela pode incluem um operador <code>splat</code>, mas pode aparecer em qualquer posição na lista:</p>

<p>``` ruby Atribuição</p>

<h1>Ruby 1.9 somente</h1>

<p><em>x,y = 1, 2, 3  # x=[1,2]; y=3
</em>x,y = 1, 2     # x=[1]; y=2
*x,y = 1        # x=[]; y=1
```</p>

<p>Note-se que <code>splats</code> pode aparecer em ambos os lados de uma expressão paralela de atribuição:</p>

<p><code>ruby Atribuição
x, y, *z = 1, *[2,3,4]  # x=1; y=2; z=[3,4].
</code></p>

<p>Finalmente, lembre-se que anteriormente descrevemos dois casos simples de atribuição paralela em que há um <code>lvalue</code> único ou uma única <code>rvalue</code>. Note-se que ambos os casos se comportam como se existe um <code>splat</code> antes da única <code>lvalue</code> ou <code>rvalue</code>. Explicitamente, incluindo um <code>splat</code> em nestes casos não tem qualquer efeito adicional.</p>

<h5>Parênteses na atribuição paralelo</h5>


<p>Uma das características menos compreendidas da atribuição paralela é que o lado esquerdo pode usar parênteses para "sub atrobuição". Se um grupo de dois ou mais <code>lvalues</code> ​​é colocado entre parênteses, então é inicialmente tratada como um <code>lvalue</code> único. Uma vez que o <code>rvalue</code> correspondente foi determinado, as regras de atribuição paralela são aplicadas recursivamente, o <code>rvalue</code> que é atribuído ao grupo de <code>lvalues</code> ​​que foi em parênteses. Considere o seguinte exercício:</p>

<p><code>ruby Atribuição
x, (y, z) = a, b
</code></p>

<p>Este é efetivamente executam dois trabalhos ao mesmo tempo:</p>

<p><code>ruby Atribuição
x = a
y,z = b
</code></p>

<p>Mas note que a segunda tarefa é em si uma atribuição paralela. Como usamos parênteses no lado esquerdo, uma atribuição paralela recursiva é executada. Em ordem para que ele funcione, b deve ser um objeto <code>splattable</code> como um <code>array</code> ou <code>enumerador</code>.</p>

<p>Aqui estão alguns exemplos concretos que devem tornar isso mais claro. Note que os parênteses no ato da esquerda a "desembrulhar" um nível de <code>array</code> alinhado à direita:</p>

<p>```ruby Atribuição
x,y,z = 1,[2,3]             # Sem parenteses: x=1;y=[2,3];z=nil
x,(y,z) = 1,[2,3]           # Parenteses: x=1;y=2;z=3</p>

<p>a,b,c,d = [1,[2,[3,4]]]     # Sem parenteses: a=1;b=[2,[3,4]];c=d=nil
a,(b,(c,d)) = [1,[2,[3,4]]] # Parenteses: a=1;b=2;c=3;d=4
```</p>

<p>É isso aí amigos..</p>

<p>Bons estudos e até a proxima! :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atribuições #Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/03/atribuicoes/"/>
    <updated>2012-06-03T11:55:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/03/atribuicoes</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Atribuições</p>




<h1>Atribuições</h1>


<p>Uma expressão de atribuição especifica um ou mais valores para um ou mais valores. lvalue é o termo para algo que pode aparecer no lado
esquerdo de uma atribuição do operador. Os valores no lado direito de um operador de atribuição são algumas vezes chamado de rvalues ​​por
contraste. Variáveis, constantes, atributos e elementos do Array são lvalues ​​em Ruby. As regras para o significado de expressões de
atribuição são um pouco diferente para diferentes tipos de lvalues, e cada tipo é descrito em detalhe neste post.</p>

<!--more-->


<p>Existem três diferentes formas de expressões de atribuição em Ruby. Atribuição simples envolve um lvalue do operador <code>=</code>, e um rvalue.
Para exemplo:</p>

<p><code>ruby Atribuição
x = 1 # Define o lvalue x para o valor 1
</code></p>

<p>Atribuição abreviada é uma expressão abreviada que atualiza o valor de uma variável através da aplicação de alguma outro operador (tais
como a adição) ao valor atual da variável. Atribuição abreviada utiliza a atribuição de operadores como <code>+=</code> e <code>*=</code> que combinam operadores binários com uma sinal de igual:</p>

<p><code>ruby Atribuição
x += 1 # Define o lvalue x para o valor de x + 1
</code></p>

<p>Por fim, a atribuição paralela é qualquer expressão de atribuição que tem mais do que um lvalue ou mais do que um rvalue. Aqui é um simples exemplo:</p>

<p><code>ruby Atribuição
x, y, z = 1,2,3 # Definir x a 1, y a 2 e z a 3
</code></p>

<p>Atribuição paralela é mais complicado quando o número de lvalues não é o mesmo que o número de rvalues ​​ou quando existe um <code>array</code> sobre à direita.</p>

<p>O valor de uma expressão de atribuição é o valor (ou um <code>array</code> dos valores) atribuído. Além disso, o operador de atribuição
é "Associativo à direita", se aparecer várias atribuições em uma única expressão, eles são avaliados da direita para a esquerda.
Isto significa que a atribuição pode ser acorrentado para atribuir o mesmo valor para as múltiplas variáveis:</p>

<p><code>ruby Atribuição
x = y = 0 # X e Y recebem 0
</code></p>

<p>Note-se que este não é um caso de atribuição paralela é duas atribuições simples, acorrentados juntos: Y é atribuído o valor 0, e então x é atribuído o valor da primeira tarefa (também 0).</p>

<h5>Atribuindo a Variáveis</h5>


<p>Quando nós pensamos em atribuição, geralmente pensamos em variáveis ​​e, na verdade, estes são os mais comuns em expressões de atribuição de lvalues. Lembre-se que Ruby tem quatro tipos de variáveis: variáveis ​​locais, variáveis ​​globais, variáveis ​​de instância e variáveis ​​de classe. Estes são distintas um do outro, pelo primeiro carácter no nome da variável. Atribuição funciona da mesma forma para todos os quatro tipos de variáveis, de modo que não é necessário fazer a distinção entre os tipos de variáveis ​​aqui.</p>

<p>Tenha em mente que as variáveis ​​de instância de objetos do Ruby são nunca nomes visíveis fora do objeto, e variável nunca é qualificado com um nome de objeto. Considere esta atribuição:</p>

<p><code>ruby Atribuição
ponto.x, ponto.y = 1, 2
</code></p>

<p>Os lvalues ​​nesta expressão não são variáveis, são atributos.</p>

<p>Atribuição a uma variável funciona como seria de se esperar: a variável é simplesmente definida como o valor especificado. Ruby não tem nenhuma sintaxe para declarar explicitamente uma variável: variáveis ​​simplesmente vir à existência quando são atribuídas. Assim, uma  expressão simples como X poderia se referir a uma variável local chamada x ou um método chamado x. Para resolver essa ambigüidade, Ruby trata de um identificador como uma variável local se tem visto qualquer trabalho anterior para a variável. Ele faz isso com uma atribuição nunca foi executada. O código a seguir demonstra isso:</p>

<p>```ruby Atribuição
class Ambiguous  
  def x; 1; end # Um método chamado "x". Sempre retorna 1  </p>

<p>  def teste    </p>

<pre><code>puts x # Nenhuma variável foi visto, refere-se ao método acima: imprime 1    

# A linha abaixo não é avaliada, por causa da cláusula "if falsa". 
# Mas o analisador vê e trata x como uma variável para o resto do método.    
x = 0 if false

puts x # x é uma variável, mas nunca foi atribuído: irá imprimir nil

x = 2 # Esta atribuição não é avaliada
puts x # Então agora esta linha imprime 2  
</code></pre>

<p>  end
end
```</p>

<h5>Atribuindo a Constantes</h5>


<p>Constantes são diferentes das variáveis ​​de uma forma óbvia: seus valores são destinados a permanecer constante durante a execução de um programa. Portanto, existem algumas regras especiais para a atribuição de constantes:</p>

<pre><code>* Atribuição a uma constante que já existe, faz com o Ruby emita um aviso. O Ruby executa a tarefa,
no entanto, que significa que as constantes não são realmente constante.

* Atribuição a constantes não é permitido dentro do corpo de um método. Ruby assume que os métodos 
destinados a ser invocados mais de uma vez, se você poderia atribuir a uma constante em um método, 
que método ira emitir alertas a cada requisição após a primeira.  Então, isso simplesmente não é 
permitido.
</code></pre>

<p>Ao contrário das variáveis, as constantes não vem a existir até que o <code>Intérprete Ruby</code> realmente executa a expressão de atribuição. A expressão não avaliada abaixo, não cria uma constante:</p>

<p><code>ruby Atribuiçao de Constante
N = 100 if false
</code></p>

<p>Note-se que isto significa que uma constante nunca está em um estado de inicialização. Se uma constante existe, então ele tem um valor atribuído a ela. A constante só terá valor se o valor realmente for <code>nil</code>.</p>

<h5>Atribuindo a Atributos e elementos de Array</h5>


<p>Atribuição a um atributo ou um elemento de um <code>Array</code> é na verdade uma abreviação do Ruby para a invocação método. Suponha que um objeto tem um método chamado <code>m=:</code>, o nome do método tem um sinal de igual como seu último caractere. Em seguida, <code>o.m</code> pode ser usado como um lvalue em uma expressão de atribuição. Suponha, além disso, que o valor v é atribuído:</p>

<p><code>ruby Atribuição
o.m = v
</code></p>

<p>O interpretador Ruby converte essa tarefa para a seguinte invocação de método:</p>

<p><code>ruby Atribuição
o.m=(v) # Se omitir os parênteses e adicionar um espaço, isso parece tarefa!
</code></p>

<p>Isto é, ele passa o valor v para o método <code>m=</code>. Esse método pode fazer o que quiser com o valor. Normalmente, ele irá verificar que o valor é de desejado tipo e dentro da gama desejada, e, em seguida, armazená-lo em uma variável de instância do objeto. Métodos como <code>m=</code> são geralmente acompanhados de um método <code>m</code>, que simplesmente retorna o valor mais recentemente passado para <code>m=</code>. Alguns dizem que <code>m=</code> é um método setter e <code>m</code> é um método getter. Quando um objeto tem esse par de métodos, dizemos que ele tem um atributo <code>m</code>. Atributos são às vezes chamado de "Propriedades" em outras línguas.</p>

<p>Atribuindo valores aos elementos de um <code>Array</code> também é feito pelo método de invocação. Se um objeto define um método chamado <code>[]=</code> (nome do método é apenas esses três caracteres de pontuação) que espera dois argumentos, então na expressão o <code>[x] = y</code> é realmente executado como:</p>

<p><code>ruby Atribuição
o.[]= (x, y)
</code></p>

<p>Se um objeto tem um método <code>[]=</code> que espera três argumentos, então ele pode ser indexado com dois valores entre os colchetes. As dois seguintes expressões são equivalentes neste caso:</p>

<p><code>ruby Atribuição
o[x, y] = z
o.[] = (x, y, z)
</code></p>

<h5>Atribuição Abreviada</h5>


<p>Atribuição Abreviada é uma forma de atribuição que combina atribuição com alguns outras operações. Ele é usado mais comumente para incrementar variáveis:</p>

<p><code>ruby Atribuição Abreviada
x += 1
</code></p>

<p>O <code>+=</code>, não é um operador real de Ruby, e a expressão acima é simplesmente uma abreviatura para:</p>

<p><code>ruby Atribuição Abreviada
x = x + 1
</code></p>

<p>Atribuição Abreviada não pode ser combinado com paralelo de atribuição: ela só funciona quando há um único lvalue à esquerda e um único valor do lado direito. Ela não deve ser usado quando o lvalue é uma constante, porque ele vai reatribuir a constante e causar um aviso. Atribuição abreviada pode, contudo, ser utilizado quando o lvalue é um atributo. As duas expressões a seguir são equivalentes:</p>

<p><code>ruby Atribuição Abreviada
o.m += 1
o.m=(o.m()+1)
</code></p>

<p>Atribuição abreviada funciona até mesmo quando o lvalue é um elemento de um <code>array</code>. Estas duas expressões são equivalente:</p>

<p><code>ruby Atribuição Abreviada
o[x] -= 2
o.[]=(x, o.[](x) - 2)
</code></p>

<p>Observe que esse código usa <code>-=</code> em vez de <code>+=</code>. Como você poderia esperar, o <code>-=</code> é pseudooperator que subtrai seu rvalue a partir do seu lvalue.</p>

<p>Além <code>+=</code> e <code>-=</code>, há outros 11 pseudooperators que podem ser usados ​​para atribuição abreviada. Eles são listados abaixo. Note-se que estes não são verdadeiros operadores próprios, eles são simplesmente uma abreviação para expressões que usam outros operadores. Muitos desses outros operadores são definidos como métodos. Se uma classe define um método chamado <code>+</code>, por exemplo, em seguida, que as alterações do sentido da Atribuição abreviada com <code>+=</code> para todas as instâncias dessa classe.</p>

<pre><code>Atribuição                          Expansão
x += y                              x = x + y
x -= y                              x = x - y
x *= y                              x = x * y
x /= y                              x = x / y
x %= y                              x = x % y
x **= y                             x = x ** y
x &amp;&amp;= y                             x = x &amp;&amp; y
x ||= y                             x = x || y
x &amp;= y                              x = x &amp; y
x |= y                              x = x | y
x ^= y                              x = x ^ y
x &lt;&lt;= y                             x = x &lt;&lt; y
x &gt;&gt;= y                             x = x &gt;&gt; y
</code></pre>

<p>É isso aí amigos... até o proximo post!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Invocações de método]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/invocacoes-de-metodo/"/>
    <updated>2012-06-02T15:36:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/invocacoes-de-metodo</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Invocações de método</h1>


<p>Uma expressão de invocação de método tem quatro partes:</p>

<ul>
<li><p>Uma expressão arbitrária cujo valor é o objeto no qual o método é chamado. Esta expressão é seguido por . ou :: para separá-lo a partir
do nome do método que se segue. A expressão e o separador são opcionais; se omitido, o método é invocada em si mesmo.</p></li>
<li><p>O nome do método a ser invocado. Este é o único pedaço exigido de uma expressão chamada de método.</p></li>
<li><p>Valores com o argumento passado para o método. A lista de argumentos podem ser colocados entre parênteses, mas estes são geralmente
opcionais. Se há mais de um argumento, eles são separados uns dos outros com vírgulas. O número e tipo de argumentos necessários
dependem da definição do método. Alguns métodos podem ser chamodos sem argumentos.</p></li>
<li><p>Um bloco opcional de código delimitado por chaves ou por um par <code>do/end</code>. O método pode invocar esse código usando a palavra-chave de
 <code>yield</code>. Esta capacidade de associar código arbitrário com qualquer invocação de método é a base para métodos poderosos em Ruby.</p></li>
</ul>


<p>Um nome do método é normalmente separado do objeto sobre o qual é chamado com um <code>..</code>, e com o <code>::</code>, que também é permitido, mas é raramente
usado porque pode fazer invocações de método parecem mais com referênciar constantes expressões.</p>

<p>Quando o interpretador Ruby tem o nome de um método e um objeto em que deve ser invocado, ele encontra a definição adequada do método
chamado usando um processo conhecido como "método de pesquisa" ou "resolução de nome do método." Os detalhes não são importantes aqui,
mas eles são explicados completamente no método de pesquisa.</p>

<p>O valor de uma invocação expressão de método é o valor da expressão avaliada pelo último método no corpo do código. Aqui, no entanto, são
alguns exemplos de invocações de método:</p>

<p><code>ruby Ruby
puts "Olá mundo" # "puts" invocado em auto, com uma seqüência de arg
Math.sqrt(2) # "sqrt" invocado em Matemática objeto com uma arg
message.length # "comprimento" invocado em mensagem objeto; não args
a.each{|x| p x} # "cada" chamado em um objeto, com um bloco associado
</code></p>

<p>Um dos exemplos do método de invocação mostradas anteriormente foi <code>message.length</code>. Você pode ser tentado a pensar-lo como uma variável
de expressão de referência, avaliando para o valor do comprimento da variável do objeto mensage. Este não é o caso, no entanto, Ruby tem
um modelo de programação muito orientada a objetos: objetos em Ruby podem encapsular qualquer número de variáveis ​​de instância interna,
mas expõem métodos apenas para o mundo exterior. Como o método <code>length</code> não espera argumentos e é chamado sem os parênteses opcionais,
parece que referência uma variável. Na verdade, isso é intencional. Métodos como estes são chamados para atribuir métodos de acesso, e
dizemos que o objeto da <code>mensage</code> tem um atributo de <code>lenght</code>. Como veremos, é possível que o objeto de <code>mensage</code>
para definir um método chamado <code>length=</code>. Se este método espera um único argumento, então é um método setter do atributo e
Ruby invoca em resposta a atribuição. Se um tal método é definido, então estas duas linhas de código seria tanto chamar o mesmo método:</p>

<p><code>ruby Length
message.length=(3) # invocação do método tradicional
message.length = 3 # invocação Método como a atribuição
</code></p>

<p>Agora, considere a seguinte linha de código, assumindo que uma variável contém um <code>Array</code>:</p>

<p><code>ruby Array
a[0]
</code></p>

<p>Você pode pensar novamente que este é um tipo especial de variável de referência, onde a variável em questão é na verdade um elemento do
<code>Array</code>. Novamente, no entanto, esta é invocação do método. O intérprete Ruby converte o acesso ao <code>Array</code> para isso:</p>

<p><code>ruby Array
a.[](0)
</code></p>

<p>O acesso ao <code>Array</code> torna-se uma invocação do método chamado <code>[]</code>, com o índice do <code>Array</code> como seu
argumento. Esta sintaxe de acesso de <code>Array</code> não se limita a <code>Arrays</code>. Qualquer objeto é permitido para definir um
método chamado <code>[]</code>. Quando o objeto é "indexado", com o indix entre parênteses, os valores dentro dos parênteses será passado
para o método. Se o método <code>[]</code> é escrito para esperar três argumentos, então você deve colocar três expressões separados por
vírgula dentro dos colchetes.</p>

<p>Atribuição de <code>Arrays</code> também é feito através de invocação de método. Se o objeto o define um método chamado <code>[]=</code>, então a expressão <code>o[x] = y</code> torna-se <code>o.[] = (x, y)</code>, e a expressão <code>o[x, y] = z</code> se torna <code>o.[] = (x , y, z)</code>.</p>

<p>Muitos operadores do Ruby são definidos como métodos, e expressões como <code>x + y</code> são avaliados como <code>x.+(y)</code>, onde o
nome de método é <code>+</code>. O fato de que muitos dos operadores do Ruby são definidos como métodos que significa você pode redefinir
esses operadores na sua próprias classes.</p>

<p>Agora, vamos considerar esta expressão muito simples:</p>

<p><code>ruby Ruby
x
</code></p>

<p>Se uma variável x nomeada existe (Isto é, se o interpretador Ruby tem visto uma atribuição a x), então esta é uma variável de referência.
Se nenhuma variável existe, então esta é uma invocação do método x, sem argumentos.</p>

<p>A palavra <code>super</code> em Ruby é um tipo especial de invocação de método. Esta palavra é usada ao criar uma subclasse de outra
classe. Por si só, <code>super</code> passa os argumentos do método corrente para o método com o mesmo nome na superclasse. Ele também
pode ser usado como se fosse realmente o nome de um método e pode ser seguido por uma lista de argumentos arbitrários. A palavra-chave
<code>super</code> é abordada em detalhes no Aumentando Comportamento por encadeamento.</p>

<p>Até a Proxima... :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variáveis ​​não inicializadas]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas/"/>
    <updated>2012-06-02T11:30:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Variáveis ​​não inicializadas</h1>


<p>Em geral, você deve sempre atribuir um valor para, ou inicializar as variáveis ​​antes de usá-las em expressões. Em algumas circunstâncias,
no entanto, Ruby lhe permitirá utilizar variáveis ​​que ainda não foram inicializadas. As regras são diferentes para diferentes tipos de variáveis:</p>

<h4>Variáveis ​​de classe</h4>


<pre><code>Variáveis ​​de classe deve sempre ter um valor atribuído a elas antes que serem utilizadas. Ruby levanta uma NameError se 
referir a uma variável de classe à qual nenhum valor foi atribuído.
</code></pre>

<h4>Variáveis ​​de instância</h4>


<pre><code>Se você se referir a uma variável de instância não inicializada, Ruby retorna nil. Considera-se má programação de 
contar com esse comportamento, no entanto. Ruby vai emitir um aviso sobre a variável não inicializada se você executá-la 
com a opção -w.
</code></pre>

<h4>As variáveis ​​globais</h4>


<pre><code>Variáveis ​​globais não inicializadas são como o exemplo de variáveis não inicializadas: elas igualam a nil, mas mostra 
um aviso quando o Ruby é executado com o flag do -w.
</code></pre>

<h4>As variáveis ​​locais</h4>


<pre><code>Este caso é mais complicado que os outros, porque variáveis locais ​​não têm um caractere de pontuação como um prefixo. 
Este significa que variáveis ​​locais referênciam olhando apenas como uma invocação de método de expressões. Se o 
interpretador Ruby tem visto uma atribuição de uma variável local, ele sabe que é uma variável e não um método, 
e pode retornar o valor da variável. Se não tiver havido nenhuma atribuição, então o Ruby trata a expressão como uma 
invocação de método. Se nenhum método com esse nome existe, Ruby levanta um NameError.

Em geral, portanto, a tentativa de usar uma variável local antes de ter sido inicializada resulta em um erro. Existe 
uma peculiaridade, uma variável passa a existir quando o interpretador Ruby vê uma expressão de atribuição para essa 
variável. Este é o caso, mesmo se essa atribuição não é realmente executada. A variável que existe, mas não foi 
atribuído um valor, é dado o valor nulo   como padrão. Por exemplo:
</code></pre>

<p><code>ruby Variaveis
a = 0.0 if false # atribuição Isso nunca é executado
puts a # Imprime nulo: a variável existe mas não é atribuída
puts b # NameError: nenhuma variável ou método chamado existe b
</code></p>

<p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html">Variaveis Ruby 1.9.2</a></p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variáveis de Referência]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia/"/>
    <updated>2012-06-01T13:16:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis de Referência</p>




<h1>Variáveis de Referência</h1>


<p>Uma variável é simplesmente um nome para um valor. As variáveis ​​são criadas e os valores que lhes são atribuídos por expressões
de atribuição. Quando o nome de uma variável aparece num programa em qualquer lugar que não seja o lado esquerdo de uma atribuição, é uma
variável de referência à expressão e avaliado como o valor da variável:</p>

<p><code>ruby Referência
one = 1.0 # Esta é uma atribuição de expressão
one # Essa referência de expressão da variável, que imprimi 1.0
</code></p>

<p>Existem quatro tipos de variáveis ​​em Ruby, e regras <a href="http://pt.wikipedia.org/wiki/Item_lexical">lexicais</a> para governar seus nomes. Variáveis que começam com $ são variáveis ​​globais, visível ao longo de um programa Ruby. Variáveis ​​que começam com @ e @@ são
variáveis ​​de instância e variáveis ​​de classe, usado em programação orientada a objeto. E as variáveis ​​cujos nomes começam com um sublinhado
ou uma letra minúscula são variáveis ​​locais, definidas apenas dentro do atual método ou bloco.</p>

<p>Variáveis ​​sempre são simples, nomes não qualificados. Se um . ou :: aparece em uma expressão, em seguida, que a expressão é ou um
uma referência a uma constante ou uma invocação de método. Por exemplo, Math::PI é uma referência a uma constante, e a expressão
item.preco é uma invocação do método chamado preco (preço) sobre o valor realizado pela variável item.</p>

<p>O interpretador Ruby predefine um número de variáveis ​​globais quando ele é iniciado.</p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
</feed>
