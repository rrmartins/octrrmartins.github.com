<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby 1.9 | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/ruby-1-9/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-06-02T11:53:28-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Variáveis ​​não inicializadas]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas/"/>
    <updated>2012-06-02T11:30:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Variáveis ​​não inicializadas</h1>


<p>Em geral, você deve sempre atribuir um valor para, ou inicializar as variáveis ​​antes de usá-las em expressões. Em algumas circunstâncias,
no entanto, Ruby lhe permitirá utilizar variáveis ​​que ainda não foram inicializadas. As regras são diferentes para diferentes tipos de variáveis:</p>

<h4>Variáveis ​​de classe</h4>


<pre><code>Variáveis ​​de classe deve sempre ter um valor atribuído a elas antes que serem utilizadas. Ruby levanta uma NameError se 
referir a uma variável de classe à qual nenhum valor foi atribuído.
</code></pre>

<h4>Variáveis ​​de instância</h4>


<pre><code>Se você se referir a uma variável de instância não inicializada, Ruby retorna nil. Considera-se má programação de 
contar com esse comportamento, no entanto. Ruby vai emitir um aviso sobre a variável não inicializada se você executá-la 
com a opção -w.
</code></pre>

<h4>As variáveis ​​globais</h4>


<pre><code>Variáveis ​​globais não inicializadas são como o exemplo de variáveis não inicializadas: elas igualam a nil, mas mostra 
um aviso quando o Ruby é executado com o flag do -w.
</code></pre>

<h4>As variáveis ​​locais</h4>


<pre><code>Este caso é mais complicado que os outros, porque variáveis locais ​​não têm um caractere de pontuação como um prefixo. 
Este significa que variáveis ​​locais referênciam olhando apenas como uma invocação de método de expressões. Se o 
interpretador Ruby tem visto uma atribuição de uma variável local, ele sabe que é uma variável e não um método, 
e pode retornar o valor da variável. Se não tiver havido nenhuma atribuição, então o Ruby trata a expressão como uma 
invocação de método. Se nenhum método com esse nome existe, Ruby levanta um NameError.

Em geral, portanto, a tentativa de usar uma variável local antes de ter sido inicializada resulta em um erro. Existe 
uma peculiaridade, uma variável passa a existir quando o interpretador Ruby vê uma expressão de atribuição para essa 
variável. Este é o caso, mesmo se essa atribuição não é realmente executada. A variável que existe, mas não foi 
atribuído um valor, é dado o valor nulo   como padrão. Por exemplo:
</code></pre>

<p><code>ruby Variaveis
a = 0.0 if false # atribuição Isso nunca é executado
puts a # Imprime nulo: a variável existe mas não é atribuída
puts b # NameError: nenhuma variável ou método chamado existe b
</code></p>

<p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html">Variaveis Ruby 1.9.2</a></p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variáveis de Referência]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia/"/>
    <updated>2012-06-01T13:16:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis de Referência</p>




<h1>Variáveis de Referência</h1>


<p>Uma variável é simplesmente um nome para um valor. As variáveis ​​são criadas e os valores que lhes são atribuídos por expressões
de atribuição. Quando o nome de uma variável aparece num programa em qualquer lugar que não seja o lado esquerdo de uma atribuição, é uma
variável de referência à expressão e avaliado como o valor da variável:</p>

<p><code>ruby Referência
one = 1.0 # Esta é uma atribuição de expressão
one # Essa referência de expressão da variável, que imprimi 1.0
</code></p>

<p>Existem quatro tipos de variáveis ​​em Ruby, e regras <a href="http://pt.wikipedia.org/wiki/Item_lexical">lexicais</a> para governar seus nomes. Variáveis que começam com $ são variáveis ​​globais, visível ao longo de um programa Ruby. Variáveis ​​que começam com @ e @@ são
variáveis ​​de instância e variáveis ​​de classe, usado em programação orientada a objeto. E as variáveis ​​cujos nomes começam com um sublinhado
ou uma letra minúscula são variáveis ​​locais, definidas apenas dentro do atual método ou bloco.</p>

<p>Variáveis ​​sempre são simples, nomes não qualificados. Se um . ou :: aparece em uma expressão, em seguida, que a expressão é ou um
uma referência a uma constante ou uma invocação de método. Por exemplo, Math::PI é uma referência a uma constante, e a expressão
item.preco é uma invocação do método chamado preco (preço) sobre o valor realizado pela variável item.</p>

<p>O interpretador Ruby predefine um número de variáveis ​​globais quando ele é iniciado.</p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Literais e Palavras-Chaves Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais/"/>
    <updated>2012-05-27T12:15:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Literais e Plavras-chaves literais</p>




<h1>Literais e Plavras-chaves literais</h1>


<p>Literais são valores como 1.0, "Hello world", e [] que são incorporados diretamente em seu texto do programa.</p>

<p>É interessante notar que muitos literais, tais como números, são as principais expressões - as expressões mais simples possíveis não
compostas de expressões simples. Literais, tais como Array e literais de hash e strings duplas citadas que usam interpolação, incluem
sub-expressões e são, portanto, expressões não primárias.</p>

<p>Determinadas palavras-chave em Ruby são expressões primárias e podem ser considerados palavras-chave literais ou formas especializadas
de referência da variável:</p>

<pre><code>nil            -&gt;   Avalia o valor nulo, de NilClass classe.
true           -&gt;   Avalia-se à instância singleton da Classe TrueClass, que um objeto representa o valor booleano 
                    verdadeiro.
false          -&gt;   Avalia-se à instância singleton da Classe FalseClass, que um objeto representa os valores booleanos
                    falsos.
self           -&gt;   Auto avalia o objeto atual.
__FILE__       -&gt;   Avalia a uma string que nomeia o arquivo que o Ruby Intérprete (IRB) está em execução. Isto pode ser
                    útil em erro de mensagens.
__LINE__       -&gt;   Avalia como um inteiro que especifica o número da linha dentro da linha do código atual do __FILE__.
__ENCODING__   -&gt;   Avalia a um objeto Encoding que especifica a codificação do arquivo atual. (Ruby 1.9 apenas.)
</code></pre>

<p>É isso ai galera, até o proximo post.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Expressões e Operadores - O inicio]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/23/aexpressoes-e-operadores-o-inicio/"/>
    <updated>2012-05-23T07:22:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/23/aexpressoes-e-operadores-o-inicio</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Expressões e Operadores</p>




<h1>Expressões e Operadores</h1>


<p>Uma expressão é um pedaço de código Ruby que o interpretador Ruby pode avaliar para produzir um valor. Aqui estão alguns exemplos
de expressões:</p>

<p><code>ruby Expressões
2 # Um literal numérico
x # Uma referência variável local
Math.sqrt(2) # invocação Um método
x = Math.sqrt(2) # Atribuição
x * x # Multiplicação com o operador *
</code>
Como você pode ver, expressões primárias, tal como literais, referências variáveis, e invocações de método podem ser combinadas em
expressões maiores com operadores, tais como o operador de atribuição e o operador de multiplicação.</p>

<p>Muitas linguagens de programação diferenciam entre expressões de baixo nível e alto nível de declarações, tais como condicionais e loops.
Nestas linguagens, as declarações de controlar o fluxo de um programa, mas eles não têm valores. Eles são executados, em vez de avaliados.
Em Ruby, não há distinção clara entre as afirmações e expressões; tudo em Ruby, incluindo a definição de classe e de método, pode ser
avaliado como uma expressão e retorna um valor. É ainda útil, no entanto, diferenciam sintaxe normalmente usada como expressões de sintaxe
tipicamente usadas ​​como indicações.</p>

<p>Até mais amigos.. ainda vem muito conteudo legal com por ai.. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part VI]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-vi/"/>
    <updated>2012-05-20T19:08:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-vi</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Copiando objetos</h3>


<p>A classe Object define dois métodos estreitamente relacionados para copiar objetos. Tanto o clone e como o dup retornar uma cópia
superficial do objeto em que eles são chamados. Se o objeto copiado inclui o estado interno que se refere a outros objetos, apenas as
referências a objetos são copiadas, não os próprios objetos referenciados.</p>

<p>Se o objecto a ser copiado define um método initialize_copy, em seguida, clone e dup simplesmente alocam uma nova instância vazia da
classe e chamam o método initialize_copy nesta instância vazio. O objeto a ser copiado é passado como um argumento, para este "Construtor
de cópias", podendo inicializar a cópia. Para exemplo, o método initialize_copy pode copiar recursivamente os dados internos de um objeto
para que o objeto resultante, não sendo uma simples cópia superficial do original.</p>

<p>Classes também podem substituir os métodos clone e dup diretamente para produzir qualquer tipo de copia que eles desejam.</p>

<p>Há duas diferenças importantes entre os métodos clone e dup definidos pelo objeto. Primeiro, as cópias do clone tanto o congelado e
quanto o estado contaminado(definido em breve) de um objeto, enquanto dup apenas copia o estado contaminado, chamando dup sobre um objeto
congelado retorna uma cópia descongelada. Em segundo lugar, clone cópia quaisquer métodos singleton do objeto, enquanto que dup não.</p>

<h3>Objetos Empacotamento</h3>


<p>Você pode salvar o estado de um objeto passando para a classe <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html">Marshal</a>, com o método <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-dump">dump</a>. Se você passar um objeto de fluxo de I/O como o segundo argumento, escreve o estado do objeto Marshal.dump (e, de forma recursiva, quaisquer objetos que referencia) para esse fluxo.
Caso contrário, ele simplesmente retorna o estado codificado como uma string binária.</p>

<p>Para restaurar um objeto empacotado, passe uma string ou um fluxo de contendo I/O do objeto de <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-load">Marshal.load</a>.</p>

<p>O empacotamento de um objeto é uma maneira muito simples para salvar seu estado para uma utilização posterior, e estes métodos podem ser
usados ​​para fornecer um arquivo automático no formato de programas Ruby. Note, no entanto, que o formato binário usado por <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-dump">Marshal.dump</a> e <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-load">Marshal.load</a> é dependente da versão, e nas mais recentes versões do Ruby não são garantidos para ser capaz de ler
objetos empacotados escritos por versões mais antigas do Ruby.</p>

<p>Outro uso para Marshal.dump e Marshal.load é criar cópias de profundidade de objetos:</p>

<p><code>ruby Marshal
def deepcopy(o)
  Marshal.load (Marshal.dump (o))
end
</code></p>

<p>Note que os arquivos de fluxo I/O, bem como o método e os objetos Binding, são dinâmicos demais para ser empacotado, não haveria nenhuma
maneira confiável para restaurar seu Estado.</p>

<p>YAML ("YAML não é Markup Language") é uma alternativa comumente utilizada para o módulo Marshal que depósita objetos (e carrega objetos) a
partir de um texto com formato legível. É na biblioteca padrão, e você deve exigir usá-lo 'yaml'.</p>

<h3>Objetos de congelamento</h3>


<p>Qualquer objeto pode ser congelado chamando seu método de freeze. A objeto congelado torna imutável e nenhum de seu estado interno pode
ser mudado, e uma tentativa de chamar qualquer um dos seus métodos de falha de modificadores:</p>

<p><code>ruby  Freeze
s = "gelo" # String são objetos mutáveis
s.freeze # Faça desta cadeia imutável
s.frozen? # Verdade: ele foi congelado
s.upcase! # TypeError: não pode modificar cadeia de congelados
s[0] = "ni" # TypeError: não pode modificar cadeia de congelados
</code></p>

<p>Congelar um objeto de classe impede a adição de quaisquer métodos para essa classe.</p>

<p>Você pode verificar se um objeto é congelado com o método frozen?. Uma vez congelado, não há maneira para "descongelar" um objeto. Se
você copiar um objeto congelado com clone, a cópia também será congelada. Se você copiar um objeto congelado com dup, no entanto, a
cópia não será congelada.</p>

<h3>Objetos contaminados e não confiáveis</h3>


<p>Aplicações Web deve muitas vezes acompanhar de dados de entrada, derivados de não confiáveis do usuário para evitar ataques de injeção
de SQL e riscos de segurança semelhantes. Ruby oferece uma solução simples para esse problema: qualquer objeto pode ser marcado como
contaminado, chamando seu método taint. Depois que um objeto está contaminado, qualquer objetos derivado, também será contaminado. O
taint de um objeto pode ser testado com o método tainted? método:</p>

<p><code>ruby taint
s = "não confiáveis" # Os objetos são normalmente não viciada
s.taint # Marcar como não confiável objeto contaminado
s.tainted? # Verdade: ele está contaminado
s.upcase.tainted? # Verdade: objetos derivados estão contaminados
s[3,4].tainted? # Verdade: substrings estão contaminados
</code></p>

<p>De entrada, tais como usuário de linha de comando argumentos, ambiente de variáveis, e seqüências de leitura com gets, são automaticamente
contaminados. Quando a variavel global $SAFE é definida com um valor maior que zero, Ruby restringe vários métodos embutidos que eles não
vão trabalhar com dados adulterados. Cópias de objetos contaminados feitos com clone e dup permanecem contaminados. Um objeto contaminado
pode ser descontaminado com o método untaint. Você só deve fazer isso, claro, se você examinar o objeto e está convencido de que não apresenta riscos de segurança.</p>

<p>Em Ruby 1.9, os objectos podem não ser confiável para além de ser manchado. Os métodos untrusted?, untrust, e trust verificam e definem a
lealdade de um objeto. Código não confiável cria objetos não confiáveis, objetos contaminados e não é permitido para modificar objetos
confiáveis.</p>

<p>Boa noite amigos... até a proxima..</p>
]]></content>
  </entry>
  
</feed>
