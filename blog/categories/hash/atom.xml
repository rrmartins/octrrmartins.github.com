<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

<<<<<<< HEAD
  <title><![CDATA[Category: Hash | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/hash/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-08-09T01:16:17-03:00</updated>
  <id>http://rrmartins.github.com/</id>
=======
  <title><![CDATA[Category: hash | Rodrigo Martins]]></title>
  <link href="http://rrmartins.com/blog/categories/hash/atom.xml" rel="self"/>
  <link href="http://rrmartins.com/"/>
<<<<<<< HEAD
  <updated>2015-09-29T11:44:19-03:00</updated>
=======
  <updated>2015-09-21T15:34:22-03:00</updated>
>>>>>>> f0fad74ab02c4e5669e277aa283faa25f065f1cb
  <id>http://rrmartins.com/</id>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
<<<<<<< HEAD
    <title type="html"><![CDATA[Invocações de método]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/invocacoes-de-metodo/"/>
    <updated>2012-06-02T15:36:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/invocacoes-de-metodo</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Invocações de método</h1>


<p>Uma expressão de invocação de método tem quatro partes:</p>

<ul>
<li><p>Uma expressão arbitrária cujo valor é o objeto no qual o método é chamado. Esta expressão é seguido por . ou :: para separá-lo a partir
do nome do método que se segue. A expressão e o separador são opcionais; se omitido, o método é invocada em si mesmo.</p></li>
<li><p>O nome do método a ser invocado. Este é o único pedaço exigido de uma expressão chamada de método.</p></li>
<li><p>Valores com o argumento passado para o método. A lista de argumentos podem ser colocados entre parênteses, mas estes são geralmente
opcionais. Se há mais de um argumento, eles são separados uns dos outros com vírgulas. O número e tipo de argumentos necessários
dependem da definição do método. Alguns métodos podem ser chamodos sem argumentos.</p></li>
<li><p>Um bloco opcional de código delimitado por chaves ou por um par <code>do/end</code>. O método pode invocar esse código usando a palavra-chave de
 <code>yield</code>. Esta capacidade de associar código arbitrário com qualquer invocação de método é a base para métodos poderosos em Ruby.</p></li>
</ul>


<p>Um nome do método é normalmente separado do objeto sobre o qual é chamado com um <code>..</code>, e com o <code>::</code>, que também é permitido, mas é raramente
usado porque pode fazer invocações de método parecem mais com referênciar constantes expressões.</p>

<p>Quando o interpretador Ruby tem o nome de um método e um objeto em que deve ser invocado, ele encontra a definição adequada do método
chamado usando um processo conhecido como "método de pesquisa" ou "resolução de nome do método." Os detalhes não são importantes aqui,
mas eles são explicados completamente no método de pesquisa.</p>

<p>O valor de uma invocação expressão de método é o valor da expressão avaliada pelo último método no corpo do código. Aqui, no entanto, são
alguns exemplos de invocações de método:</p>

<p><code>ruby Ruby
puts "Olá mundo" # "puts" invocado em auto, com uma seqüência de arg
Math.sqrt(2) # "sqrt" invocado em Matemática objeto com uma arg
message.length # "comprimento" invocado em mensagem objeto; não args
a.each{|x| p x} # "cada" chamado em um objeto, com um bloco associado
</code></p>

<p>Um dos exemplos do método de invocação mostradas anteriormente foi <code>message.length</code>. Você pode ser tentado a pensar-lo como uma variável
de expressão de referência, avaliando para o valor do comprimento da variável do objeto mensage. Este não é o caso, no entanto, Ruby tem
um modelo de programação muito orientada a objetos: objetos em Ruby podem encapsular qualquer número de variáveis ​​de instância interna,
mas expõem métodos apenas para o mundo exterior. Como o método <code>length</code> não espera argumentos e é chamado sem os parênteses opcionais,
parece que referência uma variável. Na verdade, isso é intencional. Métodos como estes são chamados para atribuir métodos de acesso, e
dizemos que o objeto da <code>mensage</code> tem um atributo de <code>lenght</code>. Como veremos, é possível que o objeto de <code>mensage</code>
para definir um método chamado <code>length=</code>. Se este método espera um único argumento, então é um método setter do atributo e
Ruby invoca em resposta a atribuição. Se um tal método é definido, então estas duas linhas de código seria tanto chamar o mesmo método:</p>

<p><code>ruby Length
message.length=(3) # invocação do método tradicional
message.length = 3 # invocação Método como a atribuição
</code></p>

<p>Agora, considere a seguinte linha de código, assumindo que uma variável contém um <code>Array</code>:</p>

<p><code>ruby Array
a[0]
</code></p>

<p>Você pode pensar novamente que este é um tipo especial de variável de referência, onde a variável em questão é na verdade um elemento do
<code>Array</code>. Novamente, no entanto, esta é invocação do método. O intérprete Ruby converte o acesso ao <code>Array</code> para isso:</p>

<p><code>ruby Array
a.[](0)
</code></p>

<p>O acesso ao <code>Array</code> torna-se uma invocação do método chamado <code>[]</code>, com o índice do <code>Array</code> como seu
argumento. Esta sintaxe de acesso de <code>Array</code> não se limita a <code>Arrays</code>. Qualquer objeto é permitido para definir um
método chamado <code>[]</code>. Quando o objeto é "indexado", com o indix entre parênteses, os valores dentro dos parênteses será passado
para o método. Se o método <code>[]</code> é escrito para esperar três argumentos, então você deve colocar três expressões separados por
vírgula dentro dos colchetes.</p>

<p>Atribuição de <code>Arrays</code> também é feito através de invocação de método. Se o objeto o define um método chamado <code>[]=</code>, então a expressão <code>o[x] = y</code> torna-se <code>o.[] = (x, y)</code>, e a expressão <code>o[x, y] = z</code> se torna <code>o.[] = (x , y, z)</code>.</p>

<p>Muitos operadores do Ruby são definidos como métodos, e expressões como <code>x + y</code> são avaliados como <code>x.+(y)</code>, onde o
nome de método é <code>+</code>. O fato de que muitos dos operadores do Ruby são definidos como métodos que significa você pode redefinir
esses operadores na sua próprias classes.</p>

<p>Agora, vamos considerar esta expressão muito simples:</p>

<p><code>ruby Ruby
x
</code></p>

<p>Se uma variável x nomeada existe (Isto é, se o interpretador Ruby tem visto uma atribuição a x), então esta é uma variável de referência.
Se nenhuma variável existe, então esta é uma invocação do método x, sem argumentos.</p>

<p>A palavra <code>super</code> em Ruby é um tipo especial de invocação de método. Esta palavra é usada ao criar uma subclasse de outra
classe. Por si só, <code>super</code> passa os argumentos do método corrente para o método com o mesmo nome na superclasse. Ele também
pode ser usado como se fosse realmente o nome de um método e pode ser seguido por uma lista de argumentos arbitrários. A palavra-chave
<code>super</code> é abordada em detalhes no Aumentando Comportamento por encadeamento.</p>

<p>Até a Proxima... :)</p>
=======
    <title type="html"><![CDATA[Threads e Concorrência - Exemplos de Threads - Part IV - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/11/04/threads-e-concorrencia-exemplos-de-threads-part-iv-number-ruby-1-dot-9/"/>
    <updated>2012-11-04T09:20:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/11/04/threads-e-concorrencia-exemplos-de-threads-part-iv-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Exemplos de Threads</strong>&hellip;</p>

<h4>Exemplos de Threads</h4>

<p>Agora que já passamos alguns post falando do modelo <code>Thread</code> e da API de <code>Thread</code> em Ruby, vamos dar uma olhada em alguns
exemplos reais de vários códigos de <code>threads</code>.</p>

<h3>Leitura de arquivos simultaneamente</h3>

<p>O uso mais comum de <code>threads</code> de Ruby é em programas que são IO. Eles permitem que os programas mantenham ocupado até
mesmo enquanto espera por alguma entrada do usuário, o sistema de arquivos, ou da rede. A seguir de código, por exemplo,
define um método <code>conread</code> (para leitura simultânea) que leva uma série de nomes de arquivos e retorna um mapa de <code>hash</code>
com esses nomes para o conteúdo desses arquivos. Ele usa <code>thread</code> para ler esses arquivos ao mesmo tempo, e é realmente
destinado a ser utilizado com o módulo <code>open-uri</code>, que permite que as URL&rsquo;s <code>HTTP</code> e <code>FTP</code> possam ser abertas com
<code>Kernel.open</code> e ler como se fossem arquivos:</p>

<pre><code class="ruby Lendo arquivos">
# Ler arquivos simultaneamente. Use com o módulo "open-uri" para buscar URLs.
# Passe uma matriz de nomes de arquivos. Retorna um mapa de nomes de arquivos de hash para o conteúdo.
def conread(filenames)
  h = {}            # hash vazio de resultados

  # Crie uma linha para cada arquivo
  filenames.each do |filename|      # Para cada arquivo chamado
    h[filename] = Thread.new do     # Criar um fio, mapa para filename
      open(filename) {|f| f.read }  # Abra e leia o arquivo
    end                             # valor da linha é o conteúdo do arquivo
  end

  # Percorre o hash, à espera de cada thread para completar.
  # Substitua a thread no hash com o seu valor (o conteúdo de arquivo)
  h.each_pair do |filename, thread|
    begin
      h[filename] = thread.value    # Mapa de nomes ao conteúdo do arquivo
    rescue
      h[filename] = $!              # Ou a exceção levantada
    end
  end
end
</code></pre>

<h3>Servidor A Multithreads</h3>

<p>Outra, quase canônico caso, o uso de <code>threads</code> é para escrever servidores que podem comunicar com mais do que um cliente
de cada vez. Vimos como fazer isto utilizando multiplexagem com Kernel.select, mas um pouco mais simples (Embora
possivelmente menos escalável) solução usa <code>threads</code>:</p>

<pre><code class="ruby Servidor a Multithreads">require 'socket'

# Este método espera um socket ligado a um cliente.
# Ele lê as linhas do cliente, inverte-los e envia-los de volta.
# Múltiplas Threads podem executar este método, ao mesmo tempo.
def handle_client(c)
  while true
    input = c.gets.chop     # Ler uma linha de entrada do cliente
    break if !input         # sai se tem muitas entradas
    break if input=="quit"  # ou se o cliente pede
    c.puts(input.reverse)   # Caso contrário, responde ao cliente.
    c.flush                 # Força a saída para fora
  end
  c.close                   # Fecha o socket cliente
end

server = TCPServer.open(2000) # Ouve na porta 2000

while true                    # Laço de servidores para sempre
  client = server.accept      # Espere um cliente para conectar
  Thread.start(client) do |c| # Inicia uma nova thread
    handle_client(c)          # E Lida com o clinete nessa Thread
  end
end
</code></pre>

<h3>Iteradores simultâneas</h3>

<p>Embora tarefas IO são o caso de uso típico para <code>threads</code> de Ruby, eles não se restringem aos que usam. O código a seguir
adiciona um método <code>conmap</code> (por mapa concorrente) para o modulo <code>Enumerável</code>. Ele funciona como mapa, mas processa cada
elemento da matriz de entrada com uma distinta <code>Thread</code>:</p>

<pre><code class="ruby Iterador Simultâneo">module Enumerable           # Abre o módulo Enumerable
  def conmap(&amp;block)        # Define um novo método que espera um block
    threads = []            # Começa com uma matriz vazia de threads
    self.each do |item|     # Para cada item enumerable
      # Chama o bloco em uma nova Thread, e lembra da Thread
      threads &lt;&lt; Thread.new { block.call(item) }
    end
    # Agora mapea o conjunto de Threads para os seus valores
    threads.map {|t| t.value } # E retorna a matriz de valores
  end
end
</code></pre>

<p>E aqui está uma versão concorrente similar do iterador de cada um:</p>

<pre><code class="ruby Módulo Enumerable">module Enumerable
  def concurrently
    map {|item| Thread.new { yield item }}.each {|t| t.join }
  end
end
</code></pre>

<p>O código é sucinto e desafiador: se você pode fazer sentido, você está bem em seu caminho para o domínio da sintaxe de
Ruby e iteradores Ruby.</p>

<p>Lembre-se que no Ruby 1.9, iteradores padrões que não são passado um bloco retorna um objeto enumerador. Isto significa
que, dado o método <code>concurrently</code> definido mais cedo e um objeto <code>Hash h</code>, podemos escrever:</p>

<pre><code class="ruby Método Concurrently">h.each_pair.concurrently {|*pair| process(pair)}
</code></pre>

<p>Até o proximo amigos!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Threads e Concorrência - Escalando Threads - Part III - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-escalando-threads-part-iii-number-ruby-1-dot-9/"/>
    <updated>2012-10-28T15:04:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-escalando-threads-part-iii-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Escalando Threads</strong>&hellip;</p>

<h2>Threads e Concorrência</h2>

<h3>Escalando Threads</h3>

<p>Intérpretes do Ruby(irb), muitas vezes têm mais <code>threads</code> para executar do que há CPU tem disponível para executá-los. Quando
o processamento paralelo verdadeiro não é possível, é simulado através da partilha de uma CPU entre <code>threads</code>. O processo para
a partilha de uma CPU entre as <code>threads</code> é chamado de escalonamento de <code>threads</code>. Dependendo da implementação e plataforma,
agendamento de <code>threads</code> pode ser feito pelo Intérprete do Ruby(irb), ou pode ser tratado pelo sistema operacional.</p>

<h4>Prioridades da Thread</h4>

<p>O primeiro fator que afeta o agendamento de <code>threads</code> é prioridades de <code>thread</code>: com a alta prioridade da <code>thread</code> são
agendadas antes de baixa prioridade de <code>thread</code>. Mais precisamente, uma <code>thread</code> só vai ficar o tempo de CPU, se não houver
maior prioridade de <code>thread</code> aguardando para ser executada.</p>

<p>Definir e consultar a prioridade de um objeto Ruby <code>Thread</code> com <code>priority=</code> e <code>priority</code>. Note-se que não há nenhuma maneira
de definir a prioridade de uma <code>thread</code> antes que ela comece a funcionar. Uma <code>thread</code> pode, no entanto, aumentar ou diminuir
sua própria prioridade como a primeira ação que toma.</p>

<p>Uma <code>thread</code> recém-criada começa com a mesma prioridade que a <code>thread</code> que a criou. A <code>thread</code> principal começa na prioridade
 0.</p>

<p>Como muitos aspectos de <code>threading</code>, prioridades de <code>threads</code> são depende da implementação do <code>Ruby</code> e do subjacente sistema
operacional. No Linux, por exemplo, <code>threads</code> não privilegiadas não pode ter as suas prioridades levantada ou abaixada. Assim,
no Ruby 1.9 (que usa <code>threads</code> nativas) no <code>Linux</code>, a definição de prioridades de <code>Thread</code> é ignorada.</p>

<h4>Aquisição de Thread e Thread.pass</h4>

<p>Quando várias <code>Threads</code> com a mesma prioridade precisam compartilhar a CPU, cabe a <code>thread</code> programada para decidir quando e
por quanto tempo, cada <code>thread</code> é executada. Alguns escalonadores são antecipadas, o que significa que elas permitem a <code>thread</code>
a ser executada apenas por um determinado período de tempo antes de permitir outra <code>thread</code> da mesma prioridade para ser
executada. Outros programadores não são preempção: uma vez que uma <code>thread</code> começa a correr, ela continua funcionando a menos
que durma, blocos para I/O, ou uma <code>thread</code> de maior prioridade acorda.</p>

<p>Se uma longa linha de computação liga (ou seja, aquela que nunca faz bloqueio para I/O) está em execução em um agendador
não preemptivo, ela vai &ldquo;morrer de fome&rdquo; as outras <code>threads</code> com a mesma prioridade, e elas nunca tem a chance de correr.
Para evitar esse problema, de longa duração <code>compute-bound</code> <code>threads</code> devem chamar periodicamente <code>Thread.pass</code> para pedir o
programador para produzir a CPU para outra <code>thread</code>.</p>

<p>Até a proxima amigos! :D</p>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
]]></content>
  </entry>
  
  <entry>
<<<<<<< HEAD
    <title type="html"><![CDATA[Variáveis ​​não inicializadas]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas/"/>
    <updated>2012-06-02T11:30:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Variáveis ​​não inicializadas</h1>


<p>Em geral, você deve sempre atribuir um valor para, ou inicializar as variáveis ​​antes de usá-las em expressões. Em algumas circunstâncias,
no entanto, Ruby lhe permitirá utilizar variáveis ​​que ainda não foram inicializadas. As regras são diferentes para diferentes tipos de variáveis:</p>

<h4>Variáveis ​​de classe</h4>


<pre><code>Variáveis ​​de classe deve sempre ter um valor atribuído a elas antes que serem utilizadas. Ruby levanta uma NameError se 
referir a uma variável de classe à qual nenhum valor foi atribuído.
</code></pre>

<h4>Variáveis ​​de instância</h4>


<pre><code>Se você se referir a uma variável de instância não inicializada, Ruby retorna nil. Considera-se má programação de 
contar com esse comportamento, no entanto. Ruby vai emitir um aviso sobre a variável não inicializada se você executá-la 
com a opção -w.
</code></pre>

<h4>As variáveis ​​globais</h4>


<pre><code>Variáveis ​​globais não inicializadas são como o exemplo de variáveis não inicializadas: elas igualam a nil, mas mostra 
um aviso quando o Ruby é executado com o flag do -w.
</code></pre>

<h4>As variáveis ​​locais</h4>


<pre><code>Este caso é mais complicado que os outros, porque variáveis locais ​​não têm um caractere de pontuação como um prefixo. 
Este significa que variáveis ​​locais referênciam olhando apenas como uma invocação de método de expressões. Se o 
interpretador Ruby tem visto uma atribuição de uma variável local, ele sabe que é uma variável e não um método, 
e pode retornar o valor da variável. Se não tiver havido nenhuma atribuição, então o Ruby trata a expressão como uma 
invocação de método. Se nenhum método com esse nome existe, Ruby levanta um NameError.

Em geral, portanto, a tentativa de usar uma variável local antes de ter sido inicializada resulta em um erro. Existe 
uma peculiaridade, uma variável passa a existir quando o interpretador Ruby vê uma expressão de atribuição para essa 
variável. Este é o caso, mesmo se essa atribuição não é realmente executada. A variável que existe, mas não foi 
atribuído um valor, é dado o valor nulo   como padrão. Por exemplo:
</code></pre>

<p><code>ruby Variaveis
a = 0.0 if false # atribuição Isso nunca é executado
puts a # Imprime nulo: a variável existe mas não é atribuída
puts b # NameError: nenhuma variável ou método chamado existe b
</code></p>

<p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html">Variaveis Ruby 1.9.2</a></p>

<p>Até a próxima.. :)</p>
=======
    <title type="html"><![CDATA[Threads e Concorrência - Threads e Variáveis - Part II - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-threads-e-variaveis-part-ii-number-ruby-1-dot-9/"/>
    <updated>2012-10-28T14:53:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-threads-e-variaveis-part-ii-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Threads e Variáveis</strong>&hellip;</p>

<h2>Threads e Concorrência</h2>

<h3>Threads e Variáveis</h3>

<p>Uma das características-chave de <code>Thread</code> é que elas podem compartilhar o acesso a variáveis. Como <code>Threads</code> são definidas
por blocos, eles têm acesso a qualquer que seja variáveis ​​(variáveis ​​locais, variáveis ​​de instância, variáveis ​​globais e
 assim por diante) estão no escopo do bloco:</p>

<pre><code class="ruby Thread e Variavel">x = 0

t1 = Thread.new do
  # Esta Thread pode consultar e definir a variável x
end

t2 = Thread.new do
  # Esta Thread e também consulta e seta x
  # E pode consultar e definir T1 e T2 também.
end
</code></pre>

<p>Quando dois ou mais <code>Thread</code> de ler e escrever as mesmas variáveis ao mesmo tempo, elas devem tomar cuidado para que elas o
fazem corretamente. Nós vamos ter mais a dizer sobre isso quando consideramos a sincronização de <code>threads</code> abaixo.</p>

<h4>Thread-privadas variáveis</h4>

<p>Variáveis ​​definidas dentro do bloco de uma <code>thread</code> são particulares para essa <code>thread</code> e não são visíveis para qualquer
outra <code>thread</code>. Isto é simplesmente consequência de regras de variáveis de escopo ​​Ruby.</p>

<p>Muitas vezes queremos uma <code>Thread</code> tenha sua própria cópia privada de uma variável de modo a que o seu comportamento não se
altere se o valor do referido mude de variáveis. Considere o seguinte código, que tenta criar três tópicos que impressão (
respectivamente) os números 1, 2 e 3:</p>

<pre><code class="ruby Threads Privadas">n = 1
while n &lt;= 3
  Thread.new { puts n }
  n += 1
end
</code></pre>

<p>Em algumas circunstâncias, em algumas implementações, este código pode funcionar como o esperado e imprimir os números 1, 2 e
3. Em outras circunstâncias, ou em outras implementações, talvez não. É perfeitamente possível (se tópicos recentemente
criados não executa de imediato) para o código imprimir 4, 4, e 4, por exemplo. Cada thread lê uma cópia compartilhada da
variável n, e o valor ds mudanças de variáveis ​​como o loop é executado. O valor impresso pela <code>thread</code> depende de quando esse
segmento é executado em relação para a thread pai.</p>

<p>Para resolver este problema, passamos o valor atual de n para o método <code>Thread.new</code>, e atribuimos o atual valor da variável a
um parâmetro de bloco. Parâmetros de bloco são privados para o bloco, e este valor particular não é partilhado entre tópicos:</p>

<pre><code class="ruby Threads Privadas">n = 1
while n &lt;= 3
  # Obtem uma cópia privada do valor atual de n em x
  Thread.new(n) {|x| puts x }
  n += 1
end
</code></pre>

<p>Note-se que temos uma outra forma de resolver este problema é a utilização de um iterador em vez de um loop <code>while</code>. Neste
caso, o valor de <code>n</code> é modificado para particular para o bloco externo e nunca durante a execução desse bloco:</p>

<pre><code class="ruby Thread Privada com Interator">1.upto (3) {| n | Thread.new {puts n}}
</code></pre>

<h4>Variáveis ​​de Threads locais</h4>

<p>Algumas das variáveis especiais globais de Ruby são <code>thread</code> local: elas podem ter valores diferentes em <code>threads</code> diferentes.
<code>$SAFE</code> e <code>$~</code> são exemplos. Isto significa que, se dois <code>thread</code> estão realizando conconrrencia de expressão regular ao mesmo
tempo, eles vão ver diferentes valores de <code>$~</code>, e a realização de um jogo em um fio não irá interferir com os resultados de
um jogo executado na outra discussão.</p>

<p>A classe <code>Thread</code> provê <code>hash-like</code> como o comportamento. Ele define métodos de instância <code>[]</code> e <code>[]=</code> que permitem associar
valores arbitrários com qualquer símbolo. (Se você usar uma cadeia de caracteres em vez disso, ele será convertido em um
símbolo. Ao contrário <code>hashs</code> de verdade, a classe <code>Thread</code> só permite símbolos como chaves.) Os valores associados a estes
símbolos comportam-se como variáveis ​​de <code>Thread</code> locais. Eles não são privados como variáveis de block ​​locais porque qualquer
<code>Thread</code> pode pesquisar um valor em qualquer outra <code>Thread</code>. Mas eles não são variáveis partilhadas, uma vez que cada Thread
pode ter a sua própria cópia.</p>

<p>Como exemplo, suponha que nós criamos <code>thread</code> para download de arquivos de um servidor web. A <code>Thread</code> principal pode querer
monitorar o progresso do download. Para permitir isso, cada <code>Thread</code> pode fazer o seguinte:</p>

<pre><code class="ruby Thread de progresso">Thread.current[:progress] = bytes_received
</code></pre>

<p>A <code>Thread</code> principal poderia, então, determinar o total de bytes baixado com um código como este:</p>

<pre><code class="ruby Thread de progresso">total = 0
download_threads.each {|t| total += t[:progress] }
</code></pre>

<p>Junto com <code>[]</code> e <code>[]=</code>, <code>Thread</code> também define um método <code>key?</code> para testar se uma determinada chave existe para uma discussão
. Os métodos <code>keys</code> retorna uma matriz de símbolos que representam as chaves definidas para a <code>Thread</code>. Este código pode ser
melhor escrito como se segue, de modo que ela trabalhe de tópicos que ainda não começou a correr e não tenha definido a chave
:progress ainda:</p>

<pre><code class="ruby Thread de progresso">total = 0
download_threads.each {|t| total += t[:progress] if t.key?(:progress)}
</code></pre>

<p>Até a proxima galera! :D</p>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
]]></content>
  </entry>
  
  <entry>
<<<<<<< HEAD
    <title type="html"><![CDATA[Variáveis de Referência]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia/"/>
    <updated>2012-06-01T13:16:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis de Referência</p>




<h1>Variáveis de Referência</h1>


<p>Uma variável é simplesmente um nome para um valor. As variáveis ​​são criadas e os valores que lhes são atribuídos por expressões
de atribuição. Quando o nome de uma variável aparece num programa em qualquer lugar que não seja o lado esquerdo de uma atribuição, é uma
variável de referência à expressão e avaliado como o valor da variável:</p>

<p><code>ruby Referência
one = 1.0 # Esta é uma atribuição de expressão
one # Essa referência de expressão da variável, que imprimi 1.0
</code></p>

<p>Existem quatro tipos de variáveis ​​em Ruby, e regras <a href="http://pt.wikipedia.org/wiki/Item_lexical">lexicais</a> para governar seus nomes. Variáveis que começam com $ são variáveis ​​globais, visível ao longo de um programa Ruby. Variáveis ​​que começam com @ e @@ são
variáveis ​​de instância e variáveis ​​de classe, usado em programação orientada a objeto. E as variáveis ​​cujos nomes começam com um sublinhado
ou uma letra minúscula são variáveis ​​locais, definidas apenas dentro do atual método ou bloco.</p>

<p>Variáveis ​​sempre são simples, nomes não qualificados. Se um . ou :: aparece em uma expressão, em seguida, que a expressão é ou um
uma referência a uma constante ou uma invocação de método. Por exemplo, Math::PI é uma referência a uma constante, e a expressão
item.preco é uma invocação do método chamado preco (preço) sobre o valor realizado pela variável item.</p>

<p>O interpretador Ruby predefine um número de variáveis ​​globais quando ele é iniciado.</p>

<p>Até a próxima.. :)</p>
=======
    <title type="html"><![CDATA[Threads e Concorrência - Part I - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-part-i-number-ruby-1-dot-9/"/>
    <updated>2012-10-28T14:26:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-part-i-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Thread Lifecycle</strong>&hellip;</p>

<h2>Threads e Concorrência</h2>

<p>Programas tradicionais têm uma única &ldquo;thread de execução&rdquo;: as declarações ou instruções que compõem o programa são executadas
sequencialmente até que o programa termina. Um programa multithread tem mais de uma <code>thread</code> de execução. Dentro de cada <code>
thread</code>, os comandos são executados sequencialmente, mas as próprias <code>threads</code> podem ser executadas em paralelo em uma
CPU multicore, por exemplo. Frequentemente (em um núcleo único, uma única CPU, por exemplo), várias <code>Threads</code> não são na
realidade executadas em paralelo, mas o paralelismo é simulada intercalando a execução das <code>threads</code>.</p>

<p>Programas como o software de processamento de imagem que fazem um monte de cálculos estão a ser dito <code>compute-bound</code>. Eles só
podem beneficiar de multithreading, se há realmente múltiplas CPUs para executar os cálculos em paralelo. A maioria dos
programas não são totalmente vinculados a computação, no entanto. Muitos, como navegadores web, passam a maior parte de seu
tempo de espera para a rede ou arquivo <code>I/O</code>. Programas como estes estão a ser dito <code>IO-bound</code>. Programas <code>IO-bound</code> pode ser
útil mesmo quando várias <code>threads</code> há apenas uma única CPU disponível. Um navegador pode tornar uma imagem em uma <code>thread</code>
enquanto outra <code>thread</code> está à espera para a próxima imagem para ser baixada da rede.</p>

<p>Ruby faz com que seja fácil de escrever programas <code>multi-threaded</code> com a <code>Class Thread</code>. Para iniciar uma nova <code>thread</code>,
apenas associa um bloco com uma chamada para <code>Thread.new</code>. Uma nova <code>thread</code> será criada para executar o código no bloco, e a
<code>thread</code> original retornará do <code>Thread.new</code> imediatamente e continuar a execução com a afirmação seguinte:</p>

<pre><code class="ruby Iniciando um thread"># Thread #1 está sendo executado aqui
Thread.new {
  # Thread #2 executa esse código
}
# Thread #1 executa esse código
</code></pre>

<p>Vamos começar nossa cobertura de <code>threads</code> explicando o modelo <code>Thread</code> de Ruby e API em alguns detalhes. Estas seções
introdutórias explicam as coisas como ciclo de vida da <code>thread</code>, agendamento de threads, e os estados da <code>thread</code>. Com que o
material introdutório como pré-requisito, passamos a apresentar código de exemplo e para cobrir <code>threads</code> avançadas como
sincronização de <code>threads</code>.</p>

<p>Finalmente, é importante notar que os programas de Ruby também pode alcançar simultaneidade ao nível do processo de sistema
operacional executando executáveis externos ​​ou novas cópias de bifurcação do interpretador Ruby. Fazendo isto é dependem do
sistema operacional. Para mais informações, use <code>ri</code> para procurar os métodos <code>Kernel.system</code>, <code>Kernel.exec</code>, <code>Kernel.fork</code>,
<code>IO.popen</code>, e o módulo <code>Process</code>.</p>

<h3>Lifecycle Tópico</h3>

<p>Como descrito acima, novas <code>threads</code> são criados com <code>Thread.new</code>. Você também pode usar os sinónimos <code>Thread.start</code> e
<code>Thread.fork</code>. Não há necessidade de se iniciar uma <code>thread</code> depois de criá-la, ele começa a ser executado automaticamente
quando os recursos da CPU estejam disponíveis. O valor da invocação <code>Thread.new</code> é um objeto <code>Thread</code>. A classe <code>Thread</code>
define um número de métodos para consultar e manipular a <code>thread</code> enquanto ela está sendo executada.</p>

<p>Uma <code>thread</code> é executa o código do bloco associado à chamada para <code>Thread.new</code> e depois pára execução. O valor da última
expressão em que o bloco é o valor da <code>thread</code>, e pode ser obtido chamando o método do valor do objeto <code>Thread</code>. Se a <code>thread</code>
foi executado para conclusão, então o valor retorna o valor da <code>thread</code> de imediato. Caso contrário, os blocos de valor do
método e não retorna até que a <code>threado</code> for concluída.</p>

<p>O método de classe <code>Thread.current</code> retorna o objeto <code>Thread</code> que representa o atual <code>thread</code>. Isso permite que as <code>threads</code>
manipulam-se. O método da classe <code>Thread.main</code> retorna o objeto <code>Thread</code> que representa a principal <code>thread</code>, este é a
<code>thread</code> inicial de execução que começou quando o Programa Ruby foi iniciado.</p>

<h4>A Thread principal</h4>

<p>A <code>Thread</code> principal é especial: o interpretador Ruby pára de correr quando a <code>thread</code> principal é feita. Ele faz isso mesmo
que a <code>thread</code> principal criou outras <code>threads</code> que ainda estão em execução. Você deve garantir, portanto, que a sua princial
<code>thread</code> não termina enquanto outras <code>threads</code> ainda estão em execução. Uma maneira de fazer isso é escrever sua <code>thread</code>
principal sob a forma de um <code>loop</code> infinito. Outra maneira é explicitamente esperar para as <code>threads</code> ser concluída. Já
mencionamos que você pode chamar o método <code>value</code> de uma <code>thread</code> que espera que ela termine. Se você não se importa com o
valor de suas <code>threads</code>, você pode esperar com o método de instancia <code>join</code>.</p>

<p>O seguinte método espera até que todas as linhas, com excepção da <code>thread</code> principal e a <code>thread</code> atual (que pode ser a mesma
coisa), ter saído:</p>

<pre><code class="ruby Thread Principal">def join_all
  main = Thread.main        # Thread Principal
  current = Thread.current  # Thread atual
  all = Thread.list         # Todas as threads ainda em execução
  # Agora chama join em cada thread
  all.each {|t| t.join unless t == current or t == main }
end
</code></pre>

<h4>Threads e exceções não tratadas</h4>

<p>Se uma exceção é levantada na <code>thread</code> principal, e não é tratada em qualquer lugar, o interpretador Ruby imprime uma
mensagem e sai. Em outras <code>threads</code> que a <code>thread</code> principal, exceções não tratadas causam a <code>thread</code> para parar de executar.
Por defeito, no entanto, isto não faz o intérprete para imprimir uma mensagem ou saída. Se uma <code>thread</code> <code>t</code> sai por causa de
uma exceção não tratada, e outra <code>thread</code> de chamadas <code>t.join</code> ou <code>t.value</code>, então a exceção que ocorreu em <code>t</code> é levantada
na <code>thread</code> de <code>s</code>.</p>

<p>Se você gostaria de qualquer exceção não tratada em qualquer <code>thread</code> para fazer com que o intérprete saia, use o método de
classe <code>Thread.abort_on_exception=</code>:</p>

<pre><code class="ruby Thread">Thread.abort_on_exception = true
</code></pre>

<p>Se você quer uma exceção não tratada em uma <code>thread</code> específica faz com que o intérprete saia, utilizando o método de
exemplo, através do mesmo nome:</p>

<pre><code class="ruby Thread abort">t = Thread.new { ... }
t.abort_on_exception = true
</code></pre>

<p>É isso ai amigos.. até a proxima!</p>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
]]></content>
  </entry>
  
  <entry>
<<<<<<< HEAD
    <title type="html"><![CDATA[Literais e Palavras-Chaves Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais/"/>
    <updated>2012-05-27T12:15:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Literais e Plavras-chaves literais</p>




<h1>Literais e Plavras-chaves literais</h1>


<p>Literais são valores como 1.0, "Hello world", e [] que são incorporados diretamente em seu texto do programa.</p>

<p>É interessante notar que muitos literais, tais como números, são as principais expressões - as expressões mais simples possíveis não
compostas de expressões simples. Literais, tais como Array e literais de hash e strings duplas citadas que usam interpolação, incluem
sub-expressões e são, portanto, expressões não primárias.</p>

<p>Determinadas palavras-chave em Ruby são expressões primárias e podem ser considerados palavras-chave literais ou formas especializadas
de referência da variável:</p>

<pre><code>nil            -&gt;   Avalia o valor nulo, de NilClass classe.
true           -&gt;   Avalia-se à instância singleton da Classe TrueClass, que um objeto representa o valor booleano 
                    verdadeiro.
false          -&gt;   Avalia-se à instância singleton da Classe FalseClass, que um objeto representa os valores booleanos
                    falsos.
self           -&gt;   Auto avalia o objeto atual.
__FILE__       -&gt;   Avalia a uma string que nomeia o arquivo que o Ruby Intérprete (IRB) está em execução. Isto pode ser
                    útil em erro de mensagens.
__LINE__       -&gt;   Avalia como um inteiro que especifica o número da linha dentro da linha do código atual do __FILE__.
__ENCODING__   -&gt;   Avalia a um objeto Encoding que especifica a codificação do arquivo atual. (Ruby 1.9 apenas.)
</code></pre>

<p>É isso ai galera, até o proximo post.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte III - Hashs Codes]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/10/o-mundo-hash-no-ruby-1-dot-9-2-parte-iii-hashs-codes/"/>
    <updated>2012-05-10T13:01:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/10/o-mundo-hash-no-ruby-1-dot-9-2-parte-iii-hashs-codes</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Hoje vamos falar um pouco mais de Hash, é hora de nos aprofundar.</p>




<h3>Códigos de Hash, Igualdade e mutáveis ​​Chaves</h3>


<p>Hashs[1] de Ruby são implementadas, sem surpresa, com um conjunto de dados de
estrutura conhecida como uma tabela hash. Objetos usados como chaves em um hash deve ter um método chamado de hash que retorna <a href="http://www.ruby-doc.org/core-1.9.2/Fixnum.html">Fixnum</a> hashcode para a chave. Se duas chaves são iguais, elas devem ter o mesmo
hashcode. Chaves desiguais também pode ter a mesma hashcode, mas hash's de tabelas são mais eficientes quando hashcodes duplicados são raros.</p>

<p>A classe Hash compara chaves igualdade com o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-eql-3F">eql?</a>. Para
outras classes Ruby, eql? obras como o operador == . Se você definir uma nova classe que
substitui o método eql?, você deve também substituir o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-hash">hash</a>, ou se não as instâncias de sua classe não vam funcionar como chaves em um hash.</p>

<p>Se você definir uma classe e não sobreescrever o método eql?, em seguida, as instâncias dessa classe são
comparadas com a identidade do objeto quando usado como chave de hash. Duas instâncias distintas de sua classe são distintas chaves de hash mesmo que eles representam o mesmo conteúdo. Neste caso, o método padrão hash é apropriado: retorna a única object_id do objeto.</p>

<p>Note-se que objetos mutáveis ​​são problemáticos como chaves de hash. Mudar o conteúdo de um objeto geralmente muda seu hashcode. Se você usar um objeto como uma chave e então alterar esse objeto, a tabela de hash ficará corrompida, e o hash não funciona corretamente.</p>

<p>Porque strings são mutáveis, mas comumente usamos chaves de hash, Ruby trata eles como um caso especial e faz cópias privadas de todas as cadeias utilizadas como chaves. Este é o único caso especial, no entanto, você deve ser muito cuidado ao usar qualquer outro objeto mutável como uma chave hash. Considera fazendo uma cópia privada ou chamando o método <a href="http://ruby-doc.org/core-1.9.2/Object.html#method-i-freeze">freeze</a>.
Se você deve usar chaves de hash mutável, chame o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-rehash">rehash</a> do Hash cada vez que você alterar uma chave.</p>

<p>-> <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html">Hash</a></p>

<p>Até a proxima!</p>
=======
    <title type="html"><![CDATA[Reflexão e Metaprogramação - Avaliando Strings e Blocos - #Ruby 1.9 - Part II]]></title>
    <link href="http://rrmartins.com/blog/2012/08/29/reflexao-e-metaprogramacao-number-ruby-1-dot-9-part-ii/"/>
    <updated>2012-08-29T22:15:00-03:00</updated>
    <id>http://rrmartins.com/blog/2012/08/29/reflexao-e-metaprogramacao-number-ruby-1-dot-9-part-ii</id>
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Avaliando Strings e Blocos</b>... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Avaliando Strings e Blocos</h1>


<p>Um dos mais poderosos reflexivos e de características direta do Ruby, é seu método <code>eval</code>. Se o seu programa Ruby pode gerar uma seqüência de código
válido Ruby, o método <code>Kernel.eval</code> pode avaliar que o código:</p>

<pre><code class="ruby Kernel.eval">x = 1
eval "x + 1"  # =&gt; 2
</code></pre>

<p><code>eval</code> é uma função poderosa, mas ao menos que você realmente está escrevendo um programa <code>shell</code> (como irb) que executa as linhas de códigos Ruby
inserido por um usuário é improvável que você realmente precisa. (E em um contexto de rede, quase nunca é seguro para chamar <code>eval</code> no texto recebido
de um usuário, que podia conter um código malicioso). Programadores inexperientes, por vezes, acabam usando eval como uma muleta. Se você tiver que
usá-lo em seu código, ver se não há uma maneira de evitá-lo. Dito isto, há algumas maneiras mais úteis para usar métodos <code>eval</code> e <code>eval-like</code>.</p>

<h3>Associações e eval</h3>


<p>Um objeto de Associação, representa o estado de variáveis <code>bindings</code> de Ruby em algum momento. O objeto <code>Kernel.binding</code> retorna as ligações em vigor
no local da chamada. Você pode passar um objeto de associação como o segundo argumento para <code>eval</code>, e a <code>String</code> especificada será avaliada no
contexto dessas ligações. Se, por exemplo, definir um método de instância que retorna um objeto <code>Binding</code> que representa a variável de ligações
dentro de um objeto, então nós podemos usar essas ligações para consultar e definir as variáveis de instância do objeto. Podemos conseguir isso como segue:</p>

<pre><code class="ruby Binding">class Object # Abre objeto para adicionar um novo método
  def bindings # Nota plural sobre este método
    binding # Este é o método de Kernel predefinido
  end
end

class Test # Uma classe simples com uma variável de instância
  def initialize(s); @x = s; end
end

t = Test.new(10) # Criar um objeto test
eval("@x", t.bindings)  # =&gt; 10: Espia dentro t
</code></pre>

<p>Note que não é realmente necessário definir um método de <code>Object.bindings</code> deste tipo para observar nas variáveis de instância de um objeto. Vários
outros métodos descritos logo oferecem maneiras mais fáceis de consulta (e de conjunto) do valor das variáveis de instância de um objeto.</p>

<p>Os objetos <code>Proc</code> definem um método público de ligação que retorna uma Associação de objeto que representa a variável ligação em vigor para o corpo
do <code>Proc</code>. Além disso, o método <code>eval</code> permite que você passe um objeto <code>Proc</code> em vez de um objeto de associação como o segundo argumento.</p>

<p>Ruby 1.9 define um método <code>eval</code> em objetos de associação, de modo em vez de passar uma associação como o segundo argumento para o <code>eval</code> global,
você pode, em vez de invocar o método <code>eval</code> em uma ligação. Qual você escolhe é puramente uma questão de estética, as duas técnicas são equivalentes.</p>

<h3>instance_eval e class_eval</h3>


<p>A classe <code>Object</code> define um método chamado <code>instance_eval</code>, e a classe <code>Module</code> define um método chamado <code>class_eval</code>. <code>module_eval</code> é um sinônimo
para <code>class_eval</code>. Ambos os métodos avaliam código Ruby, como o <code>eval</code> faz, mas existem duas diferenças importantes. A primeira diferença é a que eles
avaliam o código no contexto do objecto específico ou no contexto especificado de cada módulo do objecto ou é o valor enquanto o código está sendo
avaliado. Aqui estão alguns exemplos:</p>

<pre><code class="ruby instance_eval e class_eval">o.instance_eval("@x")  # Retorna o valor da variável de instância o @x

# Define um len método de instância de String para retornar comprimento da String
String.class_eval("def len; size; end")

# Aqui está outra maneira de fazer isso
# O código citado se comporta como se fosse dentro da "class String" e "end"
String.class_eval("alias len size")

# Use instance_eval para definir método de classe String.Empty
# Note que as aspas dentro da aspas fica um pouco complicado ...
String.instance_eval ("def vazio;''; fim")
</code></pre>

<p>Observe a diferença sutil, mas crucial entre <code>instance_eval</code> e <code>class_eval</code> quando o código que está sendo avaliado contém uma definição de método.
<code>instance_eval</code> define métodos únicos do objeto (e isso resulta em métodos de classe quando for chamado em uma classe de objeto). <code>class_eval</code> define métodos de instância regulare.</p>

<p>A segunda diferença importante entre estes dois métodos e o eval global é que <code>instance_eval</code> e <code>class_eval</code> pode aceitar um bloco de código para
avaliar. Quando passa um bloco em vez de uma <code>String</code>, o código do bloco é executado no contexto apropriado. Aqui, por conseguinte, são alternativas
para as invocações anteriorment mostrada:</p>

<pre><code class="ruby instance_eval e class_eval">o.instance_eval { @x }
String.class_eval {
  def len
    size
  end
}
String.class_eval { alias len size }
String.instance_eval { def empty; ""; end }
</code></pre>

<h3>instance_exec e class_exec</h3>


<p>Ruby 1.9 define dois métodos de avaliação a mais: <code>instance_exec</code> e <code>class_exec</code> (e seu alias, <code>module_exec</code>). Estes métodos de avaliação de um bloco
(Mas não uma cadeia) de código, no contexto do objeto receptor, como fazem <code>instance_eval</code> e <code>class_eval</code>. A diferença é que o métodos <code>exec</code> aceita
argumentos e passá para o bloco. Assim, o bloco do código é avaliado no contexto de um objeto determinado, com parâmetros cujos valores vêm a partir
do exterior do objecto.</p>

<p>Até o proximo post amigos! :P</p>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
]]></content>
  </entry>
  
</feed>
