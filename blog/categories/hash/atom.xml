<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hash | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/hash/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-06-02T11:53:28-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Variáveis ​​não inicializadas]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas/"/>
    <updated>2012-06-02T11:30:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Variáveis ​​não inicializadas</h1>


<p>Em geral, você deve sempre atribuir um valor para, ou inicializar as variáveis ​​antes de usá-las em expressões. Em algumas circunstâncias,
no entanto, Ruby lhe permitirá utilizar variáveis ​​que ainda não foram inicializadas. As regras são diferentes para diferentes tipos de variáveis:</p>

<h4>Variáveis ​​de classe</h4>


<pre><code>Variáveis ​​de classe deve sempre ter um valor atribuído a elas antes que serem utilizadas. Ruby levanta uma NameError se 
referir a uma variável de classe à qual nenhum valor foi atribuído.
</code></pre>

<h4>Variáveis ​​de instância</h4>


<pre><code>Se você se referir a uma variável de instância não inicializada, Ruby retorna nil. Considera-se má programação de 
contar com esse comportamento, no entanto. Ruby vai emitir um aviso sobre a variável não inicializada se você executá-la 
com a opção -w.
</code></pre>

<h4>As variáveis ​​globais</h4>


<pre><code>Variáveis ​​globais não inicializadas são como o exemplo de variáveis não inicializadas: elas igualam a nil, mas mostra 
um aviso quando o Ruby é executado com o flag do -w.
</code></pre>

<h4>As variáveis ​​locais</h4>


<pre><code>Este caso é mais complicado que os outros, porque variáveis locais ​​não têm um caractere de pontuação como um prefixo. 
Este significa que variáveis ​​locais referênciam olhando apenas como uma invocação de método de expressões. Se o 
interpretador Ruby tem visto uma atribuição de uma variável local, ele sabe que é uma variável e não um método, 
e pode retornar o valor da variável. Se não tiver havido nenhuma atribuição, então o Ruby trata a expressão como uma 
invocação de método. Se nenhum método com esse nome existe, Ruby levanta um NameError.

Em geral, portanto, a tentativa de usar uma variável local antes de ter sido inicializada resulta em um erro. Existe 
uma peculiaridade, uma variável passa a existir quando o interpretador Ruby vê uma expressão de atribuição para essa 
variável. Este é o caso, mesmo se essa atribuição não é realmente executada. A variável que existe, mas não foi 
atribuído um valor, é dado o valor nulo   como padrão. Por exemplo:
</code></pre>

<p><code>ruby Variaveis
a = 0.0 if false # atribuição Isso nunca é executado
puts a # Imprime nulo: a variável existe mas não é atribuída
puts b # NameError: nenhuma variável ou método chamado existe b
</code></p>

<p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html">Variaveis Ruby 1.9.2</a></p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variáveis de Referência]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia/"/>
    <updated>2012-06-01T13:16:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis de Referência</p>




<h1>Variáveis de Referência</h1>


<p>Uma variável é simplesmente um nome para um valor. As variáveis ​​são criadas e os valores que lhes são atribuídos por expressões
de atribuição. Quando o nome de uma variável aparece num programa em qualquer lugar que não seja o lado esquerdo de uma atribuição, é uma
variável de referência à expressão e avaliado como o valor da variável:</p>

<p><code>ruby Referência
one = 1.0 # Esta é uma atribuição de expressão
one # Essa referência de expressão da variável, que imprimi 1.0
</code></p>

<p>Existem quatro tipos de variáveis ​​em Ruby, e regras <a href="http://pt.wikipedia.org/wiki/Item_lexical">lexicais</a> para governar seus nomes. Variáveis que começam com $ são variáveis ​​globais, visível ao longo de um programa Ruby. Variáveis ​​que começam com @ e @@ são
variáveis ​​de instância e variáveis ​​de classe, usado em programação orientada a objeto. E as variáveis ​​cujos nomes começam com um sublinhado
ou uma letra minúscula são variáveis ​​locais, definidas apenas dentro do atual método ou bloco.</p>

<p>Variáveis ​​sempre são simples, nomes não qualificados. Se um . ou :: aparece em uma expressão, em seguida, que a expressão é ou um
uma referência a uma constante ou uma invocação de método. Por exemplo, Math::PI é uma referência a uma constante, e a expressão
item.preco é uma invocação do método chamado preco (preço) sobre o valor realizado pela variável item.</p>

<p>O interpretador Ruby predefine um número de variáveis ​​globais quando ele é iniciado.</p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Literais e Palavras-Chaves Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais/"/>
    <updated>2012-05-27T12:15:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Literais e Plavras-chaves literais</p>




<h1>Literais e Plavras-chaves literais</h1>


<p>Literais são valores como 1.0, "Hello world", e [] que são incorporados diretamente em seu texto do programa.</p>

<p>É interessante notar que muitos literais, tais como números, são as principais expressões - as expressões mais simples possíveis não
compostas de expressões simples. Literais, tais como Array e literais de hash e strings duplas citadas que usam interpolação, incluem
sub-expressões e são, portanto, expressões não primárias.</p>

<p>Determinadas palavras-chave em Ruby são expressões primárias e podem ser considerados palavras-chave literais ou formas especializadas
de referência da variável:</p>

<pre><code>nil            -&gt;   Avalia o valor nulo, de NilClass classe.
true           -&gt;   Avalia-se à instância singleton da Classe TrueClass, que um objeto representa o valor booleano 
                    verdadeiro.
false          -&gt;   Avalia-se à instância singleton da Classe FalseClass, que um objeto representa os valores booleanos
                    falsos.
self           -&gt;   Auto avalia o objeto atual.
__FILE__       -&gt;   Avalia a uma string que nomeia o arquivo que o Ruby Intérprete (IRB) está em execução. Isto pode ser
                    útil em erro de mensagens.
__LINE__       -&gt;   Avalia como um inteiro que especifica o número da linha dentro da linha do código atual do __FILE__.
__ENCODING__   -&gt;   Avalia a um objeto Encoding que especifica a codificação do arquivo atual. (Ruby 1.9 apenas.)
</code></pre>

<p>É isso ai galera, até o proximo post.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte III - Hashs Codes]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/10/o-mundo-hash-no-ruby-1-dot-9-2-parte-iii-hashs-codes/"/>
    <updated>2012-05-10T13:01:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/10/o-mundo-hash-no-ruby-1-dot-9-2-parte-iii-hashs-codes</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Hoje vamos falar um pouco mais de Hash, é hora de nos aprofundar.</p>




<h3>Códigos de Hash, Igualdade e mutáveis ​​Chaves</h3>


<p>Hashs[1] de Ruby são implementadas, sem surpresa, com um conjunto de dados de
estrutura conhecida como uma tabela hash. Objetos usados como chaves em um hash deve ter um método chamado de hash que retorna <a href="http://www.ruby-doc.org/core-1.9.2/Fixnum.html">Fixnum</a> hashcode para a chave. Se duas chaves são iguais, elas devem ter o mesmo
hashcode. Chaves desiguais também pode ter a mesma hashcode, mas hash's de tabelas são mais eficientes quando hashcodes duplicados são raros.</p>

<p>A classe Hash compara chaves igualdade com o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-eql-3F">eql?</a>. Para
outras classes Ruby, eql? obras como o operador == . Se você definir uma nova classe que
substitui o método eql?, você deve também substituir o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-hash">hash</a>, ou se não as instâncias de sua classe não vam funcionar como chaves em um hash.</p>

<p>Se você definir uma classe e não sobreescrever o método eql?, em seguida, as instâncias dessa classe são
comparadas com a identidade do objeto quando usado como chave de hash. Duas instâncias distintas de sua classe são distintas chaves de hash mesmo que eles representam o mesmo conteúdo. Neste caso, o método padrão hash é apropriado: retorna a única object_id do objeto.</p>

<p>Note-se que objetos mutáveis ​​são problemáticos como chaves de hash. Mudar o conteúdo de um objeto geralmente muda seu hashcode. Se você usar um objeto como uma chave e então alterar esse objeto, a tabela de hash ficará corrompida, e o hash não funciona corretamente.</p>

<p>Porque strings são mutáveis, mas comumente usamos chaves de hash, Ruby trata eles como um caso especial e faz cópias privadas de todas as cadeias utilizadas como chaves. Este é o único caso especial, no entanto, você deve ser muito cuidado ao usar qualquer outro objeto mutável como uma chave hash. Considera fazendo uma cópia privada ou chamando o método <a href="http://ruby-doc.org/core-1.9.2/Object.html#method-i-freeze">freeze</a>.
Se você deve usar chaves de hash mutável, chame o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-rehash">rehash</a> do Hash cada vez que você alterar uma chave.</p>

<p>-> <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html">Hash</a></p>

<p>Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte II - Hashs Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2-parte-ii-hashs-literais/"/>
    <updated>2012-05-08T22:28:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2-parte-ii-hashs-literais</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Na primeira parte eu fiz uma introdução do Hash:
-> <a href="/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2/">O Mundo Hash no Ruby 1.9.2 - Parte I</a></p>

<p>Vamos lá!</p>

<p>Um literal de hash é escrita como uma lista separada por vírgulas de chave/valor de
pares, colocados dentro de chaves. Chaves e valores são separados
com um caractere de dois "arrow": '=>'. O objeto Hash criado anteriormente também pode ser
criado com o literal seguinte:</p>

<!--more-->


<p><code>ruby Hash Literal
números = {"um" =&gt; 1, "dois" =&gt; 2, "três" =&gt; 3}
</code></p>

<p>Em geral, objetos <a href="http://www.ruby-doc.org/core-1.9.2/Symbol.html">Símbolos</a> trabalham mais eficientemente como chaves de hash de strings, fazem assim:</p>

<p><code>ruby Hash Literal
números = {:um =&gt; 1,:dois =&gt; 2,:três =&gt; 3}
</code></p>

<p>Os <a href="http://www.ruby-doc.org/core-1.9.2/Symbol.html">Símbolos</a> são imutáveis, escrito como
prefixados identificadores, que serão explicados em maior detalhe em um outro post.</p>

<p>Ruby 1.8 permite vírgulas em lugar de setas, mas isso não teve a sintaxe substituída, mais suportado no Ruby 1.9:</p>

<p><code>ruby Hash Literal
 numeros = {:um, 1, :dois, 2, :tres, 3} # Igual, mas mais difícil de ler
</code></p>

<p>Tanto Ruby 1.8 quanto no Ruby 1.9 permite uma única vírgula à direita do
final da lista de chave / valor:</p>

<p><code>ruby Hash Literal
números = {: um =&gt; 1,: dois =&gt; 2} # vírgula extra ignorado
</code></p>

<p>Ruby 1.9 suporta muito útil e sucinto a sintaxe literal de Hash
quando as chaves são símbolos. Neste caso, move-se para o fim da chave de hash e substitui a seta:</p>

<p><code>ruby Hash Literal
números = {um: 1, dois: 2, tres: 3}
</code></p>

<p>Note-se que pode não haver qualquer espaço entre a chave Hash
identificador e dos dois pontos.</p>

<p>Até breve!</p>
]]></content>
  </entry>
  
</feed>
