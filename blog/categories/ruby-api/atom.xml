<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby API | Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/blog/categories/ruby-api/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-07-25T23:37:17-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objetos Enumeráveis #Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/07/25/objetos-enumeraveis-number-ruby-1-dot-9-2/"/>
    <updated>2012-07-25T22:50:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/07/25/objetos-enumeraveis-number-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `Objetos Enumeráveis`... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Objetos Enumeráveis</h1>


<p><code>Array</code>, <code>Range</code>, <code>Hash</code>, e um número de outras classes definem um iterador <code>each</code> que passa cada elemento da
coleção para o bloco associado. Este é talvez o mais comumente usado iterador em Ruby, o loop só funciona para
iterar sobre objetos que têm o método <code>each</code>. Exemplos de iteradores <code>each</code>:</p>

<p><code>ruby Metodo each
[1,2,3].each {|x| print x }   # =&gt; prints "123"
(1..3).each  {|x| print x }   # =&gt; prints "123" Same as 1.upto(3)
</code></p>

<!--more-->


<p>O iterador <code>each</code> não é só para as classes tradicionais "de estrutura de dados". Classes <code>IO</code> Ruby definem um
iterador <code>each</code> que cada linha de texto lido do objeto produz <code>Input/Output</code>. Assim, você pode processar as linhas
de um arquivo em Ruby com um código como esse:</p>

<p><code>ruby Metodo each para File
File.open(filename) do |f|       # Abrir arquivo nomeado, passando f como parametro
  f.each {|line| print line }    # Imprimir f em cada linha
end
</code></p>

<p>A maioria das classes que definem um método <code>each</code> também incluem o módulo <code>Enumerable</code>, que define um número de
iteradores mais especializados que são implementados em cima do método <code>each</code>. Um iterador é útil tal <code>each_with_index</code>, o que nos permite adicionar a linha de numeração para o exemplo anterior:</p>

<p>``` ruby Metodo each com Index
File.open(filename) do |f|
  f.each_with_index do |line,number|</p>

<pre><code>print "#{number}: #{line}"
</code></pre>

<p>  end
end
```</p>

<p>Alguns dos iteradores mais comumentes utilizados são os métodos <code>Enumerable</code>, <code>collect</code>, <code>select</code>, <code>reject</code>, e
<code>inject</code>. O método <code>collect</code> (também conhecido como <code>map</code>) executa o seu bloco associado para cada elemento do objeto
enumerável, e coleta os valores de retorno dos blocos em um <code>array</code>:</p>

<p><code>ruby Metodo Collect
quadrados = [1,2,3].collect {|x| x*x}   # =&gt; [1,4,9]
</code></p>

<p>O método <code>select</code> invoca o bloco associado para cada elemento no objeto enumerável, e retorna uma matriz de
elementos para a qual o bloco retorna um outro valor <code>false</code> ou <code>nil</code>. Por exemplo:</p>

<p><code>ruby Metodo Select
nivela = (1..10).select{|x| x%2 == 0} # =&gt; [2,4,6,8,10]
</code></p>

<p>O método <code>reject</code> é simplesmente o oposto de <code>select</code>, ele retorna uma matriz de elementos para a qual o bloco
retorna <code>nil</code> ou <code>false</code>. Por exemplo:</p>

<p><code>ruby Metodo reject
odds = (1..10).reject{|x| x%2 == 0} # =&gt; [1,3,5,7,9]
</code></p>

<p>O método <code>inject</code> é um pouco mais complicado do que os outros. Ele invoca o bloco associado com dois argumentos.
O primeiro argumento é um valor acumulado de algum tipo das iterações anteriores. O segundo argumento é o próximo
o objeto enumerável. O valor de retorno do bloco é o primeiro argumento bloqueado para a próxima iteração, ou torna-
se o valor de retorno do iterador após a última iteração. O valor inicial da variável acumula ou é o argumento de
<code>inject</code>, se houver um, ou o primeiro elemento do objeto enumerável. (Neste caso, o bloco é invocado. Apenas uma vez durante os primeiros dois elementos). Exemplos para <code>injects</code> mais claros:</p>

<p><code>ruby Metodo Inject
data = [2, 5, 3, 4]
sum = data.inject{|sum, x| sum + x }      # =&gt; 14    (2+5+3+4)
floatprod = data.inject(1.0){|p,x| p*x }  # =&gt; 120.0 (1.0*2*5*3*4)
max = data.inject{|m,x| m&gt;x ? m : x }     # =&gt; 5     (elemento maior)
</code></p>

<p>Veja <a href="http://ruby-doc.org/core-1.9.2/Enumerable.html">Objetos Enumeráveis</a> ​​para obter mais detalhes sobre o <code>Módulo Enumerable</code> e a seus iteradores.</p>

<p>Até a proxima amigos...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Iteradores Numéricos #Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/07/14/iteradores-numericos/"/>
    <updated>2012-07-14T22:52:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/07/14/iteradores-numericos</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `Iteradores Numéricos`... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Iteradores Numéricos</h1>


<p>O núcleo do <code>Ruby API</code> fornece um número de iteradores padrão. Os métodos de loops do Kernel se comporta como um
loop infinito, executando seu bloco associado repetidamente até que o bloco executa um <code>return</code>, <code>break</code>, ou outra
declaração que sai do laço.</p>

<p>A classe <code>Integer</code> define três iteradores usados. O método <code>upto</code> chama seu bloco associado uma vez para cada número
inteiro entre o número inteiro no qual ele é invocado e o número inteiro que é passado como um argumento.
Por exemplo:</p>

<p><code>ruby upto
4.upto(6){|x| print x} # =&gt; prints "456"
</code></p>

<p>Como você pode ver, <code>upto</code> intera cada número inteiro para o bloco associado, e inclui tanto o ponto de partida e o
ponto final na iteração. Em geral, <code>n.upto(m)</code> é executado o bloco <code>m-n +1</code> vezes.</p>

<p>O método <code>downto</code> é como <code>upto</code> mas itera a partir de um maior número para um número menor.</p>

<p>Quando o método <code>Integer.times</code> é chamado no <code>n</code> inteiro, invoque o seu bloco de <code>n vezes</code>, passando os valores de
<code>0 a n-1</code> em iterações sucessivas. Por exemplo:</p>

<p><code>ruby times
3.times {|x| print x }    # =&gt; prints "012"
</code></p>

<p>Em geral, é <code>n.times</code> equivalente a <code>0.upto(n-1)</code>.</p>

<p>Se você quer fazer uma iteração numérica usando um ponto flutuante de números, você pode usar o método <code>step</code> mais
complexo definido pela classe numérica. O iterador a seguir, por exemplo, começa a 0 e itera em passos de 0.1 até
atingir <code>Math::PI</code>:</p>

<p><code>ruby metodo step
0.step(Math::PI, 0.1){|x| puts Math.sin(x)}
</code></p>

<p>Até a proxima!</p>
]]></content>
  </entry>
  
</feed>
