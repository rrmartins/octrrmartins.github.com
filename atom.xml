<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Rodrigo Martins]]></title>
<<<<<<< HEAD
  <link href="http://rrmartins.github.com/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-08-09T01:16:17-03:00</updated>
  <id>http://rrmartins.github.com/</id>
=======
  <link href="http://rrmartins.com/atom.xml" rel="self"/>
  <link href="http://rrmartins.com/"/>
<<<<<<< HEAD
  <updated>2015-09-29T11:44:19-03:00</updated>
=======
  <updated>2015-09-21T15:34:22-03:00</updated>
>>>>>>> f0fad74ab02c4e5669e277aa283faa25f065f1cb
  <id>http://rrmartins.com/</id>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
<<<<<<< HEAD
    <title type="html"><![CDATA[A Filosofia do #Ruby <3]]></title>
    <link href="http://rrmartins.github.com/blog/2012/08/08/a-filosofia-do-number-ruby-3/"/>
    <updated>2012-08-08T22:59:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/08/08/a-filosofia-do-number-ruby-3</id>
    <content type="html"><![CDATA[<p>Nessa noite, eu estava assistindo um jogo na tv, e navegando na internet achei um link muito bom(<a href="http://www.artima.com/intv/ruby.html">http://www.artima.com/intv/ruby.html</a>), que já consegui a 
autorização para colocar aqui para vocês&#8230;</p>




<p>Então, abaixo uma entrevista do criador da linguagem de programação <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, o <a href="https://twitter.com/yukihiro_matz">Yukihiro Matsumoto &#8216;Matz&#8217;</a>.</p>




<h2>A Filosofia do #<a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a></h2>




<h6>Resumo</h6>




<p><a href="https://twitter.com/yukihiro_matz">Yukihiro Matsumoto &#8216;Matz&#8217;</a>, como é conhecido online, é o criador da linguagem de programação <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>. <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> é uma linguagem orientada a objeto adequada para escrever scripts do dia-a-dia, assim como em grande escala de aplicações. Matz começou a trabalhar no <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> em 1993, porque ele queria uma linguagem que o fizesse produtivo enquanto fosse divertido de usar. Inicialmente popular no Japão, <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> tem encontrado seu caminho para os corações de programadores em todo o mundo.</p>
=======
    
<<<<<<< HEAD
    <title type="html"><![CDATA[Resolvendo problema com $PORT com uma app Golang no Heroku]]></title>
    <link href="http://rrmartins.com/blog/2015/09/28/levantando-uma-app-golang-no-heroku/"/>
    
    <updated>2015-09-28T22:24:09-03:00</updated>
    <id>http://rrmartins.com/blog/2015/09/28/levantando-uma-app-golang-no-heroku</id>
    
    <content type="html"><![CDATA[<p>Æ,</p>

<p>Já faz um tempo que venho estudando e praticando um pouco com <a href="https://golang.org">Golang</a>. Como alguns codigos estão somente em meu repo particular, resolvi colocar alguns de meus codígos em algum host para testes iniciais. Optei por usar o <a href="heroku.com">Heroku</a> (não estou ganhando nada para fazer propaganda kkkkk).</p>

<p>Porém ao seguir o seu <a href="https://devcenter.heroku.com/articles/getting-started-with-go#introduction">Getting Started with Go</a>, percebi uma coisa: não deixam claro as politicas de porta de acesso à app.</p>

<p>Como resolver?</p>

<!--more-->


<pre><code>Não vou entrar nos detalhes para colocar a app no ar, pois o 'passo-a-passo'
do Heroku da uma boa ajuda quanto a isso.
</code></pre>

<p>Um dos <a href="https://golang.org/pkg/">packages</a> nativos de Go, que é bem útil para usar no
Heroku, é o package <a href="https://golang.org/pkg/os/">os</a>.</p>

<p>A <a href="https://golang.org/doc/effective_go.html#functions">func</a> que vamos usar aqui será a <a href="https://golang.org/pkg/os/#Getenv">Getenv</a> do pacote <code>os</code>, ela lê uma variavel de ambiente que é passada como parametro do tipo <code>string</code>.</p>

<figure class='code'><figcaption><span>e sua chamada será algo como:</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'>  <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017




<<<<<<< HEAD
<p>Nesta entrevista, Yukihiro Matsumoto discute a filosofia do design do <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, as características da linguagem <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, e se tornar um programador melhor. Neste capítulo inicial, Matz faz filosofias sobre a imperfeição de design, o perigo de <a href="http://pt.wikipedia.org/wiki/Ortogonalidade">ortogonalidade</a>, a concessão de liberdade com a orientação, o princípio da menor surpresa e a importância do ser humano em empreendimentos de computador.</p>


<!--more-->




<h6>Nenhuma Línguagem Perfeita</h6>




<p><b>Bill Venners</b>: Dave Thomas, co-autor de Programming <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>: Um Guia do Programador Pragmático, disse que você não acha que um projeto de linguagem deve ser perfeito. Por que não?</p>




<p><b>Yukihiro Matsumoto</b>: designers de Linguagens querem projetar a linguagem perfeita. Eles querem ser capazes de dizer: &#8220;A minha linguagem é perfeita. Ela pode fazer tudo.&#8221; Mas é simplesmente impossível projetar uma linguagem perfeita, porque existem duas maneiras de olhar para uma mesma linguagem. Uma maneira é olhar para o que pode ser feito com essa linguagem. A outra é olhar para o que sentimos usando essa linguagem, como nos sentimos durante a programação.</p>




<p>Por causa da Teoria da <a href="http://ethosproject.blogspot.com.br/2012/06/preconceito-ignorancia-e-genialidade.html">Integridade de Turing</a>, tudo que uma linguagem pode fazer teoricamente pode ser feito por outra linguagem, mas a um custo diferente. Você pode fazer tudo em <a href="http://pt.wikipedia.org/wiki/Assembly">Assembler</a>, mas ninguém quer programar em assembler mais. Do ponto de vista que você pode fazer, portanto, as línguas diferem entre si, mas as diferenças são limitadas. Por exemplo, <a href="http://www.python.org/">Python</a> e <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> fornecem quase o mesmo poder para o programador.</p>




<p>Em vez de enfatizar o que eu quero enfatizar a parte como: Como nos sentimos durante a programação, essa é a diferença principal do <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> a partir de projetos em outras linguagens. Eu enfatizo a sensação, em particular, como eu me sinto usando <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>. Eu não trabalho duro para tornar <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> perfeito para todos, porque você se sente diferente de mim. Nenhuma linguagem pode ser perfeita para todos. Eu tentei fazer o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> perfeita para mim, mas talvez ela não é perfeito para você. A linguagem perfeita para Guido van Rossum provavelmente é <a href="http://www.python.org/">Python</a>.</p>




<h6><a href="http://www.dicio.com.br/ortogonal/">Ortogonais</a> em relação harmoniosa</h6>




<p><b>Bill Venners</b>: Dave Thomas também afirmou que, se eu pedir para você adicionar um recurso que é ortogonal, você não vai fazer. O que você quer é algo que seje harmonioso. O que significa isso?</p>




<p><b>Yukihiro Matsumoto</b>: Eu acredito que a consistência e ortogonalidade são ferramentas de design, não o objetivo principal no projeto.</p>




<p><b>Bill Venners</b>: O que significa ortogonalidade neste contexto?</p>




<p><b>Yukihiro Matsumoto</b>: Um exemplo de ortogonalidade é permitir qualquer combinação de características de pequeno porte ou de sintaxe. Por exemplo, <a href="http://pt.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)">C</a> suporta ambos os valores de parâmetro padrão para funções e sobrecarga de nomes de função com base em parâmetros. Ambos são boas características  para se ter em uma língua, mas porque elas são ortogonais, você pode aplicar ao mesmo tempo. O compilador sabe como aplicar ao mesmo tempo. Se é ambígua, o compilador irá sinalizar um erro. Mas se eu olhar para o código, eu preciso aplicar a regra com o meu cérebro também. Eu preciso adivinhar como o compilador funciona. Se eu estiver certo, e eu for inteligente o suficiente, não há problema. Mas se eu não sou inteligente o suficiente, e eu não sou realmente, causa confusão. O resultado será inesperado para uma pessoa comum. Este é um exemplo de como ortogonalidade é má.</p>




<p><b>Bill Venners</b>: Em outras palavras, as características ortogonais irá funcionar uma vez que o escritor do compilador entendê-las e recebe-las para trabalhar. Mas é difícil para os programadores entender quando olham para ele, porque é complicado, porque eu tenho que descobrir como essas duas coisas andam juntas.</p>




<p><b>Yukihiro Matsumoto</b>: As funcionalidades ortogonais, quando combinadas, podem explodir em complexidade.</p>




<p><b>Bill Venners</b>: Então, qual é a alternativa? O que seria mais harmonioso?</p>




<p><b>Yukihiro Matsumoto</b>: Basta pegar um dos dois para colocar na linguagem. Você não tem que fazer tudo o que você pode pensar. Você precisa escolher um deles, mesmo que ambos sejam bons.</p>




<h6>Liberdade e Conforto</h6>




<p><b>Bill Venners</b>: Uma das filosofias de design na comunidade <a href="http://www.python.org/">Python</a> está fornecendo uma e apenas uma maneira de fazer as coisas. Se você fornecer cinquenta maneiras diferentes de fazer a mesma coisa, então você forneceu comodidade para os escritores de código. As pessoas podem escrever coisas da sua melhor forma. A troca é para os leitores de código. Quando eu li o seu código, você poderia ter escrito de um jeito. Quando eu li o código de outras pessoas, elas podem ter escrito de outra forma. Então, como um leitor de eu acabar precisando estar familiarizado com todos os meios para realizar a tarefa, não apenas a minha maneira favorita de escrevê-la. Esse é o dilema do design. A comunidade <a href="http://www.python.org/">Python</a> parece preferir a uma e apenas uma maneira de abordagem, mas <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> parece fornecer várias maneiras de fazer a mesma coisa.</p>




<p><b>Yukihiro Matsumoto</b>: <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> herdou a filosofia <a href="http://www.perl.org.br/Main/WebHome">Perl</a> de ter mais de uma maneira de fazer a mesma coisa. Eu herdei essa filosofia de <a href="http://pt.wikipedia.org/wiki/Larry_Wall">Larry Wall</a>, que é o meu herói, na verdade. Eu quero fazer os usuários de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> livre. Eu quero dar-lhes a liberdade de escolher. As pessoas são diferentes. As pessoas escolhem diferentes critérios. Mas se há uma maneira melhor entre muitas alternativas, eu quero encorajar esse caminho, tornando-o confortável. Então é isso que eu tentei fazer. Talvez o código do <a href="http://www.python.org/">Python</a> é um pouco mais legível. Todo mundo pode escrever o mesmo estilo de código <a href="http://www.python.org/">Python</a>, por isso pode ser mais fácil de ler, talvez. Mas a diferença de uma pessoa para outra é tão grande, proporcionando apenas uma maneira de ajudar é pouco, mesmo se você estiver usando o <a href="http://www.python.org/">Python</a>, eu acho. Prefiro fornecer muitas maneiras se é possível, mas encorajar ou orientar os usuários a escolher um caminho melhor, se é possível.</p>




<h6>A alegria do <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a></h6>




<p><b>Bill Venners</b>: Em um artigo introdutório sobre <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, você escreveu: &#8220;Para mim, o propósito da vida é, em parte, para ter alegria de programadores, que muitas vezes se sentem alegres quando eles podem se concentrar no lado criativo da programação, o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, então, é projetado para fazer programadores felizes.. &#8221; Como pode o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> fazer programadores felizes?<p>

<p><b>Yukihiro Matsumoto</b>: Você quer curtir a vida, não é? Se você começa o seu trabalho feito rapidamente e seu trabalho é divertido, isso é bom não é? Esse é o propósito da vida, em parte. Sua vida é melhor.</p>

<p>Eu quero resolver os problemas que encontro no cotidiano usando computadores, então preciso escrever programas. Usando <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, quero me concentrar nas coisas que faço, e não as regras mágicas da linguagem, como começo com algum público vazio, tenho algo a dizer, &#8220;Olá, mundo de impressão.&#8221; Eu só quero dizer, &#8220;imprimir isto!&#8221; Eu não quero todas as palavras mágicas circundantes. Eu só quero concentrar-se na tarefa. Essa é a idéia básica. Então eu tentei fazer o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> conciso e com código suscinto.</p>

<p><b>Bill Venners</b>: permitir que os programadores escrevem códigos que é conciso e suscinto é uma maneira de fazê-los felizes.</p>

<p><b>Yukihiro Matsumoto</b>: Sim, para que eles possam se concentrar no problema em si. Às vezes as pessoas anotam pseudo-código no papel. Se esse pseudo-código é executado diretamente em seus computadores, é melhor, não é? <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> tenta ser assim, como o pseudo-código que é executado. As pessoas dizem que <a href="http://www.python.org/">Python</a> também.</p>

<p><b>Bill Venners</b>: Sim, as pessoas dizem que Pytho é pseudo-código executável. O que mais está em <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> para fazer programadores felizes?</p>

<p><b>Yukihiro Matsumoto</b>: Em nossas vidas diárias como programadores, processamos cadeias de texto muito grandes. Então, eu tentei trabalhar duro em processamento de texto, ou seja, a Classe <a href="http://ruby-doc.org/core-1.9.3/String.html">String</a> e <a href="http://www.ruby-doc.org/core-1.9.3/Regexp.html">Expressões Regulares</a>. As <a href="http://www.ruby-doc.org/core-1.9.3/Regexp.html">Expressões Regulares</a> são incorporadas na linguagem e são muito boas para uso. <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> pode chamar todas as chamadas de sistema em <a href="http://pt.wikipedia.org/wiki/Unix">Unix</a> e mais da API do Windows. Isto traz o poder e função do sistema operacional para o ambiente da linguagem interpretativa. Assim você pode fazer administração de sistemas e programação diária de processamento de texto. Esse é o maior domínio de, pelo menos, a minha vida, então eu trabalhei duro para fazer isso bom.</p>

<p><b>Bill Venners</b>: Então, basicamente, o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> me ajuda a gozar a minha vida, me ajudando a fazer meu trabalho mais rapidamente e com mais diversão?</p>

<p><b>Yukihiro Matsumoto</b>: Ele me ajuda a fazer isso. Eu não tenho certeza se <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> funciona para você, mas eu espero que sim.</p>

<h6>O Fator Humano</h6>

<p><b>Bill Venners</b>: Em uma entrevista, você disse, &#8221; Não subestime o fator humano, ainda penso que nós estamos na frente de computadores, eles são meios que estamos trabalhando para consumo humano, com humana.&#8221; O que você quer dizer com isso?</p>

<p><b>Yukihiro Matsumoto</b>: Imagine que você está escrevendo um e-mail. Está em frente do computador. Você está operando o computador, clica em um mouse e digita em um teclado, mas a mensagem será enviada a um ser humano através da internet. Então você está trabalhando antes do computador, mas com um ser humano por trás do computador. A maioria das tarefas que fazemos são para seres humanos. Por exemplo, um cálculo do imposto é contar números para que o governo possa tirar dinheiro da minha carteira, mas o governo é composto por seres humanos.</p>

<p>A maioria das nossas tarefas estão relacionadas com os seres humanos, afinal. Assim, na programação, ou pedimos ao computador para trabalhar para um ser humano, ou descrevemos nossos pensamentos para um computador de uma maneira muito clara de que até mesmo o computador possa executar. No primeiro caso, tornando o trabalho do computador para os seres humanos, o alvo é um ser humano através do computador. No segundo caso, a expressão dos nossos pensamentos claramente suficiente para ser entendido e executado por computadores, expressa a intenção de nossos cérebros humanos e, como resultado, é executada pelos computadores. Assim, em ambos os casos, o objeto aqui é humano.</p>

<p><b>Bill Venners</b>: O que é importante pensar dessa forma? Você diz: &#8220;Não subestime o fator humano.&#8221; Por quê?</p>

<p><b>Yukihiro Matsumoto</b>: Porque computadores não se importaria se eu devo fazer o esforço para se comunicar com eles ou se é fácil de se comunicar com eles. Eles não se importam se eu colocar o número de sequências de instruções de bytes em um arquivo e alimentá-lo com eles para correr, ou se uma linguagem de alto nível geradas as instruções. Com os computadores não me importo. Nós, seres humanos se preocupam com o esforço que nós pagamos. Muitas vezes as pessoas, especialmente engenheiros de computação, tem o foco sobre as máquinas. Eles pensam: &#8220;Ao fazer isso, a máquina irá correr mais rápido. Ao fazer isso, a máquina vai funcionar mais eficazmente. Ao fazer isso, a máquina algo algo algo.&#8221; Eles estão se concentrando em máquinas. Mas, na verdade temos de nos concentrar em seres humanos, sobre como os seres humanos se preocupam com fazer a programação e operação da aplicação das máquinas. Nós somos os mestres. Eles são os escravos.</p>

<p><b>Bill Venners</b>: Por enquanto, de qualquer maneira.</p>

<p><b>Yukihiro Matsumoto</b>: Por enquanto de qualquer forma, até a idade terminar.</p>

<h6>Princípio da menor surpresa</h6>

<p><b>Bill Venners</b>: Em uma entrevista, você disse &#8220;Eu projetei <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> para minimizar minha surpresa, eu estava muito surpreso quando as pessoas ao redor do mundo me disse que <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>Ruby reduziram a sua surpresa e reforçou a sua alegria de programar. Agora eu tenho certeza de que as mentes dos programadores.. são iguais em todo o mundo. &#8220;Por que o princípio da menor surpresa?</p>

<p><b>Yukihiro Matsumoto</b>: Na verdade, eu não fiz a alegação de que <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> segue o princípio da menor surpresa. Alguém sentiu a concepção de que <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> segue a filosofia, então eles começaram a dizer isso. Eu não trouxe o que, na verdade.</p>

<p>Eu queria minimizar minha frustração durante a programação, assim que eu quero minimizar meu esforço na programação. Esse era o meu objetivo principal no projeto <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>. Quero divertir-me na programação. Depois de libertar as pessoas de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> e muitos ao redor do mundo que conheci <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, eles disseram que sentem o que sinto. Eles vieram para cima com a frase do princípio da menor surpresa. Mas, na verdade, é muitas vezes incompreendido.</p>

<p><b>Bill Venners</b>: Como é mal compreendido?</p>

<p><b>Yukihiro Matsumoto</b>: Todo mundo tem um fundo individual. Alguém pode vir de <a href="http://www.python.org/">Python</a>, alguém pode vir de <a href="http://www.perl.org.br/Main/WebHome">Perl</a>, e podem ser surpreendido por diferentes aspectos da linguagem. Em seguida, eles vêm até mim e dizer: &#8220;Fiquei surpreso com esse recurso da língua, assim, portanto, o <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> viola o princípio da menor surpresa&#8221;. Espere. Espere. O princípio da menor surpresa não é apenas para você. O princípio da menor surpresa significa princípio, pelo menos da minha surpresa. E isso significa que o princípio da menor surpresa depois que você aprender <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a> muito bem. Por exemplo, eu era um programador <a href="http://pt.wikipedia.org/wiki/C%2B%2B">C++</a> antes de começar a projetar <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>. Eu programei em <a href="http://pt.wikipedia.org/wiki/C%2B%2B">C++</a> exclusivamente dois ou três anos. E depois de dois anos de programação <a href="http://pt.wikipedia.org/wiki/C%2B%2B">C++</a>, ele ainda me surpreendeu.</p>

<p>Fonte: <a href="http://www.artima.com">Artima</a></p>

&#8212;&#8212;
<p>
É isso ai amigos.. uma boa entrevista!

Até a proxima! =D</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Escrevendo iteradores personalizados #Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/08/05/escrevendo-iteradores-personalizados-number-ruby-1-dot-9-2/"/>
    <updated>2012-08-05T16:18:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/08/05/escrevendo-iteradores-personalizados-number-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `Escrevendo iteradores personalizados`&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Escrevendo iteradores personalizados</h1>


<p>A definição de característica de um método <code>Iterator</code>, é que ele invoca um bloco de código associado com a
invocação do método. Você faz isso com a declaração <code>yield</code>. O método que se segue é um iterador trivial que apenas
invoca o seu bloco duas vezes:</p>

<figure class='code'><figcaption><span>yield</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">twice</span>
</span><span class='line'>  <span class="k">yield</span>
</span><span class='line'><span class="err">  </span><span class="k">yield</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>Para passar valores de argumento para o bloco, veja a declaração do <code>yield</code> com uma lista separada por vírgulas de
expressões. Tal como acontece com invocação de método, os valores dos argumentos podem, opcionalmente, ser colocada
com parênteses. O iterador simples a seguir mostra uma utilização do <code>yield</code>:</p>

<figure class='code'><figcaption><span>Method</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<figure class='code'><figcaption><span>A assinatura da func</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'>  <span class="kd">func</span> <span class="nx">Getenv</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ok! Bora para o problema.</p>

<p>Sem a declaração desta chamada, para que a app possa saber qual será a porta que ela vai iniciar. Iremos observar nos logs do Heroku o seguinte erro:</p>

<figure class='code'><figcaption><span>A assinatura da func</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'>  <span class="mi">2015</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">28</span><span class="nx">T21</span><span class="p">:</span><span class="mi">57</span><span class="p">:</span><span class="mf">58.411180</span><span class="o">+</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span> <span class="nx">heroku</span><span class="p">[</span><span class="nx">web</span><span class="mf">.1</span><span class="p">]:</span> <span class="nx">Error</span> <span class="nx">R10</span> <span class="p">(</span><span class="nx">Boot</span> <span class="nx">timeout</span><span class="p">)</span> <span class="o">-</span><span class="p">&gt;</span> \
</span><span class='line'>  <span class="nx">Web</span> <span class="nx">process</span> <span class="nx">failed</span> <span class="nx">to</span> <span class="nx">bind</span> <span class="nx">to</span> <span class="err">$</span><span class="nx">PORT</span> <span class="nx">within</span> <span class="mi">60</span> <span class="nx">seconds</span> <span class="nx">of</span> <span class="nx">launch</span>
</span></code></pre></td></tr></table></div></figure>


<p>Já se torna visivel que esta reclamando de algo com relação a variavel de ambiente <code>$PORT</code>, e por isso o processo <code>web</code> não foi iniciado, recebendo na cara um <code>SIGKILL</code>.</p>

<p>Ao ler a app de apresentação que foi publicada para ajuda pelo Heroku, <a href="https://github.com/heroku/go-getting-started/">app Go Getting Started on Github</a> e ler mais afinco sobre este erro e sobre &lsquo;o como o Heroku Apps precisa desta declaração :)&rsquo;, saiu algo assim:</p>

<figure class='code'><figcaption><span>Declaração com a variavel de ambiente $PORT</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'>  <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;PORT&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lembrem, como estamos usando o pacote <code>os</code>, temos que fazer seu <code>import</code>.</p>

<figure class='code'><figcaption><span>Importando pacote os</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'>   <span class="kn">import</span> <span class="s">&quot;os&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Caso, não faça este <code>import</code>, verá um erro ao compilar o codigo, algo como:</p>

<figure class='code'><figcaption><span>Erro de compilação</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="err">$</span> <span class="k">go</span> <span class="nx">build</span>
</span><span class='line'><span class="err">#</span> <span class="nx">heroku</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">rrmartins</span><span class="o">/</span><span class="nx">rrtempo</span>
</span><span class='line'><span class="p">.</span><span class="o">/</span><span class="nx">servidor</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span> <span class="nx">undefined</span><span class="p">:</span> <span class="nx">os</span>
</span><span class='line'><span class="p">.</span><span class="o">/</span><span class="nx">servidor</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span> <span class="nx">undefined</span><span class="p">:</span> <span class="nx">os</span>
</span></code></pre></td></tr></table></div></figure>


<p>Então, faça o <code>import "os"</code>. :)</p>

<p>Sabendo a declaração, podemos iniciar o server:</p>

<figure class='code'><figcaption><span>Levantando o server</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'>   <span class="nx">port</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;PORT&quot;</span><span class="p">)</span>
</span><span class='line'>   <span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;:%s&quot;</span><span class="p">,</span> <span class="nx">port</span><span class="p">),</span><span class="kc">nil</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Na segunda linha do codígo acima, vemos mais dois pacotes nativos Go, <code>http</code> e <code>fmt</code>, para fazer funcionar é importante tambem fazer o <code>import</code> deles, ficando algo parecido com isso:</p>

<figure class='code'><figcaption><span>Importando mais pacotes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kn">import</span> <span class="p">(</span>
</span><span class='line'>  <span class="s">&quot;fmt&quot;</span>
</span><span class='line'>  <span class="s">&quot;os&quot;</span>
</span><span class='line'>  <span class="s">&quot;net/http&quot;</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Mas, como o problema a ser resolvido não é &lsquo;o como levantar o servidor&rsquo;, mas sim &lsquo;o que é preciso para tal&rsquo;, então vamos voltar ao caso aqui. :)</p>

<p>Declarando só com <code>port := os.Getenv("PORT")</code>, é obrigatório que nas configurações da app no Heroku tenha a variavel <code>$PORT</code> declarada, e se não tiver? Quem poderá nos defender?</p>

<p>Para não fazer um <code>if</code> deste modo:</p>

<figure class='code'><figcaption><span>if desnecessario</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'>  <span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;PORT&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">port</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;PORT&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">port</span> <span class="p">=</span> <span class="s">&quot;8080&quot;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Fazemos uma condicional de uma linha só: :)</p>

<figure class='code'><figcaption><span>Condicional lindão</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'>  <span class="nx">port</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">bool</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="kc">true</span><span class="p">:</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;PORT&quot;</span><span class="p">),</span> \
</span><span class='line'>  <span class="kc">false</span><span class="p">:</span> <span class="s">&quot;8080&quot;</span><span class="p">}[</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;PORT&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">]</span>
</span><span class='line'>  <span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;:%s&quot;</span><span class="p">,</span> <span class="nx">port</span><span class="p">),</span><span class="kc">nil</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Vejam só, se não tem a declaração da variavel <code>$PORT</code>, assumo a porta <code>8080</code>.</p>

<p>É isso ai.</p>

<p>O codígo deste post esta em <a href="https://github.com/rrmartins/rrtime">Github rrtime</a>, e rodando no Heroku <a href="https://rrtime.herokuapp.com/tempo">Heroku rrtime</a>.</p>

<p>Creditos pela ajuda da condicional mais simples ao <a href="https://twitter.com/iamvsouza">Vinicius Souza Twitter</a> | <a href="https://github.com/vsouza">Vinicius Souza Github</a> contribuidor da comunidade brasileira <a href="http://www.golangbr.org/">Golang BR</a>.</p>

<p>Valeu!</p>
]]></content>
    
  </entry>
  
  <entry>
    
=======
>>>>>>> f0fad74ab02c4e5669e277aa283faa25f065f1cb
    <title type="html"><![CDATA[Ser importante ou famoso?]]></title>
    <link href="http://rrmartins.com/blog/2015/09/21/ser-importante-ou-famoso/"/>
    
    <updated>2015-09-21T10:14:10-03:00</updated>
    <id>http://rrmartins.com/blog/2015/09/21/ser-importante-ou-famoso</id>
    
    <content type="html"><![CDATA[<p>Este é um dos pensamentos mais legais que já vi sobre este tema. Em uma correria do nossos dias, vejo muitos querendo ser famoso e tal, quando em uma breve realização, e pronto. Mas, vejo que a importancia que damos ao ser famoso é em demasia grande. Quando podemos olhar e viver para ser simples e importante. Nesse sentido, transcrevo abaixo um texto muito bom para esta reflexão do filosofo brasileiro Mario Sergio Cortella.</p>

<p>Destaco para o inicio desta boa leitura:</p>

<pre><code>Aliás, felicidade não é um estado contínuo,
felicidade é uma ocorrência eventual.
por Mario Sergio Cortella
</code></pre>

<!--more-->


<p>Segue a reflexão completa.</p>

<pre><code>Felicidade é uma vibração intensa, um momento em que eu sinto a vida
em plenitude dentro de mim, e quero que aquilo se eternize.
Felicidade é a capacidade de você ser inundado por uma alegria imensa
por aquele instante, por aquela situação. Aliás, felicidade não é
um estado contínuo, felicidade é uma ocorrência eventual.

A felicidade é sempre episódica. Você sentir a vida vibrando, seja num
abraço, seja na realização de uma obra, seja numa situação, por exemplo,
em que seu time vence, seja porque algo que você fez deu certo, seja porque
você ouviu algo que você queria ouvir. É claro que aquilo não tem
perenidade, aliás, a felicidade se marcada pela perenidade seria impossível.
Afinal de contas nós só temos a noção de felicidade pela carência.

Se eu tivesse a felicidade como algo contínuo, eu não a perceberia. Nós só
sentimos a felicidade porque ela não é contínua. Isto é, ela não é o que
acontece o tempo todo, de todos os modos. A ideia de felicidade sozinha ela
teria que ter uma questão anterior: se é possível viver sozinho. Que como a
felicidade pelo óbvio só acontece com alguém que viu ou está e viver é viver
com outros e outras, como não é possível viver sozinho?

A possibilidade da felicidade isolada, solitária é nenhuma. Pra que eu possa
ser feliz sozinho eu teria que ser capaz de viver sozinho. Mesmo a literatura,
como Robson Crusoé, por exemplo, que lida com um homem que está só, mas ele
está só depois de ter vivido com outros. Ele trás as outras pessoas na sua
memória, na sua história, no seu desejo, no seu horizonte. Não há, não há
história de ser humano em que ele tenha sido sozinho da geração até o término.
Se assim não há, não há possibilidade de se ser feliz sozinho.

Nos últimos 50 anos do século XX, nós tivemos mais desenvolvimento tecnológico
do que em toda história anterior da humanidade. Todos os 39.950 anos anteriores,
desde que o homo-sapiens era sapiens, sapiens sapiens na classificação científica,
foram menos do que os 50 anos finais do século XX. Seria a redenção da humanidade.
Uma questão: as questões centrais permaneceram. Quem sou eu?, pra que tudo isso?,
porque eu não sou feliz apenas quando possuo objeto?, porque o mal existe?, porque
que eu não tenho paz em meio a tanta convivência? Nesta hora, não só a religiosidade,
ela sofreu um revival, como a filosofia passou, de novo, a ser interessante. E
aí claro, a filosofia como autoajuda, a filosofia como autoconhecimento, a filosofia
como auto capacidade, a filosofia como prática sistemática. E de repente a gente
tem no final do século XX, em vários lugares do mundo e no Brasil também, casas
pra estudar filosofia; procura de cursos de filosofia.

Nós somos o único animal que é mortal. Todos os outros animais são imortais. Embora
todos morram, nós somos o único que além de morrer, sabe que vai morrer. Teu
cachorro tá dormindo sossegado a essa hora. Teu gato tá tranquilo. Você e eu
sabemos que vamos morrer. Desse ponto de vista, não é a morte que me importa,
porque ela é um fato. O que me importa é o que eu faço da minha vida enquanto
minha morte não acontece, pra que essa vida não seja banal, superficial, fútil,
pequena. Nesta hora, eu preciso ser capaz de fazer falta.

No dia que eu me for, e eu me vou, quero fazer falta. Fazer falta não significa ser
famoso, significa ser importante. Há uma diferença entre ser famoso e importante.
Muita gente não é famosa e é absolutamente importante. Importar; quando alguém me
leva pra dentro, importa. Ele me porta pra dentro, ele me carrega.

Eu quero ser importante. Por isso, pra ser importante, eu preciso não ter uma vida
que seja pequena. E uma vida se torna pequena quando ela é uma vida que é apoiada
só em si mesmo, fechada em si. Eu preciso transbordar, ir além da minha borda,
preciso me comunicar, preciso me juntar, preciso me repartir. Nesta hora, minha
vida que, sem dúvida, ela é curta, eu desejo que ela não seja pequena.
</code></pre>

<p>Por Mario Sergio Cortella</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Ditado Chinês do Pão]]></title>
    <link href="http://rrmartins.com/blog/2014/12/10/ditado-chines-do-pao/"/>
    
    <updated>2014-12-10T14:00:00-02:00</updated>
    <id>http://rrmartins.com/blog/2014/12/10/ditado-chines-do-pao</id>
    
    <content type="html"><![CDATA[<p>Hoje, escutei de um amigo um ditado Chinês.
Que achei muito massa ser repassado!</p>

<pre><code>Se dois homens vêm andando por uma estrada,
cada um com um pão, e, ao se encontrarem,
trocarem os pães, cada um vai embora com um pão.

Se dois homens vêm andando por uma estrada,
cada um com uma idéia, e, ao se encontrarem,
trocarem as idéias,
cada um vai embora com duas idéias.
</code></pre>

<p>Sempre crescemos com algo, ao partilhar o que de bom temos.</p>

<p>Abraços.</p>

<p>Paz e Bem</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Brincando com ChicagoBoss]]></title>
    <link href="http://rrmartins.com/blog/2014/05/18/brincando-com-chicagoboss/"/>
    
    <updated>2014-05-18T18:44:00-03:00</updated>
    <id>http://rrmartins.com/blog/2014/05/18/brincando-com-chicagoboss</id>
    
    <content type="html"><![CDATA[<p>Uma pequena Introdução:</p>

<p>Se você quiser guardar um segredo, diga a ele para um sueco. Nascido em Stockholm mais de 20
anos atrás, Erlang é a mais avançada plataforma de servidor de código aberto em
existência, mas parece que quase ninguém sabe sobre isso. Erlang pode lidar com
centenas de milhares de conexões simultâneas; ele pode gerar
milhões de processos simultâneos em menos de um segundo; código do servidor pode ser
atualizado, em produção, sem qualquer interrupção do serviço; e erros
são tratados de tal forma que falhas do servidor são extremamente raros.</p>

<!--more-->


<p>O que não gostar? Por que não é todo o mundo de programação em Erlang?
Bem, Erlang é uma linguagem funcional, o que significa que, para implementar qualquer
algoritmo, você deve usar a recursividade em vez dos laços familiares &ldquo;for&rdquo; e &ldquo;while&rdquo;.
Ao contrário de todas as grandes linguagem de script, não há sintaxe embutida
para dicionários ou mapas de hash. E para realmente escrever um servidor funcionando,
você deve aprender com uma camada adicional de magia conhecida como OTP. Estas
barreiras, na minha opinião, têm impedido Erlang de ganhar muita tração fora da Scandinavia.</p>

<p>Mas ChicagoBoss muda tudo isso. O faz Erlang acessível para hackers
que só querem escrever um site confiável em uma linguagem bacana. Usuários do ChicagoBoss
geram código para contornar o histórico hash , e tem o
cuidado com todos os negócios OTP para que você possa se ​​concentrar em escrever as características
o que precisa para o seu site. Quanto aos supostos encargos da programação funcional, acho que a recursividade
raramente é necessária em um dia de trabalho de programação; Eu diria que 99% do código de um aplicativo de servidor
simplesmente transporta dados para e de um banco de dados, de modo que no curso da construção de um
website, o programador processual caminhe dificilmente perca o seu laço &ldquo;do/while&rdquo;.</p>

<p>Se você é um programador web experiente, você provavelmente vai desfrutar de toda a
amenidades que CB tem para oferecer: um ORM avançado com suporte para
associações de bancos de dados, sharding e caches; modelos velozes compilado até Erlang bytecode;
recompilação automática e no navegador, relatório de erros; directivas simples para recargas e redirecionamentos;
rotas para construção de URLs e tratamento dos pedidos; quadros completos para envio
e recebimento de e-mail; uma fila de mensagens embutida; um quadro para a escrita
e execução de testes funcionais.</p>

<p>No final, através da combinação da plataforma de Erlang com as suas próprias inovações,
ChicagoBoss faz sites um deleite para desenvolver e implantar uma alegria.
Aplicações saliência pode ser escrito no mesmo tempo ou menos equivalentes
Rails aplicações , e eles quase nunca irá travar ou perda de memória . desde
a rede subjacente é tudo assíncrona, você pode facilmente escrever
serviços concorrentes , como o bate-papo , que antes eram só é possível em
estruturas à base de retorno de chamada (como Nginx , Node.js , Torcido, ou Perlbal ) .</p>

<p>A importância deste avanço não pode ser exagerada . É agora
viável para uma pequena equipe para desenvolver e operar um banco de dados -driven,
site altamente interativo , com muito trânsito , com muito pouco investimento de capital .
Embora Chicago chefe não posso te dizer como adquirir os usuários , o resto desta
manual irá mostrar-lhe tudo o que você precisa fazer para lidar com os seus pedidos
e (com sorte) cumprir seus desejos.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Tenho Sede]]></title>
    <link href="http://rrmartins.com/blog/2014/02/26/tenho-sede/"/>
    
    <updated>2014-02-26T20:45:00-03:00</updated>
    <id>http://rrmartins.com/blog/2014/02/26/tenho-sede</id>
    
    <content type="html"><![CDATA[<p>Tenho Sede</p>

<!--more-->


<p>
Minha alma pede ajuda<br/>
Sinto sede, Senhor<br/>
Sou como um violão sem corda<br/>
Repleto de silêncio e dor
</p>


<p><br/></p>

<p>
Lançai-me, Senhor<br/>
Teu Espírito de Amor<br/>
E minha alma reviverá<br/>
Tira toda tristeza<br/>
Que há em mim, Senhor<br/>
Renova-me com Teu Espírito de Amor
</p>


<p><br/></p>

<p>
Carrega-me nos Teus braços<br/>
Não me deixe jamais<br/>
Sou como um filho<br/>
Precisando de um Pai
</p>


<p><br/></p>

<p>
Ass,
Rodrigo Martins
</p>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Não é bem uma String]]></title>
    <link href="http://rrmartins.com/blog/2013/04/28/nao-e-bem-uma-string/"/>
    
    <updated>2013-04-28T18:35:00-03:00</updated>
    <id>http://rrmartins.com/blog/2013/04/28/nao-e-bem-uma-string</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Continuando o ultimo post <a href="http://rrmartins.com/blog/2013/04/28/as-duas-faces-de-string/">As Duas Faces de String</a>
que finaliza com a pergunta:</p>

<pre><code>Então, por que o Ruby nos fornece tanto?
</code></pre>

<p>A resposta é que nós tendemos a usar cadeias de caracteres em nosso código para duas finalidades diferentes:
O primeiro, e mais óbvio, o uso de <code>strings</code> é manter alguns dados que estamos processando. Leia naqueles
objetos livro a partir do banco de dados e você muito provavelmente vai ter suas mãos cheias de dados de
<code>string</code>, coisas como o título do livro, o autor, o nome do AOS, e o texto real.</p>

<p>A segunda maneira que nós usamos cadeias de caracteres é para representar as coisas em nossos programas,
coisas como querer encontrar <code>:all</code> registros em uma tabela. A principal coisa sobre: ​​tudo em nosso exemplo
de <code>Books</code> é que ActiveRecord pode reconhecê-lo quando vê-lo - o código precisa saber quais registros para
voltar, e <code>:all</code> é um flag que diz que ele deve retornar cada um. O bom de usar algo como <code>:all</code> para esse
tipo de &ldquo;significa&rdquo; que ele também faz sentido para os seres humanos: Você é muito mais propenso a reconhecer
que <code>:all</code> quando você se depara com ele do que <code>0</code>, ou <code>-1</code>, ou mesmo <code>0x29ef</code>(Deus me perdoe!).</p>

<p>Estes dois usos para cadeias de caracteres - para tarefas de processamento de dados regulares sobre a
um lado, e, postos de trabalho, do tipo marcador simbólicos internos sobre o outro - faz muita
diferença sobre demandas de objetos. Se você estiver processando dados, você vai querer ter toda a gama de
ferramentas de manipulação de <code>string</code> na ponta dos dedos: Você pode querer os dez primeiros caracteres do
título, ou você pode querer obter o seu comprimento ou ver se ele corresponde a alguma expressão regular. Por
outro lado, se você estiver usando alguns caracteres para estar em algo no seu código, você provavelmente não
está muito interessado em brincar com os caracteres reais. Em vez disso, neste segundo caso, você só precisa
saber se essa coisa é o flag que fala para você encontrar todos os registros ou apenas o primeiro registro.
Principalmente, quando você quer alguns caracteres para representar algo, você simplesmente precisa saber se
esta é a forma rápida e confiável.</p>

<p>Até mais galera! :)</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[As duas faces de String]]></title>
    <link href="http://rrmartins.com/blog/2013/04/28/as-duas-faces-de-string/"/>
    
    <updated>2013-04-28T16:30:00-03:00</updated>
    <id>http://rrmartins.com/blog/2013/04/28/as-duas-faces-de-string</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Às vezes, uma boa maneira de explicar um assunto problemático é se engajar em uma ficção um pouco criativa. Você começa com uma
explicação simplista e, uma vez que se aprofunda um pouco, você trabalha o seu caminho de lá para voltar para o mundo real.
Com este espírito, vou começar a exploração de símbolos com uma ligeira simplificação: Símbolos são realmente apenas strings.
Isto não é tão improvável quanto parece: Pense sobre a string &ldquo;dog&rdquo; e seu primo mais próximo simbólico :dog. A única coisa que
bate no rosto sobre esses dois objetos é que eles são ambos essencialmente três personagens: um &ldquo;d&rdquo;, um &ldquo;o&rdquo;, e &ldquo;g&rdquo;.</p>

<p>Strings e símbolos também são razoavelmente permutáveis ​​em código na vida real: Tome este exemplo familiar de algum de código no
ActiveRecord, que encontra todos os registros no livros de mesa:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>book = Book.find(:all)</span></code></pre></td></tr></table></div></figure>


<p>O argumento para o método <code>find</code> é simplesmente um flag, há que dizer que queremos encontrar todos os registros de livros, e não
apenas o primeiro registro, e não apenas o último registro, mas todos eles. O valor real que passamos para <code>Book.find</code> realmente
não importa muito. Podemos imaginar que, se tivesse tempo e motivação, podemos ir nas entranhas do <code>ActiveRecord</code> e reescrever o
código para que pudéssemos usar uma string para sinal de que queria que todos os livros:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>book = Book.find('all')</span></code></pre></td></tr></table></div></figure>


<p>Portanto, não é a minha explicação simplificada de símbolos: Além do fato de que a digitação de <code>:all</code> exige um keystroke menos
do que digitar <code>'all'</code>, não há realmente muito a distinguir um símbolo a partir de uma string. Então, por que o Ruby nos fornece tanto?</p>

<p>Continuando no post <a href="http://rrmartins.com/blog/2013/04/28/nao-e-bem-uma-string/">Não é bem uma String</a>&hellip;</p>

<p>Até mais galera! :)</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Expressões Regulares em Ruby]]></title>
    <link href="http://rrmartins.com/blog/2013/04/28/expressoes-regulares-em-ruby/"/>
    
    <updated>2013-04-28T13:52:00-03:00</updated>
    <id>http://rrmartins.com/blog/2013/04/28/expressoes-regulares-em-ruby</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Olá amigos,</p>

<p>Ando meio sumido, mas pretendo voltar a fazer os posts, e dar continuidade nos estudos.</p>

<p>Volto falando um pouco de <code>Expressão Regular</code> em Ruby(<a href="http://ruby-doc.org/core-1.9.3/Regexp.html">1.9.3</a>, <a href="http://ruby-doc.org/core-2.0/Regexp.htm">2.0</a>), vou abordar as duas ultimas versões do Ruby, mas gostaria de deixar claro que a nova versão <a href="http://ruby-doc.org/core-2.0/">2.0</a> é a que estou usando, e não esta me deixando na mão.</p>

<p>Em Ruby, a expressão regular, ou <code>Regexp</code>(<a href="http://ruby-doc.org/core-1.9.3/Regexp.html">1.9.3</a>, <a href="http://ruby-doc.org/core-2.0/Regexp.htm">2.0</a>), tem sua própria sintaxe literal especial. Para fazer uma expressão regular em Ruby que você encerra o seu padrão entre as barras. Então, em Ruby nossa expressão regular seria:</p>

<figure class='code'><figcaption><span>Regexp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">/\d\d:\d\d (AM|PM)/</span>
</span></code></pre></td></tr></table></div></figure>


<p>Você usa o operador <code>=~</code> para testar se uma expressão regular corresponde a uma string. Assim, se quisermos corresponder à expressão regular acima com um tempo real que seria executado:</p>

<figure class='code'><figcaption><span>Regexp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 1.9.3 e 2.0</span>
</span><span class='line'> <span class="o">&gt;</span> <span class="nb">puts</span> <span class="sr">/\d\d:\d\d (AM|PM)/</span> <span class="o">=~</span> <span class="s1">&#39;10:24 PM&#39;</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>Que o zero está tentando nos dizer muitas coisas. Primeiro, ele está dizendo que a expressão correspondente, esta começando no
índice zero. Em segundo lugar, o zero está nos dizendo é que, quando você combinar uma expressão regular, Ruby verifica ao longo
da String, procurando um conjunto em qualquer lugar da string. Podemos ver a digitalização em ação com este exemplo seguinte:</p>

<figure class='code'><figcaption><span>Regexp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 1.9.3 e 2.0</span>
</span><span class='line'> <span class="o">&gt;</span> <span class="nb">puts</span> <span class="sr">/PM/</span> <span class="o">=~</span> <span class="s1">&#39;10:24 PM&#39;</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="mi">6</span>
</span></code></pre></td></tr></table></div></figure>


<p>Que seis é uma indicação de onde o Regexp encontrou, mas só depois de Ruby digitalizar bem a string. Se não houver
correspondência, então você não vai ter um retorno para o seu problema, de modo a que este:</p>

<figure class='code'><figcaption><span>Regexp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 1.9.3 e 2.0</span>
</span><span class='line'> <span class="o">&gt;</span> <span class="sr">/May/</span> <span class="o">=~</span> <span class="s1">&#39;Sometime in June&#39;</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="kp">nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Voltará <code>nil</code>. Desde o operador <code>=~</code> retorna um número quando se encontra uma correspondência e <code>nil</code> se não, você pode usar
conjuntos de expressões regulares como booleanos:</p>

<figure class='code'><figcaption><span>Regexp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 1.9.3 e 2.0</span>
</span><span class='line'> <span class="o">&gt;</span> <span class="n">the_time</span> <span class="o">=</span> <span class="s1">&#39;10:24 AM&#39;</span>
</span><span class='line'> <span class="o">&gt;</span> <span class="nb">puts</span> <span class="s2">&quot;É de manhã!&quot;</span> <span class="k">if</span> <span class="sr">/AM/</span> <span class="o">=~</span> <span class="n">the_time</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="err">É</span> <span class="n">de</span> <span class="n">manh</span><span class="err">ã</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>O operador <code>=~</code> também é ambidestro: Não importa se a string ou a expressão regular vem em primeiro lugar, para que pudéssemos
refazer o último exemplo, como:</p>

<figure class='code'><figcaption><span>Regexp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 1.9.3 e 2.0</span>
</span><span class='line'> <span class="o">&gt;</span> <span class="nb">puts</span> <span class="s2">&quot;É de manhã!&quot;</span> <span class="k">if</span> <span class="s1">&#39;10:24 AM&#39;</span> <span class="o">=~</span> <span class="sr">/AM/</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="err">É</span> <span class="n">de</span> <span class="n">manh</span><span class="err">ã</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como disse, as expressões regulares são por padrão <code>case sensitive</code>: <code>/AM/</code> não corresponde <code>/am/</code>. Felizmente, você pode
transformar esse <code>case sensitive</code> colocando um i no fim de sua expressão, de modo que este:</p>

<figure class='code'><figcaption><span>Regexp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 1.9.3 e 2.0</span>
</span><span class='line'> <span class="o">&gt;</span> <span class="nb">puts</span> <span class="s2">&quot;É de manhã!&quot;</span> <span class="k">if</span> <span class="sr">/AM/i</span> <span class="o">=~</span> <span class="s1">&#39;am&#39;</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="err">É</span> <span class="n">de</span> <span class="n">manh</span><span class="err">ã</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Irá imprimir algo!</p>

<p>Além de seu uso mais ou menos independente com o operador <code>=~</code>, expressões regulares também entram em jogo nos métodos de <code>string</code>
que envolvem a pesquisa. Assim, você pode passar uma expressão regular para o método <a href="http://ruby-doc.org/core-2.0/String.html#method-i-gsub">gsub</a> da classe <code>string</code>, talvez para apagar todo o conteúdo de um documento:</p>

<figure class='code'><figcaption><span>Regexp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Document</span>
</span><span class='line'>  <span class="c1"># A maioria da classe omitida...</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">obscure_times!</span>
</span><span class='line'>    <span class="vi">@content</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span> <span class="sr">/\d\d:\d\d (AM|PM)/</span><span class="p">,</span> <span class="s1">&#39;**:** **&#39;</span> <span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Expressão Regular é muito usado e em alguns momentos ajuda a reduzir bastante as condicionais.</p>

<p>Até mais&hellip; :)</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[[Tradução] Ruby 2.0 por Exemplos]]></title>
    <link href="http://rrmartins.com/blog/2013/02/26/traducao-ruby-2-dot-0-por-exemplos/"/>
    
    <updated>2013-02-26T22:54:00-03:00</updated>
    <id>http://rrmartins.com/blog/2013/02/26/traducao-ruby-2-dot-0-por-exemplos</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Olá amigos,</p>

<p>Tudo tranquilo?</p>

<p>Estava conversando com o <a href="https://twitter.com/malafortune">Marc-Andre Lafortune</a>, do blog <a href="http://blog.marc-andre.ca/">Marc Andre</a>, sobre a nova versão do <a href="http://www.ruby-lang.org/en/news/2013/02/24/ruby-2-0-0-p0-is-released/">Ruby 2.0</a>, e ele me permitiu traduzir o <a href="http://blog.marc-andre.ca/2013/02/23/ruby-2-by-example/">post dele</a> e ai vai.. :)</p>

<p>Antes de começar a tradução, gostaria de lembrar do que disse o proprio criador do #Ruby no <a href="https://twitter.com/yukihiro_matz/statuses/305334327938519040">twitter</a>:</p>

<blockquote><p>20 years has passed since I started developing Ruby. I really appreciate your support from the great Ruby community. Thank you!</p><footer><strong>@yukihiro_matz</strong> <cite><a href='https://twitter.com/yukihiro_matz/status/305334327938519040'>twitter.com/yukihiro_matz/&hellip;</a></cite></footer></blockquote>


<p>Neste trecho, <a href="https://twitter.com/yukihiro_matz">Matz</a> diz que desde quando começou a desenvolver o Ruby já se passou 20 anos e agradece a toda a comunidade que ajuda direta ou indiretamente.</p>

<p>Vamos a tradução&hellip; :D</p>

<hr />

<p>Tradução</p>

<hr />

<p>Um rápido resumo de alguns dos novos recursos do <a href="http://www.ruby-lang.org/en/news/2013/02/24/ruby-2-0-0-p0-is-released/">Ruby 2.0.0</a>:</p>

<h3>Alterações na Linguagem</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Este método espera um bloco. Gera n valores da forma</span>
</span><span class='line'><span class="c1"># M * i + c, para i de 0 .. n-1, e os yield deles, um de cada vez,</span>
</span><span class='line'><span class="c1"># Para o bloco associado.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">sequencia</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="err">  </span><span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="c1"># loop n vezes</span>
</span><span class='line'><span class="err">    </span><span class="k">yield</span> <span class="n">m</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span> <span class="c1"># Invocar o bloco, e passar um valor a ela</span>
</span><span class='line'><span class="err">    </span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Incrementa i de cada vez</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Aqui está uma invocação desse método, com um bloco.</span>
</span><span class='line'><span class="c1"># Ela imprime os valores 1, 6 e 11</span>
</span><span class='line'><span class="n">sequencia</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="nb">puts</span> <span class="n">y</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>Nomenclatura: rendimento e iteradores

Dependendo da sua experiência em programação, você pode encontrar os
termos "yield" e "iterator". O método de sequencia mostrado anteriormente é 
um bom exemplo claro de por que o 'yield' tem o nome do que ele faz. Depois de calcular cada número 
na sequencia, o método 'yield' de controle (e produz o número calculado) para o bloco,
de modo que o bloco pode trabalhar com ele. Nem sempre é isso claro,
no entanto, em algum código que possa parecer como se fosse o bloco que é
produzindo um resultado de volta para o método que o invocou.

Um método como sequencia que espera um bloco e invoca-lo várias vezes é chamado de
'iterador', porque parece e se comporta como um loop. Isso pode ser confuso se você está 
acostumado a linguagens como Java em que iteradores são objetos. Em Java, o código que o cliente usa,
o iterador está no controle e 'puxa' os valores do iterador quando ela precisa deles. 
Em Ruby, o método iterator está no controle e 'empurra' os valores para o bloco que quer.

Este problema de nomenclatura está relacionada com a distinção entre 'Iteradores interno'
e 'iteradores externos'.
</code></pre>

<p>Aqui está outro exemplo de um &#8216;iterador&#8217; em Ruby; ele passa dois argumentos para o seu bloco. Vale notar
que a implementação deste iterador usa outro iterador internamente:</p>

<figure class='code'><figcaption><span>yield</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9:</span>
</span><span class='line'>  <span class="c1"># (Do action_view/helpers/text_helper.rb)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">first_value</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>
</span><span class='line'>  <span class="n">options</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">extract_options!</span>
</span><span class='line'>  <span class="nb">name</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">first_value</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="nb">name</span><span class="p">:</span> <span class="s1">&#39;default&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># ATENÇÃO: Não exatamente idêntica, como palavras-chave são aplicadas:</span>
</span><span class='line'><span class="n">cycle</span><span class="p">(</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="s1">&#39;even&#39;</span><span class="p">,</span> <span class="n">nme</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; ArgumentError: unknown keyword: nme</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Para obter o mesmo resultado e melhor exato:</span>
</span><span class='line'><span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">first_value</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="nb">name</span><span class="p">:</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">ignore_extra</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isso faz com que as definições de método seja muito flexível. Em resumo:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<<<<<<< HEAD
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Gera n pontos uniformemente espaçados em torno da circunferência de um</span>
</span><span class='line'><span class="c1"># Círculo de raio r centrado em (0,0). Rendimento da coordenadas X e Y</span>
</span><span class='line'><span class="c1"># De cada ponto ao bloco associado.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">circle</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="n">n</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>    <span class="c1">#  Observe que este método é implementado com um bloco</span>
</span><span class='line'>    <span class="n">angle</span> <span class="o">=</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">n</span>
</span><span class='line'>    <span class="k">yield</span> <span class="n">r</span><span class="o">*</span><span class="no">Math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="no">Math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Esta invocação das impressões iterador:</span>
</span><span class='line'><span class="c1"># (1,00, 0,00) (0,00, 1,00) (-1,00, 0,00) (-0,00, -1,00)</span>
</span><span class='line'><span class="n">circle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span> <span class="nb">printf</span> <span class="s2">&quot;(%.2f, %.2f)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Usando a palavra-chave <code>yield</code> realmente é muito parecido com invocação de um método.
Parênteses nos argumentos são opcionais. Você pode usar <code>*</code> para expandir uma matriz de argumentos
individuais. <code>yield</code> ainda permite que você passe um hash literal sem as chaves ao seu redor. Ao contrário
de uma invocação de método, no entanto, uma expressão <code>yield</code> pode não ser seguido por um bloco.
Você não pode passar um bloco a um bloco.</p>

<p>Se um método é invocado sem um bloco, é um erro para o método <code>yield</code>, porque não há nada para <code>yield</code>. Às vezes
você querer escrever um método que produz a um bloco se for fornecido, mas tem alguma ação padrão (outro de lançar
um erro), se invocado com nenhum bloco. Para fazer isso, use <code>block_given?</code> para determinar se há um bloco
associado com a chamada. <code>block_given?</code>, e seu sinônimo <code>iterator?</code>, são métodos do Kernel, então eles agem como
funções mundiais. Aqui está um exemplo:</p>

<figure class='code'><figcaption><span>block_biven?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">name</span><span class="p">({</span><span class="n">required_arguments</span><span class="p">,</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">}</span>
</span><span class='line'>         <span class="p">{</span><span class="n">optional_arguments</span><span class="p">,</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">}</span>
</span><span class='line'>         <span class="p">{</span><span class="o">*</span><span class="n">rest</span> <span class="o">||</span> <span class="n">additional_required_arguments</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">}</span> <span class="c1"># Você Sabia?</span>
</span><span class='line'>         <span class="p">{</span><span class="n">keyword_arguments</span><span class="p">:</span> <span class="s2">&quot;with_defaults&quot;</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">}</span>
</span><span class='line'>         <span class="p">{</span><span class="o">**</span><span class="n">rest_of_keyword_arguments</span><span class="p">}</span>
</span><span class='line'>         <span class="p">{</span><span class="o">&amp;</span><span class="n">block_capture</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Em <a href="http://www.ruby-lang.org/en/news/2013/02/24/ruby-2-0-0-p0-is-released/">Ruby 2.0.0</a>, argumentos devem ter padrões, ou então deve ser capturado por <code>**extra</code> no final. Próxima versão <a href="https://bugs.ruby-lang.org/issues/7701">permitirá</a> argumentos obrigatórios, por exemplo, <code>def hello(optional: 'default', required:)</code>, mas há <a href="http://stackoverflow.com/questions/13250447/can-i-have-required-named-parameters-in-ruby-2-x/15078852#15078852">maneiras de fazer isso agora</a>.</p>

<p>Padrões, para parâmetros opcionais ou argumentos de palavras-chave, pode ser na maior parte qualquer expressão, incluindo chamadas de método para o objeto atual e pode usar os parâmetros anteriores.</p>

<p>Um exemplo complexo que mostra a maior parte deste:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Retorna um array com n elementos da forma m * i + c</span>
</span><span class='line'><span class="c1"># Se um bloco é dado, igualmente produzir cada elemento para o bloco</span>
</span><span class='line'><span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">[]</span>                  <span class="c1"># Inicializa variáveis</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>                  <span class="c1"># Loop n vezes</span>
</span><span class='line'>    <span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">c</span>                 <span class="c1"># calcula o valor</span>
</span><span class='line'>    <span class="k">yield</span> <span class="n">y</span> <span class="k">if</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">y</span>                      <span class="c1"># armazena o valor</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">s</span>             <span class="c1"># Retorna o array de valores</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso aí!</p>

<p>Até o proximo!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objetos Enumeráveis #Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/07/25/objetos-enumeraveis-number-ruby-1-dot-9-2/"/>
    <updated>2012-07-25T22:50:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/07/25/objetos-enumeraveis-number-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `Objetos Enumeráveis`&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Objetos Enumeráveis</h1>


<p><code>Array</code>, <code>Range</code>, <code>Hash</code>, e um número de outras classes definem um iterador <code>each</code> que passa cada elemento da
coleção para o bloco associado. Este é talvez o mais comumente usado iterador em Ruby, o loop só funciona para
iterar sobre objetos que têm o método <code>each</code>. Exemplos de iteradores <code>each</code>:</p>

<figure class='code'><figcaption><span>Metodo each</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">].</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">print</span> <span class="n">x</span> <span class="p">}</span>   <span class="c1"># =&gt; prints &quot;123&quot;</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">each</span>  <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">print</span> <span class="n">x</span> <span class="p">}</span>   <span class="c1"># =&gt; prints &quot;123&quot; Same as 1.upto(3)</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>O iterador <code>each</code> não é só para as classes tradicionais &#8220;de estrutura de dados&#8221;. Classes <code>IO</code> Ruby definem um
iterador <code>each</code> que cada linha de texto lido do objeto produz <code>Input/Output</code>. Assim, você pode processar as linhas
de um arquivo em Ruby com um código como esse:</p>

<figure class='code'><figcaption><span>Metodo each para File</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>       <span class="c1"># Abrir arquivo nomeado, passando f como parametro</span>
</span><span class='line'>  <span class="n">f</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">line</span><span class="o">|</span> <span class="nb">print</span> <span class="n">line</span> <span class="p">}</span>    <span class="c1"># Imprimir f em cada linha</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>A maioria das classes que definem um método <code>each</code> também incluem o módulo <code>Enumerable</code>, que define um número de
iteradores mais especializados que são implementados em cima do método <code>each</code>. Um iterador é útil tal <code>each_with_index</code>, o que nos permite adicionar a linha de numeração para o exemplo anterior:</p>

<figure class='code'><figcaption><span>Metodo each com Index</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">C</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">hi</span><span class="p">(</span><span class="n">needed</span><span class="p">,</span> <span class="n">needed2</span><span class="p">,</span>
</span><span class='line'>         <span class="n">maybe1</span> <span class="o">=</span> <span class="s2">&quot;42&quot;</span><span class="p">,</span> <span class="n">maybe2</span> <span class="o">=</span> <span class="n">maybe1</span><span class="o">.</span><span class="n">upcase</span><span class="p">,</span>
</span><span class='line'>         <span class="o">*</span><span class="n">args</span><span class="p">,</span>
</span><span class='line'>         <span class="n">named1</span><span class="p">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="n">named2</span><span class="p">:</span> <span class="n">a_method</span><span class="p">(</span><span class="n">named1</span><span class="p">,</span> <span class="n">needed2</span><span class="p">),</span>
</span><span class='line'>         <span class="o">**</span><span class="n">options</span><span class="p">,</span>
</span><span class='line'>         <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">a_method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># ...</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">C</span><span class="o">.</span><span class="n">instance_method</span><span class="p">(</span><span class="ss">:hi</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
</span><span class='line'><span class="c1"># =&gt; [ [:req, :needed], [:req, :needed2],</span>
</span><span class='line'><span class="c1">#      [:opt, :maybe1], [:opt, :maybe2],</span>
</span><span class='line'><span class="c1">#      [:rest, :args],</span>
</span><span class='line'><span class="c1">#      [:key, :named1], [:key, :named2],</span>
</span><span class='line'><span class="c1">#      [:keyrest, :options],</span>
</span><span class='line'><span class="c1">#      [:block, :block] ]</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://bugs.ruby-lang.org/issues/7922">Bug conhecido</a>: não é atualmente possível ignorar opções extras sem citar o argumento <code>**</code>.</p>

<h3>Criação de lista de Symbol</h3>

<p>Maneira fácil de criar listas de símbolos com <code>%i</code> e <code>%I</code> (onde i é para uso interno):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9:</span>
</span><span class='line'><span class="no">KEYS</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:foo</span><span class="p">,</span> <span class="ss">:bar</span><span class="p">,</span> <span class="ss">:baz</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="no">KEYS</span> <span class="o">=</span> <span class="o">%</span><span class="n">i</span><span class="o">[</span><span class="n">foo</span> <span class="n">bar</span> <span class="n">baz</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Codificação padrão é UTF-8</h3>

<p>Nenhum comentário magico é necessário caso a codificação for UTF-8.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9:</span>
</span><span class='line'><span class="c1"># encoding: utf-8</span>
</span><span class='line'><span class="c1"># ^^^ previous line was needed!</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;❤ Rodrigo Martins ❤&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;❤ Rodrigo Martins ❤&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Variáveis ​​não utilizadas pode começar com _</h3>

<p>Você sabia que Ruby pode avisá-lo sobre as variáveis ​​utilizadas?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
</span><span class='line'>  <span class="n">f</span><span class="o">.</span><span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">line</span><span class="p">,</span><span class="n">number</span><span class="o">|</span>
</span><span class='line'>    <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">number</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Alguns dos iteradores mais comumentes utilizados são os métodos <code>Enumerable</code>, <code>collect</code>, <code>select</code>, <code>reject</code>, e
<code>inject</code>. O método <code>collect</code> (também conhecido como <code>map</code>) executa o seu bloco associado para cada elemento do objeto
enumerável, e coleta os valores de retorno dos blocos em um <code>array</code>:</p>

<figure class='code'><figcaption><span>Metodo Collect</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">quadrados</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">].</span><span class="n">collect</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">}</span>   <span class="c1"># =&gt; [1,4,9]</span>
</span></code></pre></td></tr></table></div></figure>


<p>O método <code>select</code> invoca o bloco associado para cada elemento no objeto enumerável, e retorna uma matriz de
elementos para a qual o bloco retorna um outro valor <code>false</code> ou <code>nil</code>. Por exemplo:</p>

<figure class='code'><figcaption><span>Metodo Select</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">nivela</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span> <span class="c1"># =&gt; [2,4,6,8,10]</span>
</span></code></pre></td></tr></table></div></figure>


<p>O método <code>reject</code> é simplesmente o oposto de <code>select</code>, ele retorna uma matriz de elementos para a qual o bloco
retorna <code>nil</code> ou <code>false</code>. Por exemplo:</p>

<figure class='code'><figcaption><span>Metodo reject</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">odds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reject</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span> <span class="c1"># =&gt; [1,3,5,7,9]</span>
</span></code></pre></td></tr></table></div></figure>


<p>O método <code>inject</code> é um pouco mais complicado do que os outros. Ele invoca o bloco associado com dois argumentos.
O primeiro argumento é um valor acumulado de algum tipo das iterações anteriores. O segundo argumento é o próximo
o objeto enumerável. O valor de retorno do bloco é o primeiro argumento bloqueado para a próxima iteração, ou torna-
se o valor de retorno do iterador após a última iteração. O valor inicial da variável acumula ou é o argumento de
<code>inject</code>, se houver um, ou o primeiro elemento do objeto enumerável. (Neste caso, o bloco é invocado. Apenas uma vez durante os primeiros dois elementos). Exemplos para <code>injects</code> mais claros:</p>

<figure class='code'><figcaption><span>Metodo Inject</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">data</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">]</span>
</span><span class='line'><span class="n">sum</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">inject</span><span class="p">{</span><span class="o">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">x</span><span class="o">|</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">x</span> <span class="p">}</span>      <span class="c1"># =&gt; 14    (2+5+3+4)</span>
</span><span class='line'><span class="n">floatprod</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="p">){</span><span class="o">|</span><span class="nb">p</span><span class="p">,</span><span class="n">x</span><span class="o">|</span> <span class="nb">p</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span>  <span class="c1"># =&gt; 120.0 (1.0*2*5*3*4)</span>
</span><span class='line'><span class="n">max</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">inject</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="p">,</span><span class="n">x</span><span class="o">|</span> <span class="n">m</span><span class="o">&gt;</span><span class="n">x</span> <span class="p">?</span> <span class="n">m</span> <span class="p">:</span> <span class="n">x</span> <span class="p">}</span>     <span class="c1"># =&gt; 5     (elemento maior)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Veja <a href="http://ruby-doc.org/core-1.9.2/Enumerable.html">Objetos Enumeráveis</a> ​​para obter mais detalhes sobre o <code>Módulo Enumerable</code> e a seus iteradores.</p>

<p>Até a proxima amigos&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Iteradores Numéricos #Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/07/14/iteradores-numericos/"/>
    <updated>2012-07-14T22:52:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/07/14/iteradores-numericos</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `Iteradores Numéricos`&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Iteradores Numéricos</h1>


<p>O núcleo do <code>Ruby API</code> fornece um número de iteradores padrão. Os métodos de loops do Kernel se comporta como um
loop infinito, executando seu bloco associado repetidamente até que o bloco executa um <code>return</code>, <code>break</code>, ou outra
declaração que sai do laço.</p>

<p>A classe <code>Integer</code> define três iteradores usados. O método <code>upto</code> chama seu bloco associado uma vez para cada número
inteiro entre o número inteiro no qual ele é invocado e o número inteiro que é passado como um argumento.
Por exemplo:</p>

<figure class='code'><figcaption><span>upto</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">4</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">6</span><span class="p">){</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">print</span> <span class="n">x</span><span class="p">}</span> <span class="c1"># =&gt; prints &quot;456&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como você pode ver, <code>upto</code> intera cada número inteiro para o bloco associado, e inclui tanto o ponto de partida e o
ponto final na iteração. Em geral, <code>n.upto(m)</code> é executado o bloco <code>m-n +1</code> vezes.</p>

<p>O método <code>downto</code> é como <code>upto</code> mas itera a partir de um maior número para um número menor.</p>

<p>Quando o método <code>Integer.times</code> é chamado no <code>n</code> inteiro, invoque o seu bloco de <code>n vezes</code>, passando os valores de
<code>0 a n-1</code> em iterações sucessivas. Por exemplo:</p>

<figure class='code'><figcaption><span>times</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">3</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">print</span> <span class="n">x</span> <span class="p">}</span>    <span class="c1"># =&gt; prints &quot;012&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Em geral, é <code>n.times</code> equivalente a <code>0.upto(n-1)</code>.</p>

<p>Se você quer fazer uma iteração numérica usando um ponto flutuante de números, você pode usar o método <code>step</code> mais
complexo definido pela classe numérica. O iterador a seguir, por exemplo, começa a 0 e itera em passos de 0.1 até
atingir <code>Math::PI</code>:</p>

<figure class='code'><figcaption><span>metodo step</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">0</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">,</span> <span class="mi">0</span><span class="o">.</span><span class="mi">1</span><span class="p">){</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="no">Math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[unless #Ruby 1.9]]></title>
    <link href="http://rrmartins.github.com/blog/2012/07/05/unless-number-ruby-1-dot-9/"/>
    <updated>2012-07-05T01:57:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/07/05/unless-number-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de `unless`&#8230; Estranho para alguns, mas, veremos que é simples!</p>




<h1>Unless</h1>


<p><code>unless</code>, como uma declaração ou um modificador, é o oposto do <code>case</code>: ele executa o código apenas se uma expressão
associada é avaliada como <code>false</code> ou <code>nil</code>. Sua sintaxe é como <code>if</code>, exceto que as cláusulas <code>elsif</code>, que não são
permitidas:</p>

<figure class='code'><figcaption><span>Declaração unless</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Qualquer versão do Ruby, com aviso em:</span>
</span><span class='line'><span class="n">ruby</span> <span class="o">-</span><span class="n">w</span> <span class="o">-</span><span class="n">e</span> <span class="s2">&quot;</span>
</span><span class='line'><span class="s2">  def hi</span>
</span><span class='line'><span class="s2">    hello, world = &#39;hello, world&#39;.split(&#39;, &#39;)</span>
</span><span class='line'><span class="s2">    world</span>
</span><span class='line'><span class="s2">  end&quot;</span>
</span><span class='line'><span class="c1"># =&gt; warning: assigned but unused variable - hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>A maneira de evitar o aviso era usar <code>_</code>. Agora podemos usar qualquer nome de variável começando com um underscore:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9</span>
</span><span class='line'><span class="n">ruby</span> <span class="o">-</span><span class="n">w</span> <span class="o">-</span><span class="n">e</span> <span class="s2">&quot;</span>
</span><span class='line'><span class="s2">  def foo</span>
</span><span class='line'><span class="s2">    _, world = &#39;hello, world&#39;.split(&#39;, &#39;)</span>
</span><span class='line'><span class="s2">    world</span>
</span><span class='line'><span class="s2">  end&quot;</span>
</span><span class='line'><span class="c1"># =&gt; no warning</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0</span>
</span><span class='line'><span class="n">ruby</span> <span class="o">-</span><span class="n">w</span> <span class="o">-</span><span class="n">e</span> <span class="s2">&quot;</span>
</span><span class='line'><span class="s2">  def hi</span>
</span><span class='line'><span class="s2">    _hello, world = &#39;hello, world&#39;.split(&#39;, &#39;)</span>
</span><span class='line'><span class="s2">    world</span>
</span><span class='line'><span class="s2">  end&quot;</span>
</span><span class='line'><span class="c1"># =&gt; no warning either</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Mudanças das Classes Principais</h2>

<h3>Prepend</h3>

<p><a href="http://ruby-doc.org/core-2.0/String.html#method-i-prepend">Module#prepend</a> insere um módulo no início da cadeia de ligação. Pode muito bem substituir por <code>alias_method_chain</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Uma maneira, declaração unless</span>
</span><span class='line'><span class="k">unless</span> <span class="n">condition</span>
</span><span class='line'>  <span class="n">code</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Duas vias da declaração unless</span>
</span><span class='line'><span class="k">unless</span> <span class="n">condition</span>
</span><span class='line'>  <span class="n">code</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">code</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># modificador unless</span>
</span><span class='line'><span class="n">code</span> <span class="k">unless</span> <span class="n">condition</span>
</span></code></pre></td></tr></table></div></figure>


<p>A declaração <code>unless</code>, como a declaração <code>if</code>, exige que a condição e o código são separados por uma mudança de linha,
uma vírgula, ou a palavra-chave <code>then</code>. Também como <code>if</code>, as declarações <code>unless</code> são expressões e retornam o valor do
código que são executados, ou <code>nil</code> se executar nada:</p>

<figure class='code'><figcaption><span>Declaração unless</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Chama o método to_s sobre o objeto, a menos que o objeto &#39;o&#39; for nulo</span>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="k">unless</span> <span class="n">o</span><span class="o">.</span><span class="n">nil?</span>                        <span class="c1"># Nova linha de separação</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="k">unless</span> <span class="n">o</span><span class="o">.</span><span class="n">nil?</span> <span class="k">then</span> <span class="n">o</span><span class="o">.</span><span class="n">to_s</span> <span class="k">end</span>        <span class="c1"># separador então</span>
</span></code></pre></td></tr></table></div></figure>


<p>Para uma única linha condicionais como esta, a forma do modificador <code>unless</code> é geralmente mais clara:</p>

<figure class='code'><figcaption><span>Unless</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">to_s</span> <span class="k">unless</span> <span class="n">o</span><span class="o">.</span><span class="n">nil?</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ruby não tem nenhum equivalente da cláusula <code>elsif</code> para a condicional <code>unless</code>. Você ainda pode escrever um multiway da instrução <code>unless</code>, no entanto, se você está disposto a ser um pouco mais detalhado:</p>

<figure class='code'><figcaption><span>unless</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9:</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Range</span>
</span><span class='line'>  <span class="c1"># Do active_support/core_ext/range/include_range.rb</span>
</span><span class='line'>  <span class="c1"># Estende o padrão Range#include? para suportar comparações de range</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">include_with_range?</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="o">::</span><span class="no">Range</span><span class="p">)</span>
</span><span class='line'>      <span class="c1"># 1...10 inclue 1..9 mas não inclue 1..10.</span>
</span><span class='line'>      <span class="n">operator</span> <span class="o">=</span> <span class="n">exclude_end?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">value</span><span class="o">.</span><span class="n">exclude_end?</span> <span class="p">?</span> <span class="p">:</span><span class="o">&lt;</span> <span class="p">:</span> <span class="p">:</span><span class="o">&lt;=</span>
</span><span class='line'>      <span class="n">include_without_range?</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="n">last</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">include_without_range?</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">alias_method_chain</span> <span class="ss">:include?</span><span class="p">,</span> <span class="ss">:range</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Range</span><span class="o">.</span><span class="n">ancestors</span> <span class="c1"># =&gt; [Range, Enumerable, Object...]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0</span>
</span><span class='line'><span class="k">module</span> <span class="nn">IncludeRangeExt</span>
</span><span class='line'>  <span class="c1"># Estende o padrão Range#include? para suportar comparações de range</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">include?</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="o">::</span><span class="no">Range</span><span class="p">)</span>
</span><span class='line'>      <span class="c1"># 1...10 inclue 1..9 mas não inclue 1..10.</span>
</span><span class='line'>      <span class="n">operator</span> <span class="o">=</span> <span class="n">exclude_end?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">value</span><span class="o">.</span><span class="n">exclude_end?</span> <span class="p">?</span> <span class="p">:</span><span class="o">&lt;</span> <span class="p">:</span> <span class="p">:</span><span class="o">&lt;=</span>
</span><span class='line'>      <span class="k">super</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="n">last</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="k">super</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Range</span>
</span><span class='line'>  <span class="n">prepend</span> <span class="no">IncludeRangeExt</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Range</span><span class="o">.</span><span class="n">ancestors</span> <span class="c1"># =&gt; [IncludeRangeExt, Range, Enumerable, Object...]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Refinamentos [experimental]</h3>

<p>No Ruby 1.9, se você usa um metodo <code>alias_method_chain</code>, a nova definição ocorre em todos os lugares. Em <a href="http://www.ruby-lang.org/en/news/2013/02/24/ruby-2-0-0-p0-is-released/">Ruby 2.0.0</a>, você pode fazer esse tipo de mudança apenas para si mesmo utilizando o <a href="http://ruby-doc.org/core-2.0/Module.html#method-i-refine">Module#refine</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">unless</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;x is not 0&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="k">unless</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;y is not 0&quot;</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">unless</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;z is not 0&quot;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;all are 0&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos!</p>

<p>Para todos aqueles que não sabiam ao certo o que seria o <code>unless</code>, e que tipo de monstro é isso..</p>

<p>Esta ai..</p>

<p>Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Demonstrações e Estruturas de controle - Part I #Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/18/demonstracoes-e-estruturas-de-controle/"/>
    <updated>2012-06-18T08:43:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/18/demonstracoes-e-estruturas-de-controle</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Demonstrações e estruturas de controle</p>




<h1>Demonstrações e estruturas de controle</h1>


<p>Considere o programa Ruby seguinte. Acrescenta dois números passados ​​para na linha de comando e imprime a soma:</p>

<figure class='code'><figcaption><span>Programa Simples</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_f</span> <span class="c1"># Converter primeiro argumento para um número</span>
</span><span class='line'><span class="n">y</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="n">to_f</span> <span class="c1"># Converter segundo argumento para um número</span>
</span><span class='line'><span class="n">soma</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="c1"># Adicione os argumentos</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">soma</span> <span class="c1"># Imprimir a soma</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este é um programa simples que consiste essencialmente em invocar variável de atribuição e método. O que o torna
particularmente simples é sua execução puramente seqüencial. As quatro linhas de código são executadas uma após a outra
sem ramificação ou repetição. É um programa raro que pode ser tão simples.</p>

<h3>Condicionais</h3>


<p>A estrutura de controle mais comum, em qualquer linguagem de programação, é a condicional. Esta é uma forma de dizer ao
computador para condicionalmente executar alguns códigos: para executar ele, só se alguma condição for satisfeita.
A condição é uma expressão, se for avaliada como qualquer valor diferente de falso ou nulo, então a condição é satisfeita.</p>

<p>Ruby tem um vocabulário rico para expressar condicionais. Algumas sintaxes são descritas abaixo. Ao escrever código Ruby,
você pode escolher o que parece mais elegante para a tarefa.</p>

<!--more-->




<h5>if</h5>


<p>Ele é a mais simples das condicionais. Em sua forma mais simples, parece que isso:</p>

<figure class='code'><figcaption><span>Condicional IF</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">expression</span>
</span><span class='line'>  <span class="n">code</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>O código entre <code>if</code> e <code>end</code>é executado se (e somente se) o <code>expression</code> é avaliada como algo diferente que <code>falso</code> ou
<code>nulo</code>. O código deve ser separado a partir da expressão com uma nova linha ou ponto e vírgula ou a palavra-chave, em
seguida. Aqui estão duas maneiras de escrever a mesma condicional <code>if</code> de forma simples:</p>

<figure class='code'><figcaption><span>Condicional IF</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Se x é menor que 10, incrementá-lo</span>
</span><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="c1"># nova linha de separação</span>
</span><span class='line'><span class="err">  </span><span class="n">x</span> <span class="o">+</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">then</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">end</span> <span class="c1"># the separato</span>
</span></code></pre></td></tr></table></div></figure>


<p>Você também pode usar <code>then</code> como o símbolo de separação, e segui-lo com uma nova linha. Isso torna o seu código robusto.</p>

<figure class='code'><figcaption><span>Condicional IF</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">then</span>
</span><span class='line'><span class="err">  </span><span class="n">x</span> <span class="o">+</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Os programadores que estão acostumados a C, ou linguagens cuja sintaxe é derivada de C, deve observar duas coisas
importantes sobre if no Ruby:</p>

<ul>
<li><p>Parênteses não é necessário (e normalmente não utilizado) em torno da expressão condicional. O ponto e vírgula, quebra
de linha, ou então palavra-chave serve para delimitar a expressão.</p></li>
<li><p>A palavra-chave <code>end</code> é exigida, mesmo quando o código a ser executado condicionalmente consiste de uma única instrução.
A forma modificador do <code>if</code>, descrito abaixo, fornece uma maneira para gravar condicionais simples sem a palavra-chave <code>end</code>.</p></li>
</ul>


<h5>else</h5>


<p>Uma declaração <code>if</code> pode incluir uma cláusula <code>else</code> para especificar o código para ser executado se a condição não é
<code>true</code>:</p>

<figure class='code'><figcaption><span>Condicional else</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 2.0</span>
</span><span class='line'><span class="k">module</span> <span class="nn">IncludeRangeExt</span>
</span><span class='line'>  <span class="n">refine</span> <span class="no">Range</span> <span class="k">do</span>
</span><span class='line'>    <span class="c1"># Estende o padrão Range#include? para suportar comparações de range</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">include?</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="o">::</span><span class="no">Range</span><span class="p">)</span>
</span><span class='line'>        <span class="c1"># 1...10 inclue 1..9 mas não inclue 1..10.</span>
</span><span class='line'>        <span class="n">operator</span> <span class="o">=</span> <span class="n">exclude_end?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">value</span><span class="o">.</span><span class="n">exclude_end?</span> <span class="p">?</span> <span class="p">:</span><span class="o">&lt;</span> <span class="p">:</span> <span class="p">:</span><span class="o">&lt;=</span>
</span><span class='line'>        <span class="k">super</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="n">last</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>        <span class="k">super</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">test_before</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span><span class='line'>  <span class="n">r</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; false (comportamento padrão)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Agora liga o refinamento:</span>
</span><span class='line'><span class="n">using</span> <span class="no">IncludeRangeExt</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; true  (comportamento refinado)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">test_after</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span><span class='line'>  <span class="n">r</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">test_after</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># =&gt; true (definido depois de usar, o comportamento tão refinado)</span>
</span><span class='line'>
</span><span class='line'><span class="mi">3</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">all?</span> <span class="k">do</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># =&gt; true  (comportamento refinado)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Mas a versão refinada acontece apenas para chamadas definidas após o uso:</span>
</span><span class='line'><span class="n">test_before</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># =&gt; false (definido anteriormente, não afetado)</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;some_other_file&#39;</span> <span class="c1"># =&gt; não afetado, usará o comportamento predefinido</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Note:</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">send</span> <span class="ss">:include?</span><span class="p">,</span> <span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="mi">3</span> <span class="c1"># =&gt; false (por agora, envio ignora refinamentos)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Spec completo está <a href="http://bugs.ruby-lang.org/projects/ruby-trunk/wiki/RefinementsSpec">aqui</a> e está sujeita a mudanças em versões posteriores. Discussão mais aprofundada <a href="http://benhoskin.gs/2013/02/24/ruby-2-0-by-example#refinements">aqui</a>.</p>

<h3>Enumeradores Lazy</h3>

<p>Um <a href="http://ruby-doc.org/core-2.0/Enumerable.html">Enumerable</a> pode ser transformado em um lazy com o novo método <a href="http://ruby-doc.org/core-2.0/Enumerable.html#method-i-lazy">Enumerable#lazy</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="n">lines</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">foreach</span><span class="p">(</span><span class="s1">&#39;a_very_large_file&#39;</span><span class="p">)</span>
</span><span class='line'>            <span class="o">.</span><span class="n">lazy</span> <span class="c1"># por isso só ler as partes necessárias!</span>
</span><span class='line'>            <span class="o">.</span><span class="n">select</span> <span class="p">{</span><span class="o">|</span><span class="n">line</span><span class="o">|</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">}</span>
</span><span class='line'>            <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:chomp</span><span class="p">)</span>
</span><span class='line'>            <span class="o">.</span><span class="n">each_slice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'>            <span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">lines</span><span class="o">|</span> <span class="n">lines</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
</span><span class='line'>            <span class="o">.</span><span class="n">take_while</span> <span class="p">{</span><span class="o">|</span><span class="n">line</span><span class="o">|</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="p">}</span>
</span><span class='line'>  <span class="c1"># =&gt; Enumerador lazy, ainda não executa nada</span>
</span><span class='line'><span class="n">lines</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; Lê o arquivo até que ele retornar 3 elementos</span>
</span><span class='line'>               <span class="c1"># ou até que um elemento de length &lt;= 20 é</span>
</span><span class='line'>               <span class="c1"># retornado (por causa da take_while)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Para consumir o enumerável:</span>
</span><span class='line'><span class="n">lines</span><span class="o">.</span><span class="n">to_a</span> <span class="c1"># ou...</span>
</span><span class='line'><span class="n">lines</span><span class="o">.</span><span class="n">force</span> <span class="c1"># =&gt; Lê o arquivo e retorna uma array</span>
</span><span class='line'><span class="n">lines</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">elem</span> <span class="p">}</span> <span class="c1"># =&gt; Lê o arquivo e imprime os elementos resultantes</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que, muitas vezes, <code>lazy</code> é mais lento do que uma versão não <code>lazy</code>. Ele deve ser usado somente quando ele realmente faz sentido, não apenas para evitar a construção de um <code>array</code> intermediário.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;fruity&#39;</span>
</span><span class='line'><span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span>
</span><span class='line'><span class="n">compare</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">lazy</span>   <span class="p">{</span> <span class="n">r</span><span class="o">.</span><span class="n">lazy</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">)</span><span class="o">.</span><span class="n">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">direct</span> <span class="p">{</span> <span class="n">r</span>     <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">)</span><span class="o">.</span><span class="n">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>      <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1"># =&gt; direto é mais rápida do que por lazy 2x ± 0.1</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Tamanho Lazy</h3>

<p><a href="http://ruby-doc.org/core-2.0/Enumerator.html#method-i-size">Enumerator#size</a> pode ser chamado para obter o tamanho do enumerador sem consumi-lo (se disponível).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="c1"># =&gt; 94109400</span>
</span><span class='line'><span class="kp">loop</span><span class="o">.</span><span class="n">size</span> <span class="c1"># =&gt; Float::INFINITY</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">drop_while</span><span class="o">.</span><span class="n">size</span> <span class="c1"># =&gt; nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ao criar enumeradores, seja com <code>to_enum</code>, <code>Enumerator::New</code> ou <code>Enumerator::Lazy::New</code> é possível definir um tamanho muito:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="n">fib</span> <span class="o">=</span> <span class="no">Enumerator</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">Float</span><span class="o">::</span><span class="no">INFINITY</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">y</span><span class="o">|</span>
</span><span class='line'>  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="kp">loop</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="o">+</span><span class="n">a</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">still_lazy</span> <span class="o">=</span> <span class="n">fib</span><span class="o">.</span><span class="n">lazy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">1_000_000</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</span><span class='line'><span class="n">still_lazy</span><span class="o">.</span><span class="n">size</span> <span class="c1"># =&gt; 1_000_000 - 42</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">skip</span><span class="p">(</span><span class="n">every</span><span class="p">)</span>
</span><span class='line'>    <span class="k">unless</span> <span class="nb">block_given?</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">to_enum</span><span class="p">(</span><span class="ss">:skip</span><span class="p">,</span> <span class="n">every</span><span class="p">)</span> <span class="p">{</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">size</span><span class="o">+</span><span class="n">every</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">every</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">each_slice</span><span class="p">(</span><span class="n">every</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">ignore</span><span class="o">|</span>
</span><span class='line'>      <span class="k">yield</span> <span class="n">last</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span> <span class="c1"># =&gt; [1, 5, 9]</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="c1"># =&gt; 3, sem executar o loop</span>
</span></code></pre></td></tr></table></div></figure>


<p>Detalhes adicionais e exemplos na doc de <a href="http://ruby-doc.org/core-2.0/Object.html#method-i-to_enum">to_enum</a>.</p>

<h3><strong>dir</strong></h3>

<p>Embora <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-require_relative">require_relative</a> torna o uso de <code>File.dirname(__FILE__)</code> muito menos freqüentes, agora podemos usar <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-__dir__"><strong>dir</strong></a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">expression</span>
</span><span class='line'>  <span class="n">code</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">code</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>O código entre <code>if</code> e <code>else</code> é executado se <code>expression</code> é avaliada como qualquer outra coisa que <code>false</code> ou <code>nil</code>. Caso
contrário (se expression é <code>false</code> ou <code>nil</code>), o código entre o <code>else</code> e o <code>end</code> é executado. Como na forma simples
de <code>if</code>, na expressão deve ser separado do código que o segue por uma nova linha, um ponto e vírgula, ou a palavra-chave <code>then</code>. As palavras-chave <code>else</code> e <code>end</code>, totalmente delimitam o segundo pedaço de código, e sem novas linhas ou
delimitadores adicionais são exigido.</p>

<p>Aqui é um exemplo de um condicional que inclui uma cláusula <code>else</code>:</p>

<figure class='code'><figcaption><span>Condicional if - else</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.8:</span>
</span><span class='line'><span class="nb">require</span> <span class="no">File</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">__FILE__</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/lib&quot;</span>
</span><span class='line'><span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">File</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">__FILE__</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/.Gemfile&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 1.9:</span>
</span><span class='line'><span class="n">require_relative</span> <span class="s1">&#39;lib&#39;</span>
</span><span class='line'><span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">File</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">__FILE__</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/.config&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0</span>
</span><span class='line'><span class="n">require_relative</span> <span class="s1">&#39;lib&#39;</span> <span class="c1"># há necessidade de usar __dir__ por isso!</span>
</span><span class='line'><span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">__dir__</span> <span class="o">+</span> <span class="s1">&#39;/.config&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>bsearch</h3>

<p>Pesquisa binária já está disponível, usando <a href="http://ruby-doc.org/core-2.0/Array.html#method-i-bsearch">Array#bsearch</a> ou <a href="http://ruby-doc.org/core-2.0/Range.html#method-i-bsearch">Range#bsearch</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">dados</span> <span class="c1"># Se o array existe</span>
</span><span class='line'><span class="err">  </span><span class="n">dados</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="c1"># em seguida, acrescentar um valor a ela.</span>
</span><span class='line'><span class="k">else</span> <span class="c1"># Caso contrário ...</span>
</span><span class='line'><span class="err">  </span><span class="n">data</span> <span class="o">=</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="c1"># criar uma nova matriz que contém o valor.</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># Este é o fim do condicional</span>
</span></code></pre></td></tr></table></div></figure>




<h5>elsif</h5>


<p>Se você quiser testar mais de uma condição dentro de uma condicional, você pode adicionar um ou mais cláusulas <code>elsif</code>
entre um <code>if</code> e um <code>else</code>. <code>elsif</code> é uma forma abreviada de <code>else if</code>. Note que há apenas um <code>else</code> em <code>elsif</code>. A condicional <code>elsif</code> usando parecido com este:</p>

<figure class='code'><figcaption><span>Expressão elsif</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="n">ary</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="o">]</span>
</span><span class='line'><span class="n">ary</span><span class="o">.</span><span class="n">bsearch</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">&gt;=</span>   <span class="mi">6</span> <span class="p">}</span> <span class="c1">#=&gt; 7</span>
</span><span class='line'><span class="n">ary</span><span class="o">.</span><span class="n">bsearch</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="p">}</span> <span class="c1">#=&gt; nil</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Também em range, incluindo range de floats:</span>
</span><span class='line'><span class="p">(</span><span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">.</span><span class="n">.</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">*</span> <span class="mi">6</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">bsearch</span><span class="p">{</span><span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="no">Math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">}</span>
</span><span class='line'><span class="c1"># =&gt; Math::PI * (6+1/3.0)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>to_h</h3>

<p>Existe agora uma forma oficial para converter uma classe a um Hash, utilizando <code>to_h</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<<<<<<< HEAD
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">expression1</span>
</span><span class='line'><span class="err">  </span><span class="n">code1</span>
</span><span class='line'><span class="k">elsif</span> <span class="n">expression2</span>
</span><span class='line'><span class="err">  </span><span class="n">code2</span>
</span><span class='line'><span class="err">      </span><span class="o">.</span>
</span><span class='line'><span class="err">      </span><span class="o">.</span>
</span><span class='line'><span class="err">      </span><span class="o">.</span>
</span><span class='line'><span class="k">elsif</span> <span class="n">expressionN</span>
</span><span class='line'><span class="err">  </span><span class="n">codeN</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">code</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se <code>expression1</code> for avaliado não sendo <code>false</code> ou <code>nil</code>, então <code>code1</code> é executado. Caso contrário, <code>expression2</code> é
avaliada. Se for outra coisa senão <code>false</code> ou <code>nil</code>, então code2 é executado. Este processo continua até que uma expressão
é avaliada como algo diferente de <code>false</code> ou <code>nil</code>, ou até que todas as cláusulas <code>elsif</code> foram testadas. Se a expressão
associada com a última cláusula <code>elsif</code> for <code>false</code> ou <code>nil</code>, e da cláusula <code>elsif</code> é seguido por uma cláusula <code>else</code>, em
seguida, o código entre <code>else</code> e no <code>end</code> é executado. Se nenhuma cláusula mais está presente, em seguida, nenhum código é
executado.</p>

<p><code>elsif</code> é como se: a expressão deve ser separada do código por uma nova linha, uma vírgula ou uma palavra-chave, em seguida
. Aqui é um exemplo de uma multi condicional usando <code>elsif</code>:</p>

<figure class='code'><figcaption><span>Condicional elsif</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="no">Car</span> <span class="o">=</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:make</span><span class="p">,</span> <span class="ss">:model</span><span class="p">,</span> <span class="ss">:year</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">build</span>
</span><span class='line'>    <span class="c1">#...</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">car</span> <span class="o">=</span> <span class="no">Car</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;Toyota&#39;</span><span class="p">,</span> <span class="s1">&#39;Prius&#39;</span><span class="p">,</span> <span class="mi">2014</span><span class="p">)</span>
</span><span class='line'><span class="n">car</span><span class="o">.</span><span class="n">to_h</span> <span class="c1"># =&gt; {:make=&gt;&quot;Toyota&quot;, :model=&gt;&quot;Prius&quot;, :year=&gt;2014}</span>
</span><span class='line'><span class="kp">nil</span><span class="o">.</span><span class="n">to_h</span> <span class="c1"># =&gt; {}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isso foi implementado para <code>nil</code>, <code>Struct</code> e <code>OpenStruct</code>, mas não para <code>Array</code>/<code>Enumerable</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span><span class="n">hello</span><span class="p">:</span> <span class="s1">&#39;world&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="o">[</span><span class="n">k</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">upcase</span><span class="o">]</span><span class="p">}</span>
</span><span class='line'>                <span class="o">.</span><span class="n">to_h</span> <span class="c1"># =&gt; NoMethodError:</span>
</span><span class='line'><span class="c1"># undefined method `to_h&#39; for [[&quot;hello&quot;, &quot;WORLD&quot;]]:Array</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se você acha que isso seria um recurso útil, você deve <a href="http://bugs.ruby-lang.org/issues/7292">tentar convencer Matz</a>.</p>

<h3>caller_locations</h3>

<p>É usado para ser difícil saber qual o método chamado apenas. Que não foi muito eficiente, dado que o backtrace todo teve de ser retornado. Cada frames foi uma seqüência que precisava ser computado primeiramento pelo Ruby e provavelmente analisado depois.</p>

<p>Entra <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-caller_locations">caller_locations</a> que retorna a informação de uma forma de objeto e com uma api melhor que pode limitar o número de frames solicitados.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
</span><span class='line'><span class="err">  </span><span class="nb">name</span> <span class="o">=</span> <span class="s2">&quot;um&quot;</span>
</span><span class='line'><span class="k">elsif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span>
</span><span class='line'><span class="err">  </span><span class="nb">name</span> <span class="o">=</span> <span class="s2">&quot;dois&quot;</span>
</span><span class='line'><span class="k">elsif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">then</span> <span class="nb">name</span> <span class="o">=</span> <span class="s2">&quot;três&quot;</span>
</span><span class='line'><span class="k">elsif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span> <span class="nb">name</span> <span class="o">=</span> <span class="s2">&quot;quatro&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="err">  </span><span class="nb">name</span> <span class="o">=</span> <span class="s2">&quot;muitos&quot;</span>
=======
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9:</span>
</span><span class='line'><span class="k">def</span> <span class="nf">whoze_there_using_caller</span>
</span><span class='line'>  <span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="sr">/`([^&#39;]*)&#39;/</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="k">def</span> <span class="nf">whoze_there_using_locations</span>
</span><span class='line'>  <span class="n">caller_locations</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">label</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<<<<<<< HEAD


<h5>Valor de retorno</h5>


<p>Na maioria das linguagens, a condicional <code>if</code> é uma afirmação. Em Ruby, no entanto, tudo é uma expressão, mesmo as
estruturas de controle que são comumente chamadas de declarações. O valor <code>return</code> de uma &#8220;declaração&#8221; <code>if</code>, é o valor da
última expressão no código que foi executado, ou <code>nil</code> se nenhum bloco de código foi executado.</p>

<p>O fato de que, as declarações <code>if</code> devolvem um valor significa que, por exemplo, a muilti condicional mostrado
anteriormente pode ser elegantemente reescrito como este abaixo:</p>

<figure class='code'><figcaption><span>Valor de Retorno</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<p>Quanto mais rápido é? <a href="https://gist.github.com/marcandre/5041813">Um teste simples</a> me dá um aumento de velocidade de 45x de um stacktrace curto, e 100x para um stacktrace de 100 entradas!</p>

<p>A informação extra, como o caminho do arquivo, número da linha, ainda são acessíveis, em vez de pedir para o <code>label</code>, para pedir <code>path</code> ou <code>lineno</code>.</p>

<h3>Otimizações</h3>

<p>É difícil mostrar a maioria das otimizações de código, mas algumas otimizações agradáveis que foi feito no <a href="http://www.ruby-lang.org/en/news/2013/02/24/ruby-2-0-0-p0-is-released/">Ruby 2.0.0</a>. Em particular, o GC foi otimizado, em particular para fazer bifurcar muito mais rápido.</p>

<p>Uma otimização que podemos demonstrar é fazer de imediatos muitos floats em sistemas de 64 bits. Isso evita a criação de novos objetos em muitos casos:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="s2">&quot;um&quot;</span>
</span><span class='line'><span class="err">       </span><span class="k">elsif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">then</span> <span class="s2">&quot;dois&quot;</span>
</span><span class='line'><span class="err">       </span><span class="k">elsif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">then</span> <span class="s2">&quot;três&quot;</span>
</span><span class='line'><span class="err">       </span><span class="k">elsif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span> <span class="k">then</span> <span class="s2">&quot;quatro&quot;</span>
</span><span class='line'><span class="err">       </span><span class="k">else</span> <span class="s2">&quot;muitos&quot;</span>
</span><span class='line'><span class="err">       </span><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso aí amigos..</p>

<p>Bons estudos e até a proxima! :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atribuição Paralela #Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/11/atribuicao-paralela-number-ruby/"/>
    <updated>2012-06-11T19:36:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/11/atribuicao-paralela-number-ruby</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Atribuições Paralelas</p>




<h1>Atribuições Paralelas</h1>


<p>Atribuição paralela é qualquer atribuição de expressão que tem mais do que um <code>lvalue</code>, mais do que um <code>rvalue</code>, ou ambos. Múltiplos <code>lvalues</code> e ​​múltiplos <code>rvalues</code> são separados uns dos outros com uma vírgula. <code>lvalues</code> e <code>rvalues</code> ​​pode ser prefixado com <code>*</code>, que às vezes é chamado de operador <code>splat</code>, embora não seja um verdadeiro operador. O significado de <code>*</code> é explicado mais adiante neste post.</p>

<p>Expressões de atribuição mais paralelas são simples, e é óbvio que eles significam. Existem alguns casos complicados, no entanto, e os subtitulos seguintes explicam todas as possibilidades.</p>

<!--more-->




<h5>Mesmo número de lvalues ​​e rvalues</h5>


<p>Atribuição paralela é a sua forma mais simples quando não são os mesmos número de <code>lvalues</code> ​​e <code>rvalues</code>:</p>

<figure class='code'><figcaption><span>Atribuição de Mesmo número</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="c1"># x = 1; y = 2; z = 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>Neste caso, o primeiro <code>rvalue</code> é atribuído ao primeiro <code>lvalue</code>; o segundo <code>rvalue</code> é atribuído ao segundo <code>lvalue</code>, e assim por diante.</p>

<p>Estas atribuições são efetivamente executadas em paralelo, não seqüencialmente. Por exemplo, as seguintes duas linhas não são as mesmas:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="c1"># Paralela: trocar o valor de duas variáveis</span>
</span><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># seqüencial: ambas as variáveis ​​têm o mesmo valor</span>
</span></code></pre></td></tr></table></div></figure>




<h5>Um lvalue, ​​múltiplos rvalues</h5>


<p>Quando há um único <code>lvalue</code> e mais do que um <code>rvalue</code>, Ruby cria um <code>array</code> para armazenar os <code>rvalues</code> ​​e atribui esse <code>array</code> para o <code>lvalue</code>:</p>

<figure class='code'><figcaption><span>Um lvalue e Múltiplos rvalues</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="c1"># x = [1,2,3]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Você pode colocar um <code>*</code> antes do lvalue sem alterar o significado ou o valor de retorno desta atribuição.</p>

<p>Se você quiser impedir que os ​múltiplos <code>rvalues</code> de serem combinados em um único <code>array</code>, siga o <code>lvalue</code> com uma vírgula. Mesmo sem um lvalue depois da vírgula, isto torna que o Ruby se comporte como se há ​​múltiplos lvalues:</p>

<figure class='code'><figcaption><span>Atribuições</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="c1"># x = 1; outros valores são descartados</span>
</span></code></pre></td></tr></table></div></figure>




<h5>M​últiplos lvalues, array único de rvalue</h5>


<p>Quando existem múltiplos <code>lvalues​</code> e apenas um único <code>rvalue</code>, Ruby tenta expandir o rvalue em uma <code>lista</code> de valores a atribuir. Se o <code>rvalue</code> é um <code>array</code>, Ruby expande o <code>array</code> para que cada elemento torna-se seu próprio <code>rvalue</code>. Se o <code>rvalue</code> não é um <code>array</code>, mas implementa um método <code>to_ary</code>, Ruby invoca esse método e, em seguida, se expande o <code>array</code> no retorno:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span> <span class="c1"># mesmo que x, y, z = 1,2,3</span>
</span></code></pre></td></tr></table></div></figure>


<p>A atribuição paralela foi transformado de modo que há ​​múltiplos <code>lvalues</code> e zero (se expandida o <code>array</code> estando <code>empty</code>) ou mais <code>rvalues</code>. Se o número de <code>lvalues</code> ​​e <code>rvalues</code> ​​são os mesmos, então a atribuição ocorre conforme descrito anteriormente, Mesmo número de lvalues ​​e rvalues<code>. Se os números são diferentes, então a atribuição ocorre como descrito a seguir em</code>Diferentes números de lvalues ​​e rvalues`.</p>

<p>Podemos usar o truque de fuga por vírgula descrito acima para transformar uma sessão ordinária não paralela em uma atribuição que automaticamente descompacta um <code>array</code> à direita:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">]</span> <span class="c1"># x torna-se [1,2]: isso não é atribuição paralela</span>
</span><span class='line'><span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">]</span> <span class="c1"># x torna-se 1: da vírgula torna paralelo</span>
</span></code></pre></td></tr></table></div></figure>




<h5>Diferentes números de lvalues ​​e rvalues</h5>


<p>Se houver <code>lvalues</code> mais do que ​​<code>rvalues</code>, e nenhum operador <code>splat</code> é envolvido, em seguida, o primeiro <code>rvalue</code> é atribuído ao primeiro <code>lvalue</code>, o segundo <code>rvalue</code> é atribuído ao segundo <code>lvalue</code>, e assim por diante, até todos os <code>rvalues</code> ​​forem atribuídos. Em seguida, cada um dos restantes <code>lvalues</code> ​​é atribuído nil, substituindo qualquer valor existente para que <code>lvalue</code>:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="c1"># x = 1; y = 2; z = nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se houver <code>rvalues</code> mais do que ​<code>​lvalues</code>, e nenhum operador <code>splat</code> é envolvido, em seguida, os <code>rvalues</code> ​são atribuídos em ordem a cada um dos <code>lvalues</code>, e os restantes <code>rvalues</code> são descartados :</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="c1"># x = 1; y = 2, 3 não é atribuído</span>
</span></code></pre></td></tr></table></div></figure>




<h5>O operador splat</h5>


<p>Quando um <code>rvalue</code> é precedido por um asterisco(<code>*</code>), isso significa que o referido valor é um <code>array</code> e que seus elementos devem ser cada um <code>rvalues</code>. Os elementos do <code>array</code> substituem o <code>array</code> na lista original do <code>rvalue</code>, e a atribuição procede como descrito abaixo:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span> <span class="o">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span> <span class="c1"># mesmo que x, y, z = 1,2,3</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.8, um splat só pode aparecer antes do último <code>rvalue</code> em uma atribuição. No Ruby 1.9, a lista de <code>rvalues</code> ​​em uma atribuição paralela pode ter qualquer número de <code>splats</code>, e eles podem aparecer em qualquer posição na lista. Não é legal, porém, em qualquer versão da linguagem, para tentar um &#8220;splat double&#8221; em uma lista aninhada:</p>

<figure class='code'><figcaption><span>Erro de Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="o">**[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">]]</span>   <span class="c1"># SyntaxError!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Os <code>rvalues</code> com i​ntervalo de <code>arrays</code> e de <code>hash</code> pode ser <code>splatted</code>. Em geral, qualquer <code>rvalue</code> que define um método <code>to_a</code> pode ser prefixado com um <code>splat</code>. Qualquer objeto <a href="http://ruby-doc.org/core-1.9.3/Enumerable.html"><code>Enumerable</code></a>, incluindo enumeradores pode ser <code>splatted</code>, por exemplo. Quando um <code>splat</code> é aplicado a um objecto que não define um método <code>to_a</code>, nenhuma expansão é realizada e o <code>splat</code> avaliado como o próprio objeto.</p>

<p>Quando um <code>lvalue</code> é precedido por um asterisco(<code>*</code>), isso significa que todos ​​os adicionais <code>rvalues</code> devem ser colocados em um <code>array</code> e atribuído ao <code>lvalue</code>. O valor atribuído a esse <code>lvalue</code> é sempre um <code>array</code>, e ele pode ter zero, um ou mais elementos:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span><span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1"># x=1; y=[2,3]</span>
</span><span class='line'><span class="n">x</span><span class="p">,</span><span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>     <span class="c1"># x=1; y=[2]</span>
</span><span class='line'><span class="n">x</span><span class="p">,</span><span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>        <span class="c1"># x=1; y=[]</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.8, um <code>splat</code> só pode preceder o <code>lvalue</code> passado na lista. No Ruby 1.9, do lado esquerdo de uma atribuição paralela pode incluem um operador <code>splat</code>, mas pode aparecer em qualquer posição na lista:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9 somente</span>
</span><span class='line'><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1"># x=[1,2]; y=3</span>
</span><span class='line'><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>     <span class="c1"># x=[1]; y=2</span>
</span><span class='line'><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>        <span class="c1"># x=[]; y=1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que <code>splats</code> pode aparecer em ambos os lados de uma expressão paralela de atribuição:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">]</span>  <span class="c1"># x=1; y=2; z=[3,4].</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finalmente, lembre-se que anteriormente descrevemos dois casos simples de atribuição paralela em que há um <code>lvalue</code> único ou uma única <code>rvalue</code>. Note-se que ambos os casos se comportam como se existe um <code>splat</code> antes da única <code>lvalue</code> ou <code>rvalue</code>. Explicitamente, incluindo um <code>splat</code> em nestes casos não tem qualquer efeito adicional.</p>

<h5>Parênteses na atribuição paralelo</h5>


<p>Uma das características menos compreendidas da atribuição paralela é que o lado esquerdo pode usar parênteses para &#8220;sub atrobuição&#8221;. Se um grupo de dois ou mais <code>lvalues</code> ​​é colocado entre parênteses, então é inicialmente tratada como um <code>lvalue</code> único. Uma vez que o <code>rvalue</code> correspondente foi determinado, as regras de atribuição paralela são aplicadas recursivamente, o <code>rvalue</code> que é atribuído ao grupo de <code>lvalues</code> ​​que foi em parênteses. Considere o seguinte exercício:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este é efetivamente executam dois trabalhos ao mesmo tempo:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>Mas note que a segunda tarefa é em si uma atribuição paralela. Como usamos parênteses no lado esquerdo, uma atribuição paralela recursiva é executada. Em ordem para que ele funcione, b deve ser um objeto <code>splattable</code> como um <code>array</code> ou <code>enumerador</code>.</p>

<p>Aqui estão alguns exemplos concretos que devem tornar isso mais claro. Note que os parênteses no ato da esquerda a &#8220;desembrulhar&#8221; um nível de <code>array</code> alinhado à direita:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9</span>
</span><span class='line'><span class="mi">4</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="n">object_id</span> <span class="o">==</span> <span class="mi">4</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="n">object_id</span> <span class="c1"># =&gt; false</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0</span>
</span><span class='line'><span class="nb">warn</span> <span class="s2">&quot;Optimization only on 64 bit systems&quot;</span> <span class="k">unless</span> <span class="mi">42</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">64</span>
</span><span class='line'><span class="mi">4</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="n">object_id</span> <span class="o">==</span> <span class="mi">4</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="n">object_id</span> <span class="c1"># =&gt; true (4.2 é imediato)</span>
</span><span class='line'><span class="mi">4</span><span class="o">.</span><span class="mi">2</span><span class="n">e100</span><span class="o">.</span><span class="n">object_id</span> <span class="o">==</span> <span class="mi">4</span><span class="o">.</span><span class="mi">2</span><span class="n">e100</span><span class="o">.</span><span class="n">object_id</span> <span class="c1"># =&gt; false (4.2e100 não é)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>O que mais?</h2>

<p>Uma extensa lista de mudanças é o <a href="https://github.com/marcandre/ruby/blob/news/NEWS.rdoc">arquivo NEWS</a>.</p>

<h2>Eu quero!</h2>

<p>Experimente hoje:</p>

<ul>
<li>Instalar com rvm: <code>rvm get head &amp;&amp; rvm install 2.0.0</code> (note que <code>rvm get stable</code> não é suficiente!)</li>
<li>Instalar com rbenv: <code>rbenv install 2.0.0-p0</code> (eu acho)</li>
<li>Outra instalação: Veja as instruções de <a href="http://www.ruby-lang.org/en/downloads/">ruby-lang.org</a></li>
</ul>


<p>Para aqueles que não podem atualizar ainda, você ainda pode ter um pouco da diversão com a minha gem <a href="https://github.com/marcandre/backports">backports</a>. Ele faz <code>bsearch</code>, <code>lazy</code> e mais um par disponível para qualquer versão do Ruby. A lista completa está no <a href="https://github.com/marcandre/backports#ruby-200">readme</a>.</p>

<p>Aproveite o <a href="http://www.ruby-lang.org/en/news/2013/02/24/ruby-2-0-0-p0-is-released/">Ruby 2.0.0</a>!</p>

<hr />

<p>Até a proxima amigos&hellip;</p>

<p>E muito obrigado <a href="https://twitter.com/malafortune">Marc</a>&hellip;</p>

<p>And thank you very much <a href="https://twitter.com/malafortune">Marc</a>&hellip;</p>

<p>:D</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[[TRADUÇÃO] - Trabalhando com time zones em Ruby on Rails]]></title>
    <link href="http://rrmartins.com/blog/2012/12/02/traducao-trabalhando-com-time-zones-em-ruby-on-rails/"/>
    
    <updated>2012-12-02T09:37:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/12/02/traducao-trabalhando-com-time-zones-em-ruby-on-rails</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Conversando com o <a href="https://twitter.com/cjkihlbom">CJ Kihlbom</a>, um cara super gente boa. :) E ele liberou ai a tradução do post <a href="http://www.elabs.se/blog/36-working-with-time-zones-in-ruby-on-rails">Working with time zones in Ruby on Rails</a>.</p>

<hr />

<p>Tradução</p>

<hr />

<p><a href="http://api.rubyonrails.org">Rails</a> oferece ótimas ferramentas para trabalhar com fusos horários, mas ainda há um monte de coisas que
podem dar errado. Este blog tem como objetivo lançar alguma luz sobre essas pegadinhas e oferecer soluções
para os problemas mais comuns.</p>

<p>O que, provavelmente, tem me enganado é que a maioria das vezes o fato de que os tolos do Rails acredita que
você tem tudo coberto o tempo todo <strong>(com o perdão do trocadilho)</strong>. Não me interpretem mal. Eu uso Rails
para fazer o trabalho, tanto para mim quanto possível. Mas eu aprendi da maneira mais difícil que eu não
posso fugir não sabendo quando e como o Rails está me ajudando. Outra pegadinha é o fato de que você tem mais
fusos horários em jogo do que você pode acreditar. Considere o seguinte: db, servidor, a máquina dev, sistema
configurado, o usuário específico configurado e o navegador.</p>

<h3>Configure sua app Rails</h3>

<p>Então, quais as ferramentas que temos à nossa disposição como desenvolvedores <a href="http://api.rubyonrails.org">Rails</a>? O mais importante é
a configuração <code>config.time_zone</code> em seu arquivo <code>config/application.rb</code>. ActiveRecord irá ajudá-lo a
converter de e para UTC (o que a documentação não explica) e o fuso horário de sua escolha. Isto significa
que, se tudo que você está fazendo é ter usuários postando varias vezes através de um formulário e utilizar
<code>Active Record</code> que ele persista que você é bom para ir.</p>

<h3>Processamento de informações de time</h3>

<p>Então, o que sobre o fato de fazer algo com a informação de <code>time</code> antes de aceitá-lo? Que é quando se torna
complicado.</p>

<h4>Parsing</h4>

<p>Ao analisar informações de <code>time</code> é importante nunca fazê-lo sem especificar o fuso horário. A melhor maneira
de o fazer é utilizar <code>Time.zone.parse</code> (que vai usar na zona de tempo especificado no <code>config.time_zone</code>) em
vez de apenas <code>Time.parse</code> (que vai usar a zona do computador).</p>

<h4>Trabalhar com atributos numéricos e ActiveRecord</h4>

<p>Chamadas de método como <code>2.hours.ago</code> usa o fuso horário que você configurou, portanto, use este se você
pode! A mesma coisa é verdade para atributos de tempo em modelos <code>ActiveRecord</code>.</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="o">.</span><span class="n">first</span>
</span><span class='line'><span class="n">post</span><span class="o">.</span><span class="n">published_at</span> <span class="c1">#=&gt; Thu, 22 Mar 2012 00:00:00 CDT -05:00</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ActiveRecord</code> busca a hora <code>UTC</code> do banco de dados e converte para o fuso horário em <code>config.time_zone</code> para
você.</p>

<h4>Date vs Time</h4>

<p><code>Time</code> tem informações de <code>Date</code>, mas <code>Date</code> não tem informação de <code>Time</code>. Mesmo que você não acha que se
importa, você pode perceber que você faz, mais cedo ou mais tarde. Seja seguro e use <code>Time</code> (ou <code>DateTime</code>,
se você precisa de suporte para <code>Times</code> muito longe do presente).</p>

<p>Mas vamos dizer que você está preso com uma <code>Date</code> que você precisa para tratar como um <code>Time</code>, pelo menos,
certifique-se de convertê-lo para o seu fuso horário configurado:</p>

<figure class='code'><figcaption><span>Date vs Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">from_now</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 22:04:47 JST +09:00</span>
</span><span class='line'><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">to_time_in_current_zone</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 00:00:00 JST +09:00</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Consultando</h4>

<p>Desde que Rails sabe que a sua informação de <code>Time</code> é armazenado como UTC no banco de dados que irá converter
a qualquer momento que você dá para o UTC.</p>

<figure class='code'><figcaption><span>Query</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Post</span><span class="o">.</span><span class="n">where</span> <span class="p">(</span><span class="o">[</span><span class="s2">&quot;posts.publised_at&gt;?&quot;</span><span class="p">,</span> <span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">now</span><span class="o">]</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Só não se esqueça de nunca construir a seqüência de consulta à mão e use sempre <code>Time.zone.now</code> como a base e
você deve ser seguro.</p>

<h3>Trabalhando com APIs</h3>

<h4>Fornecimento</h4>

<p>A construção de uma API web para o consumo de outros? Certifique-se sempre de enviar todos os dados de tempo
como <code>UTC</code> (e especificar que este é o caso).</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">iso8601</span> <span class="c1"># =&gt; &quot;2012-03-16T14: 55:33 Z&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Leia mais sobre por ISO8601 é aconselhável aqui: <a href="http://devblog.avdi.org/2009/10/25/iso8601-dates-in-ruby/">iso8601-dates-in-ruby</a></p>

<h4>Consumindo</h4>

<p>Quando você começa a informação do <code>Time</code> a partir de uma API externa que você não tem controle sobre o que
você simplesmente necessita de descobrir o formato e o fuso horário que é enviado a você. Porque
<code>Time.zone.parse</code> pode não funcionar com o formato que você recebe, pode precisar de usar:</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_string</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-%dT%H:%M:%S%z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">in_time_zone</span><span class="p">(</span><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Por que não há nenhum método <code>#strptime</code> em <code>Time.zone</code> quando há um <code>#parse</code>. No entanto, não se esqueça de
chamar <code>in_time_zone</code> (<code>Time.zone</code>) no seu resultado!</p>

<h3>Trabalhar com vários fusos horários do usuário</h3>

<p>Muitos sistemas necessita de suporte aos usuários para entrar e visualizar as informações de tempo em uma
variedade de zonas de tempo. Para conseguir isso, você precisa armazenar zona de cada usuário tempo
(provavelmente só um dos nomes de zona de tempo <code>String</code> encontrado no <code>rake time:zones:all</code>). Então, para
realmente usar esse fuso horário o padrão mais comum é simplesmente criar um método particular em sua
<code>ActionController</code> e executá-la antes como um filtro.</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">before_filter</span> <span class="ss">:set_time_zone</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">set_time_zone</span>
</span><span class='line'>  <span class="no">Time</span><span class="o">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">current_user</span><span class="o">.</span><span class="n">time_zone</span> <span class="k">if</span> <span class="n">current_user</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isso vai fazer a mesma coisa que <code>config.time_zone</code> mas em uma base por pedido. Eu ainda recomendo mudar o
<code>config.time_zone</code> padrão para um fuso horário que é um bom padrão para seus usuários.</p>

<h4>Testando</h4>

<p>Todos acima é algo que os testes devem pegar para você. O problema é que você como o usuário e seu
computador como o servidor de desenvolvimento, acontece a residir no mesmo fuso horário. Esse raramente é o
 caso, uma vez que você levar as coisas para a produção.</p>

<p>Highgroove liberado apenas <a href="https://github.com/highgroove/zonebie">Zonebie</a>, uma gem que o ajuda a lidar com isso. Eu não tive tempo de testá-lo
eu mesmo ainda, mas parece muito promissor. Se você achar que isso seja um exagero, pelo menos,
certifique-se de que seus testes executados com um conjunto <code>Time.zone</code> para outro fuso horário do que a sua
máquina de desenvolvimento está configurado!</p>

<h4>Bug no Time.zone.parse</h4>

<p>Jarkko Laine (<a href="https://twitter.com/#!/jarkko">@Jarkko</a>) apontou que não há atualmente um bug no <code>Rails</code> que pode fazer o
<code>Time.zone.parse</code> perder uma hora quando o tempo do sistema está em <code>DST</code> (<code>horário de verão</code>) e seu fuso
horário configurado não. Jarkko postou um problema no <code>Rails</code> rastreando o assunto e escreveu um patch para
corrigir o bug. Até que o patch foi aceito ou se você está rodando com versões mais antigas do <code>Rails</code> a
única forma segura de evitar este erro, quer seja um patches para <code>Rails</code> em seu aplicativo com correção
Jarkko’s ou uso:</p>

<figure class='code'><figcaption><span>Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># use</span>
</span><span class='line'><span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TimeWithZone</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="kp">nil</span><span class="p">,</span> <span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="p">,</span> <span class="no">DateTime</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-25 03:29&quot;</span><span class="p">))</span>
</span><span class='line'><span class="c1"># =&gt; Sun, 25 Mar 2012 03:29:00 PDT -07:00</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># or if possible pass the time zone in the string</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-25 03:29 PDT&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; Sun, 25 Mar 2012 03:29:00 PDT -07:00</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># instead of</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-25 03:29&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># =&gt; Sun, 25 Mar 2012 04:29:00 PDT -07:00</span>
</span></code></pre></td></tr></table></div></figure>


<p>Deve, contudo, ser mencionado que é muito raro que esta superfícies de bug e quando ele faz isso só pode
perder uma hora. Se você pode viver com o que você provavelmente faz melhor por apenas aguardando o patch
para ser aceito.</p>

<h3>Cheat Sheet</h3>

<h4>FAZER</h4>

<figure class='code'><figcaption><span>Date vs Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">2</span><span class="o">.</span><span class="n">hours</span><span class="o">.</span><span class="n">ago</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 14:02:42 CET +01:00</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">from_now</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 22:04:47 JST +09:00</span>
</span><span class='line'><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">to_time_in_current_zone</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 00:00:00 JST +09:00</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-02 16:05:37&quot;</span><span class="p">)</span> <span class="c1"># =&gt; Fri, 02 Mar 2012 16:05:37 JST +09:00</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">now</span> <span class="c1"># =&gt; Sat, 03 Mar 2012 00:07:37 JST +09:00</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">today</span> <span class="c1"># If you really can&#39;t have a Time or DateTime for some reason</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">iso8601</span> <span class="c1"># &quot;When supliyng an API (you can actually skip .zone here, but I find it better to always use it, than miss it when it&#39;s needed)</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_string</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-%dT%H:%M:%S%z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">in_time_zone</span><span class="p">(</span><span class="no">Time</span><span class="o">.</span><span class="n">zone</span><span class="p">)</span> <span class="c1"># If you can&#39;t use parse</span>
</span></code></pre></td></tr></table></div></figure>


<h4>NÃO FAZER</h4>

<figure class='code'><figcaption><span>Date vs Time</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="o">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span>             <span class="c1"># Sem parenteses: x=1;y=[2,3];z=nil</span>
</span><span class='line'><span class="n">x</span><span class="p">,(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="o">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span>           <span class="c1"># Parenteses: x=1;y=2;z=3</span>
</span><span class='line'>
</span><span class='line'><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="o">[</span><span class="mi">2</span><span class="p">,</span><span class="o">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">]]]</span>     <span class="c1"># Sem parenteses: a=1;b=[2,[3,4]];c=d=nil</span>
</span><span class='line'><span class="n">a</span><span class="p">,(</span><span class="n">b</span><span class="p">,(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">))</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="o">[</span><span class="mi">2</span><span class="p">,</span><span class="o">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">]]]</span> <span class="c1"># Parenteses: a=1;b=2;c=3;d=4</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso aí amigos..</p>

<p>Bons estudos e até a proxima! :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atribuições #Ruby]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/03/atribuicoes/"/>
    <updated>2012-06-03T11:55:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/03/atribuicoes</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Atribuições</p>




<h1>Atribuições</h1>


<p>Uma expressão de atribuição especifica um ou mais valores para um ou mais valores. lvalue é o termo para algo que pode aparecer no lado
esquerdo de uma atribuição do operador. Os valores no lado direito de um operador de atribuição são algumas vezes chamado de rvalues ​​por
contraste. Variáveis, constantes, atributos e elementos do Array são lvalues ​​em Ruby. As regras para o significado de expressões de
atribuição são um pouco diferente para diferentes tipos de lvalues, e cada tipo é descrito em detalhe neste post.</p>

<!--more-->


<p>Existem três diferentes formas de expressões de atribuição em Ruby. Atribuição simples envolve um lvalue do operador <code>=</code>, e um rvalue.
Para exemplo:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Define o lvalue x para o valor 1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Atribuição abreviada é uma expressão abreviada que atualiza o valor de uma variável através da aplicação de alguma outro operador (tais
como a adição) ao valor atual da variável. Atribuição abreviada utiliza a atribuição de operadores como <code>+=</code> e <code>*=</code> que combinam operadores binários com uma sinal de igual:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Define o lvalue x para o valor de x + 1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Por fim, a atribuição paralela é qualquer expressão de atribuição que tem mais do que um lvalue ou mais do que um rvalue. Aqui é um simples exemplo:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span> <span class="c1"># Definir x a 1, y a 2 e z a 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>Atribuição paralela é mais complicado quando o número de lvalues não é o mesmo que o número de rvalues ​​ou quando existe um <code>array</code> sobre à direita.</p>

<p>O valor de uma expressão de atribuição é o valor (ou um <code>array</code> dos valores) atribuído. Além disso, o operador de atribuição
é &#8221;Associativo à direita&#8221;, se aparecer várias atribuições em uma única expressão, eles são avaliados da direita para a esquerda.
Isto significa que a atribuição pode ser acorrentado para atribuir o mesmo valor para as múltiplas variáveis:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># X e Y recebem 0</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que este não é um caso de atribuição paralela é duas atribuições simples, acorrentados juntos: Y é atribuído o valor 0, e então x é atribuído o valor da primeira tarefa (também 0).</p>

<h5>Atribuindo a Variáveis</h5>


<p>Quando nós pensamos em atribuição, geralmente pensamos em variáveis ​​e, na verdade, estes são os mais comuns em expressões de atribuição de lvalues. Lembre-se que Ruby tem quatro tipos de variáveis: variáveis ​​locais, variáveis ​​globais, variáveis ​​de instância e variáveis ​​de classe. Estes são distintas um do outro, pelo primeiro carácter no nome da variável. Atribuição funciona da mesma forma para todos os quatro tipos de variáveis, de modo que não é necessário fazer a distinção entre os tipos de variáveis ​​aqui.</p>

<p>Tenha em mente que as variáveis ​​de instância de objetos do Ruby são nunca nomes visíveis fora do objeto, e variável nunca é qualificado com um nome de objeto. Considere esta atribuição:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">ponto</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">ponto</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>Os lvalues ​​nesta expressão não são variáveis, são atributos.</p>

<p>Atribuição a uma variável funciona como seria de se esperar: a variável é simplesmente definida como o valor especificado. Ruby não tem nenhuma sintaxe para declarar explicitamente uma variável: variáveis ​​simplesmente vir à existência quando são atribuídas. Assim, uma  expressão simples como X poderia se referir a uma variável local chamada x ou um método chamado x. Para resolver essa ambigüidade, Ruby trata de um identificador como uma variável local se tem visto qualquer trabalho anterior para a variável. Ele faz isso com uma atribuição nunca foi executada. O código a seguir demonstra isso:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">now</span> <span class="c1"># =&gt; 2012-03-02 16:05:37 +0100</span>
</span><span class='line'><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">to_time</span> <span class="c1"># =&gt; 2012-03-02 00:00:00 +0100</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2012-03-02 16:05:37&quot;</span><span class="p">)</span> <span class="c1"># =&gt; 2012-03-02 16:05:37 +0100</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">now</span> <span class="c1"># =&gt; 2012-03-02 16:07:20 +0100</span>
</span><span class='line'><span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="c1"># This could be yesterday or tomorrow depending on the machine&#39;s time zone!</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_string</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-%dT%H:%M:%S%z&#39;</span><span class="p">)</span> <span class="c1"># You won&#39;t have the time in your configured time zone!</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Epílogo</h3>

<p>Espero que você tenha aprendido alguma coisa com este post. Tenho certeza que fiz ao escrevê-lo! Se você tem
algum comentário sobre como ele pode ser melhorada, ou se você encontrar algum erro, por favor me avise por
postar um comentário abaixo!</p>

<hr />

<p>Agradeço ao amigo <a href="https://twitter.com/cjkihlbom">CJ Kihlbom</a>, abraços amigo&hellip; :D</p>

<hr />
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Teste salva sua carne]]></title>
    <link href="http://rrmartins.com/blog/2012/11/04/teste-salva-sua-carne/"/>
    
    <updated>2012-11-04T09:30:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/11/04/teste-salva-sua-carne</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Galera estou lendo mais um livro, e vou passar para vocês um textículo do inicio do <a href="http://www.amazon.com/Rails-3-Action-Ryan-Bigg/dp/1935182277">Rails 3 in Action</a>.</p>

<p>Lendo o capitulo 1, ele deixou uma pergunta no ar: como você faz aplicações Rails sustentável?</p>

<p>A resposta é que você escreve testes automatizados para a aplicação como você desenvolve, e você escreve isso <strong>o tempo todo</strong>.</p>

<p>Ao escrever testes automatizados para a sua aplicação, você pode rapidamente assegurar que o aplicativo está funcionando
como deveria. Se você não escrever testes, a sua alternativa seria a de verificar toda a aplicação manualmente, o que é
demorado e propício a erros. <strong>Teste automatizado economiza uma tonelada de tempo, a longo prazo e leva a menos bugs.</strong> Os
seres humanos cometem erros; programas (se codificado corretamente) não.</p>

<h2>Teste e desenvolvimento orientado a comportamento</h2>

<p>No mundo <code>Ruby</code> uma enorme ênfase é colocada em teste, especificamente  desenvolvimento orientado a testes (Test-driven
 development - TDD) e desenvolvimento de comportamentos (Behavior-Driven Development - BDD).</p>

<p>Ao aprender técnicas de teste bem como agora, você tem um caminho sólido para se certificar que nada esta quebrado quando
você começa a escrever sua primeira aplicação real Rails. Se você não testar, não há como dizer o que poderia dar errado
seu código.</p>

<p>TDD é uma metodologia que consiste em escrever um caso de teste falho primeiro (geralmente usando uma testar ferramenta
como <code>Test::Unit</code>), em seguida, escrever o código para fazer o teste passar e, finalmente, refatorar o código. Este
processo é comumente chamado de <code>vermelho-verde-refatorar</code>( <code>red-green-refactor</code> ). As razões para desenvolver código desta
forma são duas. Primeiro, faz você considera como o código deve ser executado antes de ser usado por qualquer pessoa. Em
segundo lugar, crie um teste automatizado, você pode executar quantas vezes você quiser para garantir que o seu código ainda
está trabalhando como pretendido.</p>

<p>BDD é uma metodologia baseada em TDD. Você escreve um teste automatizado para verificar a interação entre as diferentes
partes da base de código em vez de testar que cada parte funciona de forma independente.</p>

<p>As duas ferramentas são usadas para o BDD são (RSpec)[<a href="http://rspec.info/">http://rspec.info/</a>] e (Cucumber)[<a href="http://cukes.info/">http://cukes.info/</a>].</p>

<h2>Test-Driven Development</h2>

<p>Uma resposta enigmática mas verdadeira para a pergunta &ldquo;Por que eu deveria testar?&rdquo; é &ldquo;porque você é humano.&rdquo;. Os seres
humanos - a grande maioria deste livro - comete erros. É uma de nossas favoritas maneiras de aprender. Porque os
seres-humanos cometem erros, ter uma ferramenta para informar quando eles fazem um erro é útil, não é? Teste automatizado
fornece uma rápida segurança para informar aos desenvolvedores quando eles cometem erros. Por eles, é claro, queremos dizer
que você. Nós queremos que você faça poucos erros quanto possível. Queremos que salvar sua vida!</p>

<p>TDD e BDD também dar-lhe tempo para pensar nas suas decisões antes de escrever qualquer código. Escrevendo primeiro teste
para a implementação, você é (ou, pelo menos, você deve ser) levado a pensar através da implementação: o código que você
vai escrever depois do teste e como você vai fazer para o teste passar. Se você encontrar um teste difícil de escrever,
então talvez a implementação pode ser melhorada. Infelizmente, não há nenhuma maneira clara de quantificar a dificuldade de
escrever um teste e trabalhar com ele para além de consultar outras pessoas que estão familiarizadas com o processo.</p>

<p>Uma vez que o teste é implementado, você deve ir escrever algum código que o seu teste pode passar. Se você está
trabalhando escrevendo o código primeiro e depois os testes para pegar um bug da implementação, é geralmente melhor
repensar o teste e desfazer sua implementação.</p>

<p><strong>Primeiro teste, código mais tarde.</strong></p>

<p>Até mais amigos!</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Threads e Concorrência - Exemplos de Threads - Part IV - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/11/04/threads-e-concorrencia-exemplos-de-threads-part-iv-number-ruby-1-dot-9/"/>
    
    <updated>2012-11-04T09:20:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/11/04/threads-e-concorrencia-exemplos-de-threads-part-iv-number-ruby-1-dot-9</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Exemplos de Threads</strong>&hellip;</p>

<h4>Exemplos de Threads</h4>

<p>Agora que já passamos alguns post falando do modelo <code>Thread</code> e da API de <code>Thread</code> em Ruby, vamos dar uma olhada em alguns
exemplos reais de vários códigos de <code>threads</code>.</p>

<h3>Leitura de arquivos simultaneamente</h3>

<p>O uso mais comum de <code>threads</code> de Ruby é em programas que são IO. Eles permitem que os programas mantenham ocupado até
mesmo enquanto espera por alguma entrada do usuário, o sistema de arquivos, ou da rede. A seguir de código, por exemplo,
define um método <code>conread</code> (para leitura simultânea) que leva uma série de nomes de arquivos e retorna um mapa de <code>hash</code>
com esses nomes para o conteúdo desses arquivos. Ele usa <code>thread</code> para ler esses arquivos ao mesmo tempo, e é realmente
destinado a ser utilizado com o módulo <code>open-uri</code>, que permite que as URL&rsquo;s <code>HTTP</code> e <code>FTP</code> possam ser abertas com
<code>Kernel.open</code> e ler como se fossem arquivos:</p>

<figure class='code'><figcaption><span>Lendo arquivos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ler arquivos simultaneamente. Use com o módulo &quot;open-uri&quot; para buscar URLs.</span>
</span><span class='line'><span class="c1"># Passe uma matriz de nomes de arquivos. Retorna um mapa de nomes de arquivos de hash para o conteúdo.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">conread</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>
</span><span class='line'>  <span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>             <span class="c1"># hash vazio de resultados</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># Crie uma linha para cada arquivo</span>
</span><span class='line'><span class="err">  </span><span class="n">filenames</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">filename</span><span class="o">|</span>      <span class="c1"># Para cada arquivo chamado</span>
</span><span class='line'><span class="err">    </span><span class="n">h</span><span class="o">[</span><span class="n">filename</span><span class="o">]</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>     <span class="c1"># Criar um fio, mapa para filename</span>
</span><span class='line'><span class="err">      </span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span> <span class="p">}</span>  <span class="c1"># Abra e leia o arquivo</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>                           <span class="c1"># valor da linha é o conteúdo do arquivo</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Percorre o hash, à espera de cada thread para completar.</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Substitua a thread no hash com o seu valor (o conteúdo de arquivo)</span>
</span><span class='line'>  <span class="n">h</span><span class="o">.</span><span class="n">each_pair</span> <span class="k">do</span> <span class="o">|</span><span class="n">filename</span><span class="p">,</span> <span class="n">thread</span><span class="o">|</span>
</span><span class='line'>    <span class="k">begin</span>
</span><span class='line'>      <span class="n">h</span><span class="o">[</span><span class="n">filename</span><span class="o">]</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">value</span>    <span class="c1"># Mapa de nomes ao conteúdo do arquivo</span>
</span><span class='line'>    <span class="k">rescue</span>
</span><span class='line'>      <span class="n">h</span><span class="o">[</span><span class="n">filename</span><span class="o">]</span> <span class="o">=</span> <span class="vg">$!</span>              <span class="c1"># Ou a exceção levantada</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Servidor A Multithreads</h3>

<p>Outra, quase canônico caso, o uso de <code>threads</code> é para escrever servidores que podem comunicar com mais do que um cliente
de cada vez. Vimos como fazer isto utilizando multiplexagem com Kernel.select, mas um pouco mais simples (Embora
possivelmente menos escalável) solução usa <code>threads</code>:</p>

<figure class='code'><figcaption><span>Servidor a Multithreads</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Ambiguous</span><span class="err">  </span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">x</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="k">end</span> <span class="c1"># Um método chamado &quot;x&quot;. Sempre retorna 1  </span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">teste</span><span class="err">    </span>
</span><span class='line'>    <span class="nb">puts</span> <span class="n">x</span> <span class="c1"># Nenhuma variável foi visto, refere-se ao método acima: imprime 1    </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># A linha abaixo não é avaliada, por causa da cláusula &quot;if falsa&quot;. </span>
</span><span class='line'>    <span class="c1"># Mas o analisador vê e trata x como uma variável para o resto do método.    </span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="kp">false</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">puts</span> <span class="n">x</span> <span class="c1"># x é uma variável, mas nunca foi atribuído: irá imprimir nil</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Esta atribuição não é avaliada</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="n">x</span> <span class="c1"># Então agora esta linha imprime 2  </span>
=======
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;socket&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Este método espera um socket ligado a um cliente.</span>
</span><span class='line'><span class="c1"># Ele lê as linhas do cliente, inverte-los e envia-los de volta.</span>
</span><span class='line'><span class="c1"># Múltiplas Threads podem executar este método, ao mesmo tempo.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">handle_client</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'>  <span class="k">while</span> <span class="kp">true</span>
</span><span class='line'>    <span class="n">input</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">gets</span><span class="o">.</span><span class="n">chop</span>     <span class="c1"># Ler uma linha de entrada do cliente</span>
</span><span class='line'>    <span class="k">break</span> <span class="k">if</span> <span class="o">!</span><span class="n">input</span>         <span class="c1"># sai se tem muitas entradas</span>
</span><span class='line'>    <span class="k">break</span> <span class="k">if</span> <span class="n">input</span><span class="o">==</span><span class="s2">&quot;quit&quot;</span>  <span class="c1"># ou se o cliente pede</span>
</span><span class='line'>    <span class="n">c</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="n">input</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span>   <span class="c1"># Caso contrário, responde ao cliente.</span>
</span><span class='line'>    <span class="n">c</span><span class="o">.</span><span class="n">flush</span>                 <span class="c1"># Força a saída para fora</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">c</span><span class="o">.</span><span class="n">close</span>                   <span class="c1"># Fecha o socket cliente</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">server</span> <span class="o">=</span> <span class="no">TCPServer</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="c1"># Ouve na porta 2000</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="kp">true</span>                    <span class="c1"># Laço de servidores para sempre</span>
</span><span class='line'>  <span class="n">client</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">accept</span>      <span class="c1"># Espere um cliente para conectar</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">client</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="c1"># Inicia uma nova thread</span>
</span><span class='line'>    <span class="n">handle_client</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># E Lida com o clinete nessa Thread</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<<<<<<< HEAD


<h5>Atribuindo a Constantes</h5>


<p>Constantes são diferentes das variáveis ​​de uma forma óbvia: seus valores são destinados a permanecer constante durante a execução de um programa. Portanto, existem algumas regras especiais para a atribuição de constantes:</p>

<pre><code>* Atribuição a uma constante que já existe, faz com o Ruby emita um aviso. O Ruby executa a tarefa,
no entanto, que significa que as constantes não são realmente constante.

* Atribuição a constantes não é permitido dentro do corpo de um método. Ruby assume que os métodos 
destinados a ser invocados mais de uma vez, se você poderia atribuir a uma constante em um método, 
que método ira emitir alertas a cada requisição após a primeira.  Então, isso simplesmente não é 
permitido.
</code></pre>

<p>Ao contrário das variáveis, as constantes não vem a existir até que o <code>Intérprete Ruby</code> realmente executa a expressão de atribuição. A expressão não avaliada abaixo, não cria uma constante:</p>

<figure class='code'><figcaption><span>Atribuiçao de Constante</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="kp">false</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que isto significa que uma constante nunca está em um estado de inicialização. Se uma constante existe, então ele tem um valor atribuído a ela. A constante só terá valor se o valor realmente for <code>nil</code>.</p>

<h5>Atribuindo a Atributos e elementos de Array</h5>


<p>Atribuição a um atributo ou um elemento de um <code>Array</code> é na verdade uma abreviação do Ruby para a invocação método. Suponha que um objeto tem um método chamado <code>m=:</code>, o nome do método tem um sinal de igual como seu último caractere. Em seguida, <code>o.m</code> pode ser usado como um lvalue em uma expressão de atribuição. Suponha, além disso, que o valor v é atribuído:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">v</span>
</span></code></pre></td></tr></table></div></figure>


<p>O interpretador Ruby converte essa tarefa para a seguinte invocação de método:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">m</span><span class="o">=</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c1"># Se omitir os parênteses e adicionar um espaço, isso parece tarefa!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isto é, ele passa o valor v para o método <code>m=</code>. Esse método pode fazer o que quiser com o valor. Normalmente, ele irá verificar que o valor é de desejado tipo e dentro da gama desejada, e, em seguida, armazená-lo em uma variável de instância do objeto. Métodos como <code>m=</code> são geralmente acompanhados de um método <code>m</code>, que simplesmente retorna o valor mais recentemente passado para <code>m=</code>. Alguns dizem que <code>m=</code> é um método setter e <code>m</code> é um método getter. Quando um objeto tem esse par de métodos, dizemos que ele tem um atributo <code>m</code>. Atributos são às vezes chamado de &#8220;Propriedades&#8221; em outras línguas.</p>

<p>Atribuindo valores aos elementos de um <code>Array</code> também é feito pelo método de invocação. Se um objeto define um método chamado <code>[]=</code> (nome do método é apenas esses três caracteres de pontuação) que espera dois argumentos, então na expressão o <code>[x] = y</code> é realmente executado como:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">[</span><span class="o">]=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se um objeto tem um método <code>[]=</code> que espera três argumentos, então ele pode ser indexado com dois valores entre os colchetes. As dois seguintes expressões são equivalentes neste caso:</p>

<figure class='code'><figcaption><span>Atribuição</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">z</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">[</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<h5>Atribuição Abreviada</h5>


<p>Atribuição Abreviada é uma forma de atribuição que combina atribuição com alguns outras operações. Ele é usado mais comumente para incrementar variáveis:</p>

<figure class='code'><figcaption><span>Atribuição Abreviada</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>O <code>+=</code>, não é um operador real de Ruby, e a expressão acima é simplesmente uma abreviatura para:</p>

<figure class='code'><figcaption><span>Atribuição Abreviada</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>Atribuição Abreviada não pode ser combinado com paralelo de atribuição: ela só funciona quando há um único lvalue à esquerda e um único valor do lado direito. Ela não deve ser usado quando o lvalue é uma constante, porque ele vai reatribuir a constante e causar um aviso. Atribuição abreviada pode, contudo, ser utilizado quando o lvalue é um atributo. As duas expressões a seguir são equivalentes:</p>

<figure class='code'><figcaption><span>Atribuição Abreviada</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">m</span><span class="o">=</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">m</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Atribuição abreviada funciona até mesmo quando o lvalue é um elemento de um <code>array</code>. Estas duas expressões são equivalente:</p>

<figure class='code'><figcaption><span>Atribuição Abreviada</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">-=</span> <span class="mi">2</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">[</span><span class="o">]=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">[</span><span class="o">]</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Observe que esse código usa <code>-=</code> em vez de <code>+=</code>. Como você poderia esperar, o <code>-=</code> é pseudooperator que subtrai seu rvalue a partir do seu lvalue.</p>

<p>Além <code>+=</code> e <code>-=</code>, há outros 11 pseudooperators que podem ser usados ​​para atribuição abreviada. Eles são listados abaixo. Note-se que estes não são verdadeiros operadores próprios, eles são simplesmente uma abreviação para expressões que usam outros operadores. Muitos desses outros operadores são definidos como métodos. Se uma classe define um método chamado <code>+</code>, por exemplo, em seguida, que as alterações do sentido da Atribuição abreviada com <code>+=</code> para todas as instâncias dessa classe.</p>

<pre><code>Atribuição                          Expansão
x += y                              x = x + y
x -= y                              x = x - y
x *= y                              x = x * y
x /= y                              x = x / y
x %= y                              x = x % y
x **= y                             x = x ** y
x &amp;&amp;= y                             x = x &amp;&amp; y
x ||= y                             x = x || y
x &amp;= y                              x = x &amp; y
x |= y                              x = x | y
x ^= y                              x = x ^ y
x &lt;&lt;= y                             x = x &lt;&lt; y
x &gt;&gt;= y                             x = x &gt;&gt; y
</code></pre>

<p>É isso aí amigos&#8230; até o proximo post!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Invocações de método]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/invocacoes-de-metodo/"/>
    <updated>2012-06-02T15:36:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/invocacoes-de-metodo</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Invocações de método</h1>


<p>Uma expressão de invocação de método tem quatro partes:</p>

<ul>
<li><p>Uma expressão arbitrária cujo valor é o objeto no qual o método é chamado. Esta expressão é seguido por . ou :: para separá-lo a partir
do nome do método que se segue. A expressão e o separador são opcionais; se omitido, o método é invocada em si mesmo.</p></li>
<li><p>O nome do método a ser invocado. Este é o único pedaço exigido de uma expressão chamada de método.</p></li>
<li><p>Valores com o argumento passado para o método. A lista de argumentos podem ser colocados entre parênteses, mas estes são geralmente
opcionais. Se há mais de um argumento, eles são separados uns dos outros com vírgulas. O número e tipo de argumentos necessários
dependem da definição do método. Alguns métodos podem ser chamodos sem argumentos.</p></li>
<li><p>Um bloco opcional de código delimitado por chaves ou por um par <code>do/end</code>. O método pode invocar esse código usando a palavra-chave de
 <code>yield</code>. Esta capacidade de associar código arbitrário com qualquer invocação de método é a base para métodos poderosos em Ruby.</p></li>
</ul>


<p>Um nome do método é normalmente separado do objeto sobre o qual é chamado com um <code>..</code>, e com o <code>::</code>, que também é permitido, mas é raramente
usado porque pode fazer invocações de método parecem mais com referênciar constantes expressões.</p>

<p>Quando o interpretador Ruby tem o nome de um método e um objeto em que deve ser invocado, ele encontra a definição adequada do método
chamado usando um processo conhecido como &#8220;método de pesquisa&#8221; ou &#8220;resolução de nome do método.&#8221; Os detalhes não são importantes aqui,
mas eles são explicados completamente no método de pesquisa.</p>

<p>O valor de uma invocação expressão de método é o valor da expressão avaliada pelo último método no corpo do código. Aqui, no entanto, são
alguns exemplos de invocações de método:</p>

<figure class='code'><figcaption><span>Ruby</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;Olá mundo&quot;</span> <span class="c1"># &quot;puts&quot; invocado em auto, com uma seqüência de arg</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># &quot;sqrt&quot; invocado em Matemática objeto com uma arg</span>
</span><span class='line'><span class="n">message</span><span class="o">.</span><span class="n">length</span> <span class="c1"># &quot;comprimento&quot; invocado em mensagem objeto; não args</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">p</span> <span class="n">x</span><span class="p">}</span> <span class="c1"># &quot;cada&quot; chamado em um objeto, com um bloco associado</span>
</span></code></pre></td></tr></table></div></figure>


<p>Um dos exemplos do método de invocação mostradas anteriormente foi <code>message.length</code>. Você pode ser tentado a pensar-lo como uma variável
de expressão de referência, avaliando para o valor do comprimento da variável do objeto mensage. Este não é o caso, no entanto, Ruby tem
um modelo de programação muito orientada a objetos: objetos em Ruby podem encapsular qualquer número de variáveis ​​de instância interna,
mas expõem métodos apenas para o mundo exterior. Como o método <code>length</code> não espera argumentos e é chamado sem os parênteses opcionais,
parece que referência uma variável. Na verdade, isso é intencional. Métodos como estes são chamados para atribuir métodos de acesso, e
dizemos que o objeto da <code>mensage</code> tem um atributo de <code>lenght</code>. Como veremos, é possível que o objeto de <code>mensage</code>
para definir um método chamado <code>length=</code>. Se este método espera um único argumento, então é um método setter do atributo e
Ruby invoca em resposta a atribuição. Se um tal método é definido, então estas duas linhas de código seria tanto chamar o mesmo método:</p>

<figure class='code'><figcaption><span>Length</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">message</span><span class="o">.</span><span class="n">length</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># invocação do método tradicional</span>
</span><span class='line'><span class="n">message</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># invocação Método como a atribuição</span>
</span></code></pre></td></tr></table></div></figure>


<p>Agora, considere a seguinte linha de código, assumindo que uma variável contém um <code>Array</code>:</p>

<figure class='code'><figcaption><span>Array</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Você pode pensar novamente que este é um tipo especial de variável de referência, onde a variável em questão é na verdade um elemento do
<code>Array</code>. Novamente, no entanto, esta é invocação do método. O intérprete Ruby converte o acesso ao <code>Array</code> para isso:</p>

<figure class='code'><figcaption><span>Array</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">[</span><span class="o">]</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>O acesso ao <code>Array</code> torna-se uma invocação do método chamado <code>[]</code>, com o índice do <code>Array</code> como seu
argumento. Esta sintaxe de acesso de <code>Array</code> não se limita a <code>Arrays</code>. Qualquer objeto é permitido para definir um
método chamado <code>[]</code>. Quando o objeto é &#8220;indexado&#8221;, com o indix entre parênteses, os valores dentro dos parênteses será passado
para o método. Se o método <code>[]</code> é escrito para esperar três argumentos, então você deve colocar três expressões separados por
vírgula dentro dos colchetes.</p>

<p>Atribuição de <code>Arrays</code> também é feito através de invocação de método. Se o objeto o define um método chamado <code>[]=</code>, então a expressão <code>o[x] = y</code> torna-se <code>o.[] = (x, y)</code>, e a expressão <code>o[x, y] = z</code> se torna <code>o.[] = (x , y, z)</code>.</p>

<p>Muitos operadores do Ruby são definidos como métodos, e expressões como <code>x + y</code> são avaliados como <code>x.+(y)</code>, onde o
nome de método é <code>+</code>. O fato de que muitos dos operadores do Ruby são definidos como métodos que significa você pode redefinir
esses operadores na sua próprias classes.</p>

<p>Agora, vamos considerar esta expressão muito simples:</p>

<figure class='code'><figcaption><span>Ruby</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se uma variável x nomeada existe (Isto é, se o interpretador Ruby tem visto uma atribuição a x), então esta é uma variável de referência.
Se nenhuma variável existe, então esta é uma invocação do método x, sem argumentos.</p>

<p>A palavra <code>super</code> em Ruby é um tipo especial de invocação de método. Esta palavra é usada ao criar uma subclasse de outra
classe. Por si só, <code>super</code> passa os argumentos do método corrente para o método com o mesmo nome na superclasse. Ele também
pode ser usado como se fosse realmente o nome de um método e pode ser seguido por uma lista de argumentos arbitrários. A palavra-chave
<code>super</code> é abordada em detalhes no Aumentando Comportamento por encadeamento.</p>

<p>Até a Proxima&#8230; :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variáveis ​​não inicializadas]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas/"/>
    <updated>2012-06-02T11:30:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Variáveis ​​não inicializadas</h1>


<p>Em geral, você deve sempre atribuir um valor para, ou inicializar as variáveis ​​antes de usá-las em expressões. Em algumas circunstâncias,
no entanto, Ruby lhe permitirá utilizar variáveis ​​que ainda não foram inicializadas. As regras são diferentes para diferentes tipos de variáveis:</p>

<h4>Variáveis ​​de classe</h4>


<pre><code>Variáveis ​​de classe deve sempre ter um valor atribuído a elas antes que serem utilizadas. Ruby levanta uma NameError se 
referir a uma variável de classe à qual nenhum valor foi atribuído.
</code></pre>

<h4>Variáveis ​​de instância</h4>


<pre><code>Se você se referir a uma variável de instância não inicializada, Ruby retorna nil. Considera-se má programação de 
contar com esse comportamento, no entanto. Ruby vai emitir um aviso sobre a variável não inicializada se você executá-la 
com a opção -w.
</code></pre>

<h4>As variáveis ​​globais</h4>


<pre><code>Variáveis ​​globais não inicializadas são como o exemplo de variáveis não inicializadas: elas igualam a nil, mas mostra 
um aviso quando o Ruby é executado com o flag do -w.
</code></pre>

<h4>As variáveis ​​locais</h4>


<pre><code>Este caso é mais complicado que os outros, porque variáveis locais ​​não têm um caractere de pontuação como um prefixo. 
Este significa que variáveis ​​locais referênciam olhando apenas como uma invocação de método de expressões. Se o 
interpretador Ruby tem visto uma atribuição de uma variável local, ele sabe que é uma variável e não um método, 
e pode retornar o valor da variável. Se não tiver havido nenhuma atribuição, então o Ruby trata a expressão como uma 
invocação de método. Se nenhum método com esse nome existe, Ruby levanta um NameError.

Em geral, portanto, a tentativa de usar uma variável local antes de ter sido inicializada resulta em um erro. Existe 
uma peculiaridade, uma variável passa a existir quando o interpretador Ruby vê uma expressão de atribuição para essa 
variável. Este é o caso, mesmo se essa atribuição não é realmente executada. A variável que existe, mas não foi 
atribuído um valor, é dado o valor nulo   como padrão. Por exemplo:
</code></pre>

<figure class='code'><figcaption><span>Variaveis</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">if</span> <span class="kp">false</span> <span class="c1"># atribuição Isso nunca é executado</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">a</span> <span class="c1"># Imprime nulo: a variável existe mas não é atribuída</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">b</span> <span class="c1"># NameError: nenhuma variável ou método chamado existe b</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html">Variaveis Ruby 1.9.2</a></p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variáveis de Referência]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia/"/>
    <updated>2012-06-01T13:16:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis de Referência</p>




<h1>Variáveis de Referência</h1>


<p>Uma variável é simplesmente um nome para um valor. As variáveis ​​são criadas e os valores que lhes são atribuídos por expressões
de atribuição. Quando o nome de uma variável aparece num programa em qualquer lugar que não seja o lado esquerdo de uma atribuição, é uma
variável de referência à expressão e avaliado como o valor da variável:</p>

<figure class='code'><figcaption><span>Referência</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="c1"># Esta é uma atribuição de expressão</span>
</span><span class='line'><span class="n">one</span> <span class="c1"># Essa referência de expressão da variável, que imprimi 1.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>Existem quatro tipos de variáveis ​​em Ruby, e regras <a href="http://pt.wikipedia.org/wiki/Item_lexical">lexicais</a> para governar seus nomes. Variáveis que começam com $ são variáveis ​​globais, visível ao longo de um programa Ruby. Variáveis ​​que começam com @ e @@ são
variáveis ​​de instância e variáveis ​​de classe, usado em programação orientada a objeto. E as variáveis ​​cujos nomes começam com um sublinhado
ou uma letra minúscula são variáveis ​​locais, definidas apenas dentro do atual método ou bloco.</p>

<p>Variáveis ​​sempre são simples, nomes não qualificados. Se um . ou :: aparece em uma expressão, em seguida, que a expressão é ou um
uma referência a uma constante ou uma invocação de método. Por exemplo, Math::PI é uma referência a uma constante, e a expressão
item.preco é uma invocação do método chamado preco (preço) sobre o valor realizado pela variável item.</p>

<p>O interpretador Ruby predefine um número de variáveis ​​globais quando ele é iniciado.</p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emergencia]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/28/emergencia/"/>
    <updated>2012-05-28T13:24:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/28/emergencia</id>
    <content type="html"><![CDATA[<p>Emergencia</p>

<p>A emergencia é um dos princípios fundamentais da agilidade, e é a coisa mais próxima da magia pura. Propriedades emergenciais não são
projetadas ou vêm prontas, elas simplesmente acontecem como um resultado dinâmico do resto do sistema. “Emergencia” vem do Latim da metade
do século 17, que significa “ocorrência não prevista”. Você não pode planejá-la ou agendá-la, mas pode cultivar um ambiente em que a deixe
ocorrer, se beneficiando dela.</p>

<p>Um exemplo clássico de emergência está no comportamento dos bandos de pássaros. Uma simulação de computador pode usar apenas três regras
simples (parecidas com “não colida-se com outros”) e de repente você tem comportamento complexo quando o bando vai batendo as asas
graciosamente pelos céus, se remodelando em torno de obstáculos e assim por diante. Nenhum desses comportamentos avançados (como se
remodelar na mesma forma ao redor de obstáculos) é especificado pelas regras; eles emergem da dinâmica do sistema.</p>

<p>Regras simples, como na simulação dos pássaros, leva a comportamentos complexos. Regras complexas, como com leis tributárias na maioria
dos países, levam a comportamentos estúpidos.</p>

<p>Muitas práticas comuns de desenvolvimento de software tem o infeliz efeito-colateral de eliminar qualquer chance de comportamento emergente. A maioria das tentativas de otimização – amarrando alguma coisa muito explicitamente – reduz a extensão e escopo de interações e relacionamentos, que é a origem da emergencia. No exemplo do bando de pássaros, assim como sistemas bem-desenhados, são as interações e relacionamentos que criam os comportamentos interessantes.</p>

<p>Quanto mais amarramos as coisas, menos espaço deixamos para uma solução criativa e emergente. Seja tanto travando requisitos, antes de serem bem entendidos ou otimizando o código prematuramente, como inventando navegações e cenários de fluxo de trabalho complexas, antes de deixar o usuário final usar o sistema, o resultado é o mesmo: um sistema exageramente complicado e estúpido ao invés de um sistema limpo e elegante que aproveita a emergencia.</p>

<p>Mantenha pequeno. Mantenha simples. Deixe acontecer.</p>

<pre><code>—Andrew Hunt, The Pragmatic Programmers 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A presença de paixão]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/28/naa-presenca-de-paixao/"/>
    <updated>2012-05-28T13:13:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/28/naa-presenca-de-paixao</id>
    <content type="html"><![CDATA[<p>Como um apaixonado por codigo aberto, estou lendo o livro <a href="http://gettingreal.37signals.com/GR_por.php">&#8220;Caindo na Real&#8221;</a>, e me deparei com uma parte muito boa..</p>

<p>Então, vejam ai uma parte muito boa, só para dar um gostinho! :D</p>

<h2>A presença de paixão</h2>


<p>Em design, onde o significado é normalmente e controversamente subjetivo ou dolorosamente indecifrável, poucas coisas são mais aparentes e lúcidas do que a presença de paixão. Isso é verdade seja quando o design do produto o agrada ou o deixa frio; em ambos os casos é difícil não detectar o investimento emocional das mãos que o construíram.</p>

<p>Entusiasmo se manifesta prontamente, claro, mas indiferença é igualmente inesquecível. Se seu compromisso não vem com paixão genuína para o trabalho às mãos, isso se torna um vazio que é quase impossível de conciliar, não importa o quão elaborado ou atrativo é o design.</p>

<pre><code>—Khoi Vinh, Subtraction.com
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Literais e Palavras-Chaves Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais/"/>
    <updated>2012-05-27T12:15:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Literais e Plavras-chaves literais</p>




<h1>Literais e Plavras-chaves literais</h1>


<p>Literais são valores como 1.0, &#8220;Hello world&#8221;, e [] que são incorporados diretamente em seu texto do programa.</p>

<p>É interessante notar que muitos literais, tais como números, são as principais expressões - as expressões mais simples possíveis não
compostas de expressões simples. Literais, tais como Array e literais de hash e strings duplas citadas que usam interpolação, incluem
sub-expressões e são, portanto, expressões não primárias.</p>

<p>Determinadas palavras-chave em Ruby são expressões primárias e podem ser considerados palavras-chave literais ou formas especializadas
de referência da variável:</p>

<pre><code>nil            -&gt;   Avalia o valor nulo, de NilClass classe.
true           -&gt;   Avalia-se à instância singleton da Classe TrueClass, que um objeto representa o valor booleano 
                    verdadeiro.
false          -&gt;   Avalia-se à instância singleton da Classe FalseClass, que um objeto representa os valores booleanos
                    falsos.
self           -&gt;   Auto avalia o objeto atual.
__FILE__       -&gt;   Avalia a uma string que nomeia o arquivo que o Ruby Intérprete (IRB) está em execução. Isto pode ser
                    útil em erro de mensagens.
__LINE__       -&gt;   Avalia como um inteiro que especifica o número da linha dentro da linha do código atual do __FILE__.
__ENCODING__   -&gt;   Avalia a um objeto Encoding que especifica a codificação do arquivo atual. (Ruby 1.9 apenas.)
</code></pre>

<p>É isso ai galera, até o proximo post.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Expressões e Operadores - O inicio]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/23/aexpressoes-e-operadores-o-inicio/"/>
    <updated>2012-05-23T07:22:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/23/aexpressoes-e-operadores-o-inicio</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Expressões e Operadores</p>




<h1>Expressões e Operadores</h1>


<p>Uma expressão é um pedaço de código Ruby que o interpretador Ruby pode avaliar para produzir um valor. Aqui estão alguns exemplos
de expressões:</p>

<figure class='code'><figcaption><span>Expressões</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<h3>Iteradores simultâneas</h3>

<p>Embora tarefas IO são o caso de uso típico para <code>threads</code> de Ruby, eles não se restringem aos que usam. O código a seguir
adiciona um método <code>conmap</code> (por mapa concorrente) para o modulo <code>Enumerável</code>. Ele funciona como mapa, mas processa cada
elemento da matriz de entrada com uma distinta <code>Thread</code>:</p>

<figure class='code'><figcaption><span>Iterador Simultâneo</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Enumerable</span>           <span class="c1"># Abre o módulo Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">conmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>        <span class="c1"># Define um novo método que espera um block</span>
</span><span class='line'>    <span class="n">threads</span> <span class="o">=</span> <span class="o">[]</span>            <span class="c1"># Começa com uma matriz vazia de threads</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>     <span class="c1"># Para cada item enumerable</span>
</span><span class='line'>      <span class="c1"># Chama o bloco em uma nova Thread, e lembra da Thread</span>
</span><span class='line'>      <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="c1"># Agora mapea o conjunto de Threads para os seus valores</span>
</span><span class='line'>    <span class="n">threads</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="p">}</span> <span class="c1"># E retorna a matriz de valores</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>E aqui está uma versão concorrente similar do iterador de cada um:</p>

<figure class='code'><figcaption><span>Módulo Enumerable</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">concurrently</span>
</span><span class='line'>    <span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="k">yield</span> <span class="n">item</span> <span class="p">}}</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">join</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>O código é sucinto e desafiador: se você pode fazer sentido, você está bem em seu caminho para o domínio da sintaxe de
Ruby e iteradores Ruby.</p>

<p>Lembre-se que no Ruby 1.9, iteradores padrões que não são passado um bloco retorna um objeto enumerador. Isto significa
que, dado o método <code>concurrently</code> definido mais cedo e um objeto <code>Hash h</code>, podemos escrever:</p>

<figure class='code'><figcaption><span>Método Concurrently</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">h</span><span class="o">.</span><span class="n">each_pair</span><span class="o">.</span><span class="n">concurrently</span> <span class="p">{</span><span class="o">|*</span><span class="n">pair</span><span class="o">|</span> <span class="n">process</span><span class="p">(</span><span class="n">pair</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Até o proximo amigos!</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Threads e Concorrência - Escalando Threads - Part III - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-escalando-threads-part-iii-number-ruby-1-dot-9/"/>
    
    <updated>2012-10-28T15:04:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-escalando-threads-part-iii-number-ruby-1-dot-9</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Escalando Threads</strong>&hellip;</p>

<h2>Threads e Concorrência</h2>

<h3>Escalando Threads</h3>

<p>Intérpretes do Ruby(irb), muitas vezes têm mais <code>threads</code> para executar do que há CPU tem disponível para executá-los. Quando
o processamento paralelo verdadeiro não é possível, é simulado através da partilha de uma CPU entre <code>threads</code>. O processo para
a partilha de uma CPU entre as <code>threads</code> é chamado de escalonamento de <code>threads</code>. Dependendo da implementação e plataforma,
agendamento de <code>threads</code> pode ser feito pelo Intérprete do Ruby(irb), ou pode ser tratado pelo sistema operacional.</p>

<h4>Prioridades da Thread</h4>

<p>O primeiro fator que afeta o agendamento de <code>threads</code> é prioridades de <code>thread</code>: com a alta prioridade da <code>thread</code> são
agendadas antes de baixa prioridade de <code>thread</code>. Mais precisamente, uma <code>thread</code> só vai ficar o tempo de CPU, se não houver
maior prioridade de <code>thread</code> aguardando para ser executada.</p>

<p>Definir e consultar a prioridade de um objeto Ruby <code>Thread</code> com <code>priority=</code> e <code>priority</code>. Note-se que não há nenhuma maneira
de definir a prioridade de uma <code>thread</code> antes que ela comece a funcionar. Uma <code>thread</code> pode, no entanto, aumentar ou diminuir
sua própria prioridade como a primeira ação que toma.</p>

<p>Uma <code>thread</code> recém-criada começa com a mesma prioridade que a <code>thread</code> que a criou. A <code>thread</code> principal começa na prioridade
 0.</p>

<p>Como muitos aspectos de <code>threading</code>, prioridades de <code>threads</code> são depende da implementação do <code>Ruby</code> e do subjacente sistema
operacional. No Linux, por exemplo, <code>threads</code> não privilegiadas não pode ter as suas prioridades levantada ou abaixada. Assim,
no Ruby 1.9 (que usa <code>threads</code> nativas) no <code>Linux</code>, a definição de prioridades de <code>Thread</code> é ignorada.</p>

<h4>Aquisição de Thread e Thread.pass</h4>

<p>Quando várias <code>Threads</code> com a mesma prioridade precisam compartilhar a CPU, cabe a <code>thread</code> programada para decidir quando e
por quanto tempo, cada <code>thread</code> é executada. Alguns escalonadores são antecipadas, o que significa que elas permitem a <code>thread</code>
a ser executada apenas por um determinado período de tempo antes de permitir outra <code>thread</code> da mesma prioridade para ser
executada. Outros programadores não são preempção: uma vez que uma <code>thread</code> começa a correr, ela continua funcionando a menos
que durma, blocos para I/O, ou uma <code>thread</code> de maior prioridade acorda.</p>

<p>Se uma longa linha de computação liga (ou seja, aquela que nunca faz bloqueio para I/O) está em execução em um agendador
não preemptivo, ela vai &ldquo;morrer de fome&rdquo; as outras <code>threads</code> com a mesma prioridade, e elas nunca tem a chance de correr.
Para evitar esse problema, de longa duração <code>compute-bound</code> <code>threads</code> devem chamar periodicamente <code>Thread.pass</code> para pedir o
programador para produzir a CPU para outra <code>thread</code>.</p>

<p>Até a proxima amigos! :D</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Threads e Concorrência - Threads e Variáveis - Part II - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-threads-e-variaveis-part-ii-number-ruby-1-dot-9/"/>
    
    <updated>2012-10-28T14:53:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-threads-e-variaveis-part-ii-number-ruby-1-dot-9</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Threads e Variáveis</strong>&hellip;</p>

<h2>Threads e Concorrência</h2>

<h3>Threads e Variáveis</h3>

<p>Uma das características-chave de <code>Thread</code> é que elas podem compartilhar o acesso a variáveis. Como <code>Threads</code> são definidas
por blocos, eles têm acesso a qualquer que seja variáveis ​​(variáveis ​​locais, variáveis ​​de instância, variáveis ​​globais e
 assim por diante) estão no escopo do bloco:</p>

<figure class='code'><figcaption><span>Thread e Variavel</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Esta Thread pode consultar e definir a variável x</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Esta Thread e também consulta e seta x</span>
</span><span class='line'><span class="err">  </span><span class="c1"># E pode consultar e definir T1 e T2 também.</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Quando dois ou mais <code>Thread</code> de ler e escrever as mesmas variáveis ao mesmo tempo, elas devem tomar cuidado para que elas o
fazem corretamente. Nós vamos ter mais a dizer sobre isso quando consideramos a sincronização de <code>threads</code> abaixo.</p>

<h4>Thread-privadas variáveis</h4>

<p>Variáveis ​​definidas dentro do bloco de uma <code>thread</code> são particulares para essa <code>thread</code> e não são visíveis para qualquer
outra <code>thread</code>. Isto é simplesmente consequência de regras de variáveis de escopo ​​Ruby.</p>

<p>Muitas vezes queremos uma <code>Thread</code> tenha sua própria cópia privada de uma variável de modo a que o seu comportamento não se
altere se o valor do referido mude de variáveis. Considere o seguinte código, que tenta criar três tópicos que impressão (
respectivamente) os números 1, 2 e 3:</p>

<figure class='code'><figcaption><span>Threads Privadas</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="n">n</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Em algumas circunstâncias, em algumas implementações, este código pode funcionar como o esperado e imprimir os números 1, 2 e
3. Em outras circunstâncias, ou em outras implementações, talvez não. É perfeitamente possível (se tópicos recentemente
criados não executa de imediato) para o código imprimir 4, 4, e 4, por exemplo. Cada thread lê uma cópia compartilhada da
variável n, e o valor ds mudanças de variáveis ​​como o loop é executado. O valor impresso pela <code>thread</code> depende de quando esse
segmento é executado em relação para a thread pai.</p>

<p>Para resolver este problema, passamos o valor atual de n para o método <code>Thread.new</code>, e atribuimos o atual valor da variável a
um parâmetro de bloco. Parâmetros de bloco são privados para o bloco, e este valor particular não é partilhado entre tópicos:</p>

<figure class='code'><figcaption><span>Threads Privadas</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span>
</span><span class='line'>  <span class="c1"># Obtem uma cópia privada do valor atual de n em x</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que temos uma outra forma de resolver este problema é a utilização de um iterador em vez de um loop <code>while</code>. Neste
caso, o valor de <code>n</code> é modificado para particular para o bloco externo e nunca durante a execução desse bloco:</p>

<figure class='code'><figcaption><span>Thread Privada com Interator</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span> <span class="n">n</span> <span class="o">|</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="nb">puts</span> <span class="n">n</span><span class="p">}}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Variáveis ​​de Threads locais</h4>

<p>Algumas das variáveis especiais globais de Ruby são <code>thread</code> local: elas podem ter valores diferentes em <code>threads</code> diferentes.
<code>$SAFE</code> e <code>$~</code> são exemplos. Isto significa que, se dois <code>thread</code> estão realizando conconrrencia de expressão regular ao mesmo
tempo, eles vão ver diferentes valores de <code>$~</code>, e a realização de um jogo em um fio não irá interferir com os resultados de
um jogo executado na outra discussão.</p>

<p>A classe <code>Thread</code> provê <code>hash-like</code> como o comportamento. Ele define métodos de instância <code>[]</code> e <code>[]=</code> que permitem associar
valores arbitrários com qualquer símbolo. (Se você usar uma cadeia de caracteres em vez disso, ele será convertido em um
símbolo. Ao contrário <code>hashs</code> de verdade, a classe <code>Thread</code> só permite símbolos como chaves.) Os valores associados a estes
símbolos comportam-se como variáveis ​​de <code>Thread</code> locais. Eles não são privados como variáveis de block ​​locais porque qualquer
<code>Thread</code> pode pesquisar um valor em qualquer outra <code>Thread</code>. Mas eles não são variáveis partilhadas, uma vez que cada Thread
pode ter a sua própria cópia.</p>

<p>Como exemplo, suponha que nós criamos <code>thread</code> para download de arquivos de um servidor web. A <code>Thread</code> principal pode querer
monitorar o progresso do download. Para permitir isso, cada <code>Thread</code> pode fazer o seguinte:</p>

<figure class='code'><figcaption><span>Thread de progresso</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="o">[</span><span class="ss">:progress</span><span class="o">]</span> <span class="o">=</span> <span class="n">bytes_received</span>
</span></code></pre></td></tr></table></div></figure>


<p>A <code>Thread</code> principal poderia, então, determinar o total de bytes baixado com um código como este:</p>

<figure class='code'><figcaption><span>Thread de progresso</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">download_threads</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">t</span><span class="o">[</span><span class="ss">:progress</span><span class="o">]</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Junto com <code>[]</code> e <code>[]=</code>, <code>Thread</code> também define um método <code>key?</code> para testar se uma determinada chave existe para uma discussão
. Os métodos <code>keys</code> retorna uma matriz de símbolos que representam as chaves definidas para a <code>Thread</code>. Este código pode ser
melhor escrito como se segue, de modo que ela trabalhe de tópicos que ainda não começou a correr e não tenha definido a chave
:progress ainda:</p>

<figure class='code'><figcaption><span>Thread de progresso</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">download_threads</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">t</span><span class="o">[</span><span class="ss">:progress</span><span class="o">]</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">key?</span><span class="p">(</span><span class="ss">:progress</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Até a proxima galera! :D</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Threads e Concorrência - Part I - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-part-i-number-ruby-1-dot-9/"/>
    
    <updated>2012-10-28T14:26:00-02:00</updated>
    <id>http://rrmartins.com/blog/2012/10/28/threads-e-concorrencia-part-i-number-ruby-1-dot-9</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.3/">Ruby</a>, é hora de nos aprofundar em um pouco de <strong>Threads e Concorrência</strong> agora <strong>Thread Lifecycle</strong>&hellip;</p>

<h2>Threads e Concorrência</h2>

<p>Programas tradicionais têm uma única &ldquo;thread de execução&rdquo;: as declarações ou instruções que compõem o programa são executadas
sequencialmente até que o programa termina. Um programa multithread tem mais de uma <code>thread</code> de execução. Dentro de cada <code>
thread</code>, os comandos são executados sequencialmente, mas as próprias <code>threads</code> podem ser executadas em paralelo em uma
CPU multicore, por exemplo. Frequentemente (em um núcleo único, uma única CPU, por exemplo), várias <code>Threads</code> não são na
realidade executadas em paralelo, mas o paralelismo é simulada intercalando a execução das <code>threads</code>.</p>

<p>Programas como o software de processamento de imagem que fazem um monte de cálculos estão a ser dito <code>compute-bound</code>. Eles só
podem beneficiar de multithreading, se há realmente múltiplas CPUs para executar os cálculos em paralelo. A maioria dos
programas não são totalmente vinculados a computação, no entanto. Muitos, como navegadores web, passam a maior parte de seu
tempo de espera para a rede ou arquivo <code>I/O</code>. Programas como estes estão a ser dito <code>IO-bound</code>. Programas <code>IO-bound</code> pode ser
útil mesmo quando várias <code>threads</code> há apenas uma única CPU disponível. Um navegador pode tornar uma imagem em uma <code>thread</code>
enquanto outra <code>thread</code> está à espera para a próxima imagem para ser baixada da rede.</p>

<p>Ruby faz com que seja fácil de escrever programas <code>multi-threaded</code> com a <code>Class Thread</code>. Para iniciar uma nova <code>thread</code>,
apenas associa um bloco com uma chamada para <code>Thread.new</code>. Uma nova <code>thread</code> será criada para executar o código no bloco, e a
<code>thread</code> original retornará do <code>Thread.new</code> imediatamente e continuar a execução com a afirmação seguinte:</p>

<figure class='code'><figcaption><span>Iniciando um thread</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Thread #1 está sendo executado aqui</span>
</span><span class='line'><span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Thread #2 executa esse código</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1"># Thread #1 executa esse código</span>
</span></code></pre></td></tr></table></div></figure>


<p>Vamos começar nossa cobertura de <code>threads</code> explicando o modelo <code>Thread</code> de Ruby e API em alguns detalhes. Estas seções
introdutórias explicam as coisas como ciclo de vida da <code>thread</code>, agendamento de threads, e os estados da <code>thread</code>. Com que o
material introdutório como pré-requisito, passamos a apresentar código de exemplo e para cobrir <code>threads</code> avançadas como
sincronização de <code>threads</code>.</p>

<p>Finalmente, é importante notar que os programas de Ruby também pode alcançar simultaneidade ao nível do processo de sistema
operacional executando executáveis externos ​​ou novas cópias de bifurcação do interpretador Ruby. Fazendo isto é dependem do
sistema operacional. Para mais informações, use <code>ri</code> para procurar os métodos <code>Kernel.system</code>, <code>Kernel.exec</code>, <code>Kernel.fork</code>,
<code>IO.popen</code>, e o módulo <code>Process</code>.</p>

<h3>Lifecycle Tópico</h3>

<p>Como descrito acima, novas <code>threads</code> são criados com <code>Thread.new</code>. Você também pode usar os sinónimos <code>Thread.start</code> e
<code>Thread.fork</code>. Não há necessidade de se iniciar uma <code>thread</code> depois de criá-la, ele começa a ser executado automaticamente
quando os recursos da CPU estejam disponíveis. O valor da invocação <code>Thread.new</code> é um objeto <code>Thread</code>. A classe <code>Thread</code>
define um número de métodos para consultar e manipular a <code>thread</code> enquanto ela está sendo executada.</p>

<p>Uma <code>thread</code> é executa o código do bloco associado à chamada para <code>Thread.new</code> e depois pára execução. O valor da última
expressão em que o bloco é o valor da <code>thread</code>, e pode ser obtido chamando o método do valor do objeto <code>Thread</code>. Se a <code>thread</code>
foi executado para conclusão, então o valor retorna o valor da <code>thread</code> de imediato. Caso contrário, os blocos de valor do
método e não retorna até que a <code>threado</code> for concluída.</p>

<p>O método de classe <code>Thread.current</code> retorna o objeto <code>Thread</code> que representa o atual <code>thread</code>. Isso permite que as <code>threads</code>
manipulam-se. O método da classe <code>Thread.main</code> retorna o objeto <code>Thread</code> que representa a principal <code>thread</code>, este é a
<code>thread</code> inicial de execução que começou quando o Programa Ruby foi iniciado.</p>

<h4>A Thread principal</h4>

<p>A <code>Thread</code> principal é especial: o interpretador Ruby pára de correr quando a <code>thread</code> principal é feita. Ele faz isso mesmo
que a <code>thread</code> principal criou outras <code>threads</code> que ainda estão em execução. Você deve garantir, portanto, que a sua princial
<code>thread</code> não termina enquanto outras <code>threads</code> ainda estão em execução. Uma maneira de fazer isso é escrever sua <code>thread</code>
principal sob a forma de um <code>loop</code> infinito. Outra maneira é explicitamente esperar para as <code>threads</code> ser concluída. Já
mencionamos que você pode chamar o método <code>value</code> de uma <code>thread</code> que espera que ela termine. Se você não se importa com o
valor de suas <code>threads</code>, você pode esperar com o método de instancia <code>join</code>.</p>

<p>O seguinte método espera até que todas as linhas, com excepção da <code>thread</code> principal e a <code>thread</code> atual (que pode ser a mesma
coisa), ter saído:</p>

<figure class='code'><figcaption><span>Thread Principal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">join_all</span>
</span><span class='line'>  <span class="n">main</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">main</span>        <span class="c1"># Thread Principal</span>
</span><span class='line'>  <span class="n">current</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">current</span>  <span class="c1"># Thread atual</span>
</span><span class='line'>  <span class="n">all</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">list</span>         <span class="c1"># Todas as threads ainda em execução</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Agora chama join em cada thread</span>
</span><span class='line'>  <span class="n">all</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">join</span> <span class="k">unless</span> <span class="n">t</span> <span class="o">==</span> <span class="n">current</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">==</span> <span class="n">main</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Threads e exceções não tratadas</h4>

<p>Se uma exceção é levantada na <code>thread</code> principal, e não é tratada em qualquer lugar, o interpretador Ruby imprime uma
mensagem e sai. Em outras <code>threads</code> que a <code>thread</code> principal, exceções não tratadas causam a <code>thread</code> para parar de executar.
Por defeito, no entanto, isto não faz o intérprete para imprimir uma mensagem ou saída. Se uma <code>thread</code> <code>t</code> sai por causa de
uma exceção não tratada, e outra <code>thread</code> de chamadas <code>t.join</code> ou <code>t.value</code>, então a exceção que ocorreu em <code>t</code> é levantada
na <code>thread</code> de <code>s</code>.</p>

<p>Se você gostaria de qualquer exceção não tratada em qualquer <code>thread</code> para fazer com que o intérprete saia, use o método de
classe <code>Thread.abort_on_exception=</code>:</p>

<figure class='code'><figcaption><span>Thread</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Thread</span><span class="o">.</span><span class="n">abort_on_exception</span> <span class="o">=</span> <span class="kp">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se você quer uma exceção não tratada em uma <code>thread</code> específica faz com que o intérprete saia, utilizando o método de
exemplo, através do mesmo nome:</p>

<figure class='code'><figcaption><span>Thread abort</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="n">abort_on_exception</span> <span class="o">=</span> <span class="kp">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos.. até a proxima!</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Encadeamento de Alias - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/09/18/encadeamento-de-alias-number-ruby-1-dot-9/"/>
    
    <updated>2012-09-18T08:38:00-03:00</updated>
    <id>http://rrmartins.com/blog/2012/09/18/encadeamento-de-alias-number-ruby-1-dot-9</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Encadeamento de Alias</b>...</p>




<h1>Encadeamento de Alias</h1>


<p>Como já visto, metaprogramação em Ruby muitas vezes envolve a dinâmica definição de métodos. Assim como comum é a dinâmica modificação de métodos.
Métodos são modificados com uma técnica que chamaremos de encadeamento de alias. Ele funciona assim:</p>

<pre><code>* Primeiro, criar um alias para o método a ser modificado. este apelido fornece um nome para
a versão não modificada do método.

* Em seguida, definem uma nova versão do método. Esta nova versão deve chamar a versão não modificada
através dos alias, mas pode adicionar qualquer funcionalidade que for necessário, antes e depois de que
faz isso.
</code></pre>

<p>Note-se que estes passos podem ser aplicados repetidamente (desde que um alias diferente é usado de cada vez), criando uma cadeia de métodos e aliases.</p>

<p>Este post inclui três exemplos de encadeamento de alias. O primeiro realiza o encadeamento de apelido estaticamente, ou seja, usando pseudônimo
regulares e declarações <code>def</code>. Os segundo e terceiro exemplos são mais dinâmicos; eles são apelidos que acorrentam métodos arbitrariamente nomeados
utilizando <code>alias_method</code>, <code>define_method</code> e <code>class_eval</code>.</p>

<h3>Rastreando Arquivos Carregados e Classes Definidas</h3>


<p>O <code>Exemplo 1-1</code> é um código que mantém o controle de todos os ficheiros carregados e todas as classes definidas num programa. Quando o programa sai,
ele imprime um relatório. Você pode usar este código para &ldquo;instrumento&rdquo; de um existente programa para que você entenda melhor o que está fazendo. Uma
maneira de usar este código é inserir esta linha no começo do programa:</p>

<figure class='code'><figcaption><span>classtrace</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;classtrace&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Uma solução mais fácil, no entanto, é usar a opção -r para o seu intérprete Ruby(<code>irb</code>):</p>

<figure class='code'><figcaption><span>Opção -r</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">ruby</span> <span class="o">-</span><span class="n">rclasstrace</span> <span class="n">my_program</span><span class="o">.</span><span class="n">rb</span>  <span class="o">--</span><span class="n">traceout</span> <span class="sr">/tmp/</span><span class="n">trace</span>
</span></code></pre></td></tr></table></div></figure>


<p>A opção -r carrega a biblioteca especificado antes de começar a executar o programa.</p>

<p>O <code>Exemplo 1-1</code> usa apelido de encadeamento estático para rastrear todas as chamadas dos métodos <code>Kernel.require</code> e <code>Kernel.load</code>. Ele define um hook
<code>Object.inherited</code> para rastrear as definições de novas classes. E ele usa <code>Kernel.at_exit</code> para executar um bloco de código quando o programa termina.
Além dos encadeamentos de alias <code>require</code> e <code>load</code> e defini <code>Object.inherited</code>, a única modificação do espaço global feita por este código é a
definição de um módulo chamado <code>ClassTrace</code>. Todo o estado necessário para o rastreio é armazenado em constantes dentro deste módulo, de modo que não
poluem o <code>namespace</code> com variáveis globais.</p>

<figure class='code'><figcaption><span>Exemplo 1-1. Rastreando Arquivos Carregados e Classes Definidas</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Definimos este módulo para manter o estado global do require, de modo que</span>
</span><span class='line'><span class="c1"># Nós não alteramos o espaço global mais do que o necessário.</span>
</span><span class='line'><span class="k">module</span> <span class="nn">ClassTrace</span>
</span><span class='line'><span class="err">  </span> <span class="c1"># Esta matriz mantém a nossa lista de arquivos carregados e classes definidas.</span>
</span><span class='line'><span class="err">  </span> <span class="c1"># Cada elemento é um subarray segurando a classe definida ou o</span>
</span><span class='line'><span class="err">  </span> <span class="c1"># Arquivo carregado e o quadro de pilha onde ele foi definido ou carregado.</span>
</span><span class='line'><span class="err">  </span> <span class="n">T</span> <span class="o">=</span> <span class="o">[]</span>  <span class="c1"># Array para armazenar os arquivos carregados</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span> <span class="c1"># Agora defini a constante OUT para especificar onde saída do rastreamento vai.</span>
</span><span class='line'><span class="err">  </span> <span class="c1"># O padrão é stderr, mas também pode vir a partir de argumentos na linha de comando</span>
</span><span class='line'><span class="err">  </span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;--traceout&quot;</span><span class="p">)</span>    <span class="c1"># Se existe argumento</span>
</span><span class='line'><span class="err">    </span> <span class="no">OUT</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>  <span class="c1"># Abre o arquivo especificado</span>
</span><span class='line'><span class="err">    </span> <span class="no">ARGV</span><span class="o">[</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="kp">nil</span>                  <span class="c1"># E remova os argumentos</span>
</span><span class='line'><span class="err">  </span> <span class="k">else</span>
</span><span class='line'><span class="err">    </span> <span class="no">OUT</span> <span class="o">=</span> <span class="no">STDERR</span>                     <span class="c1"># Caso contrário, o padrão para STDERR</span>
</span><span class='line'><span class="err">  </span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Passo 1 encadeamento Alias: definir aliases para os métodos originais</span>
</span><span class='line'><span class="k">alias</span> <span class="n">original_require</span> <span class="nb">require</span>
</span><span class='line'><span class="k">alias</span> <span class="n">original_load</span> <span class="nb">load</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Passo 2 encadeamento Alias 2: definir novas versões dos métodos</span>
</span><span class='line'><span class="k">def</span> <span class="nf">require</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">file</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>     <span class="c1"># Lembre-se de onde que estava carregado</span>
</span><span class='line'><span class="err">  </span><span class="n">original_require</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>                <span class="c1"># Chame o método original</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="err"> </span> <span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>  <span class="c1"># Lembre-se de onde que estava carregado</span>
</span><span class='line'><span class="err"> </span> <span class="n">original_load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>                  <span class="c1"># Chame o método original</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Este método hook é chamado de cada vez que uma nova classe é definida</span>
</span><span class='line'><span class="k">def</span> <span class="nc">Object</span><span class="o">.</span><span class="nf">inherited</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">c</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>        <span class="c1"># Lembre-se onde que foi definido</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Kernel.at_exit registra um bloco a ser executado quando o programa sai</span>
</span><span class='line'><span class="c1"># Vamos utilizá-lo para comunicar os dados de arquivo e de classe que recolhemos</span>
</span><span class='line'><span class="nb">at_exit</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">o</span> <span class="o">=</span> <span class="no">ClassTrace</span><span class="o">::</span><span class="no">OUT</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">60</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Files Loaded and Classes Defined:&quot;</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">60</span>
</span><span class='line'>  <span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">what</span><span class="p">,</span><span class="n">where</span><span class="o">|</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">what</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Class</span>  <span class="c1"># Report class (with hierarchy) defined</span>
</span><span class='line'>      <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Defined: </span><span class="si">#{</span><span class="n">what</span><span class="o">.</span><span class="n">ancestors</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;&lt;-&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="n">where</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">else</span>                 <span class="c1"># Report file loaded</span>
</span><span class='line'>      <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Loaded: </span><span class="si">#{</span><span class="n">what</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="n">where</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Métodos encadeamento de segurança da Thread</h3>


<p>O alias de encadeamento é feito pelo método <code>Module.synchronize_method</code>, o qual, por sua vez usa um método auxiliar <code>Module.create_alias</code> para definir
um alias adequado para qualquer método dado (incluindo métodos como o operador +).</p>

<p>Depois de definir estes novo métodos <code>Module</code>, Exemplo 1-2 redefine o método <code>synchronized</code> novamente. Quando o método é invocado dentro de uma classe
ou de um módulo, ele chama <code>synchronize_method</code> em cada um dos símbolos que é passado. Curiosamente, contudo, pode também ser chamado sem argumentos,
quando utilizado desta forma, acrescenta sincronização para qualquer método de instância é definido a seguir. (Utiliza o <code>hook</code> para receber
notificação quando um novo método <code>method_added</code> é adicionado.) Note que o código deste exemplo depende do método <code>Object.mutex</code> e a classe
<code>SynchronizedObject</code>.</p>

<figure class='code'><figcaption><span>Exemplo 1-2. Alias de encadeamento de segurança da Thread</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">2</span> <span class="c1"># Um literal numérico</span>
</span><span class='line'><span class="n">x</span> <span class="c1"># Uma referência variável local</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># invocação Um método</span>
</span><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Atribuição</span>
</span><span class='line'><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="c1"># Multiplicação com o operador *</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como você pode ver, expressões primárias, tal como literais, referências variáveis, e invocações de método podem ser combinadas em
expressões maiores com operadores, tais como o operador de atribuição e o operador de multiplicação.</p>

<p>Muitas linguagens de programação diferenciam entre expressões de baixo nível e alto nível de declarações, tais como condicionais e loops.
Nestas linguagens, as declarações de controlar o fluxo de um programa, mas eles não têm valores. Eles são executados, em vez de avaliados.
Em Ruby, não há distinção clara entre as afirmações e expressões; tudo em Ruby, incluindo a definição de classe e de método, pode ser
avaliado como uma expressão e retorna um valor. É ainda útil, no entanto, diferenciam sintaxe normalmente usada como expressões de sintaxe
tipicamente usadas ​​como indicações.</p>

<p>Até mais amigos.. ainda vem muito conteudo legal com por ai.. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arranhando sua própria coceira]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/22/arranhando-sua-propria-coceira/"/>
    <updated>2012-05-22T13:21:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/22/arranhando-sua-propria-coceira</id>
    <content type="html"><![CDATA[<p>Como um apaixonado por codigo aberto, estou lendo o livro <a href="http://gettingreal.37signals.com/GR_por.php">&#8220;Caindo na Real&#8221;</a>, e me deparei com uma parte do livro The Progmatic Programmers, o proximo que irei ler.</p>

<p>Então, vejam ai uma parte muito boa, só para dar um gostinho! :D</p>

<h2>Arranhando sua proípria coceira</h2>


<p>O mundo de Código Aberto abraçou esse mantra há muito tempo – eles chamam de “arranhando sua própria coceira”. Para os desenvolvedores de código aberto, significa que terão as ferramentas que querem, entregues da maneira que querem. Mas os benefícios vão mais a fundo.</p>

<p>Como designer ou desenvolvedor de uma nova aplicação, você precisa encarar centenas de micro-decisões todos os dias: azul ou verde? Uma tabela ou duas? Estática ou dinâmica? Abortar ou recuperar? Como tomamos essas decisões? Se é algo que reconhecemos como importante, poderíamos perguntar. O resto, chutamos. E todos esses chutes constroem um tipo de débito em nossas aplicações – uma rede interconectada de coisas que assumimos.</p>

<p>Como um desenvolvedor, detesto isso. O conhecimento de todas essas bombasrelógio em pequena escala nas aplicações que escrevo somam-se ao meu stress. Desenvolvedores de código aberto, arranhando suas próprias coceiras, não sofrem isso. Porque eles são seus próprios usuários, eles sabem a resposta correta para 90% das decisões que precisam tomar. Acho que é uma das razões que as pessoas chegam em casa após um dia duro de trabalho de codificação e ainda trabalham com código aberto: é relaxante.</p>

<pre><code>— Dave Thomas, The Pragmatic Programmers
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part VI]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-vi/"/>
    <updated>2012-05-20T19:08:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-vi</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Copiando objetos</h3>


<p>A classe Object define dois métodos estreitamente relacionados para copiar objetos. Tanto o clone e como o dup retornar uma cópia
superficial do objeto em que eles são chamados. Se o objeto copiado inclui o estado interno que se refere a outros objetos, apenas as
referências a objetos são copiadas, não os próprios objetos referenciados.</p>

<p>Se o objecto a ser copiado define um método initialize_copy, em seguida, clone e dup simplesmente alocam uma nova instância vazia da
classe e chamam o método initialize_copy nesta instância vazio. O objeto a ser copiado é passado como um argumento, para este &#8220;Construtor
de cópias&#8221;, podendo inicializar a cópia. Para exemplo, o método initialize_copy pode copiar recursivamente os dados internos de um objeto
para que o objeto resultante, não sendo uma simples cópia superficial do original.</p>

<p>Classes também podem substituir os métodos clone e dup diretamente para produzir qualquer tipo de copia que eles desejam.</p>

<p>Há duas diferenças importantes entre os métodos clone e dup definidos pelo objeto. Primeiro, as cópias do clone tanto o congelado e
quanto o estado contaminado(definido em breve) de um objeto, enquanto dup apenas copia o estado contaminado, chamando dup sobre um objeto
congelado retorna uma cópia descongelada. Em segundo lugar, clone cópia quaisquer métodos singleton do objeto, enquanto que dup não.</p>

<h3>Objetos Empacotamento</h3>


<p>Você pode salvar o estado de um objeto passando para a classe <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html">Marshal</a>, com o método <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-dump">dump</a>. Se você passar um objeto de fluxo de I/O como o segundo argumento, escreve o estado do objeto Marshal.dump (e, de forma recursiva, quaisquer objetos que referencia) para esse fluxo.
Caso contrário, ele simplesmente retorna o estado codificado como uma string binária.</p>

<p>Para restaurar um objeto empacotado, passe uma string ou um fluxo de contendo I/O do objeto de <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-load">Marshal.load</a>.</p>

<p>O empacotamento de um objeto é uma maneira muito simples para salvar seu estado para uma utilização posterior, e estes métodos podem ser
usados ​​para fornecer um arquivo automático no formato de programas Ruby. Note, no entanto, que o formato binário usado por <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-dump">Marshal.dump</a> e <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-load">Marshal.load</a> é dependente da versão, e nas mais recentes versões do Ruby não são garantidos para ser capaz de ler
objetos empacotados escritos por versões mais antigas do Ruby.</p>

<p>Outro uso para Marshal.dump e Marshal.load é criar cópias de profundidade de objetos:</p>

<figure class='code'><figcaption><span>Marshal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="no">Marshal</span><span class="o">.</span><span class="n">load</span> <span class="p">(</span><span class="no">Marshal</span><span class="o">.</span><span class="n">dump</span> <span class="p">(</span><span class="n">o</span><span class="p">))</span>
=======
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Define um alias corrente Module.synchronize_method de métodos de instância</span>
</span><span class='line'><span class="c1"># Assim que sincronizar a instância antes da execução.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Module</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Esta é uma função auxiliar para o encadeamento alias.</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Dado o nome de um método (como uma string ou símbolo) e um prefixo, cria</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Um alias exclusivo para o método, e retornar o nome do alias</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Como um símbolo. Quaisquer caracteres de pontuação em nome método original</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Serão convertidos em números para que os operadores podem ser alias.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">create_alias</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;alias&quot;</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Cole o prefixo do nome original e converter pontuação</span>
</span><span class='line'><span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">#{</span><span class="n">original</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="n">aka</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span><span class="sr">/([\=\|\&amp;\+\-\*\/\^\!\?\~\%\&lt;\&gt;\[\]])/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">num</span> <span class="o">=</span> <span class="vg">$1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>                       <span class="c1"># Ruby 1.8 character -&gt; ordinal</span>
</span><span class='line'>      <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">ord</span> <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">is_a?</span> <span class="nb">String</span> <span class="c1"># Ruby 1.9 character -&gt; ordinal</span>
</span><span class='line'>      <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">num</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="err">    </span>
</span><span class='line'><span class="err">    </span><span class="c1"># Mantenha acrescentando ressalta até chegarmos a um nome que não está em uso</span>
</span><span class='line'><span class="err">    </span><span class="n">aka</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="k">while</span> <span class="nb">method_defined?</span> <span class="n">aka</span> <span class="ow">or</span> <span class="nb">private_method_defined?</span> <span class="n">aka</span>
</span><span class='line'>
</span><span class='line'><span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="n">aka</span><span class="o">.</span><span class="n">to_sym</span>           <span class="c1"># Converter o nome de alias de um símbolo</span>
</span><span class='line'><span class="err">    </span><span class="n">alias_method</span> <span class="n">aka</span><span class="p">,</span> <span class="n">original</span> <span class="c1"># Na verdade criar o alias</span>
</span><span class='line'><span class="err">    </span><span class="n">aka</span>                                            <span class="c1"># Retorna o nome do alias</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Alias correntam o método nomeado para adicionar sincronização</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">synchronize_method</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Primeiro, fazemos um alias para a versão dessincronizado do método.</span>
</span><span class='line'><span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="n">create_alias</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;unsync&quot;</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Agora redefini o original para invocar o alias em um bloco sincronizado.</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Queremos o método definido como sendo capaz de aceitar os blocos, de modo que</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Não pode usar define_method, e deve avaliar vez uma string com</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Class_eval. Note-se que tudo entre% Q {} e da correspondência</span>
</span><span class='line'><span class="err">    </span><span class="c1"># É uma string entre aspas, e não um bloco.</span>
</span><span class='line'><span class="err">    </span><span class="nb">class_eval</span> <span class="sx">%Q{</span>
</span><span class='line'><span class="sx">      def </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(*args, &amp;block)</span>
</span><span class='line'><span class="sx">        synchronized(self) { </span><span class="si">#{</span><span class="n">aka</span><span class="si">}</span><span class="sx">(*args, &amp;block) }</span>
</span><span class='line'><span class="sx">      end</span>
</span><span class='line'><span class="sx">    }</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Este método global sincronizado agora pode ser usado de três maneiras diferentes.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Caso 1: com um argumento e um bloco, sincronizar sobre o objeto</span>
</span><span class='line'><span class="err">  </span><span class="c1"># E executar o bloco</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Caso dois: com um argumento que não é um símbolo e nenhum bloco</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Devolve um invólucro de SynchronizedObject</span>
</span><span class='line'><span class="err">  </span><span class="k">elsif</span> <span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">is_a?</span> <span class="no">Symbol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="no">SynchronizedObject</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Caso três: quando invocado em um módulo com nenhum bloco, alias a cadeia</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Chamado métodos para adicionar sincronização. Ou, se não há argumentos,</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Então apelido acorrentam o próximo método definido.</span>
</span><span class='line'><span class="err">  </span><span class="k">elsif</span> <span class="nb">self</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Module</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Synchronize the named methods</span>
</span><span class='line'>      <span class="n">args</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="nb">self</span><span class="o">.</span><span class="n">synchronize_method</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Se nenhum método é especificado pelo synchronize o método seguinte define</span>
</span><span class='line'><span class="err">      </span><span class="n">eigenclass</span> <span class="o">=</span> <span class="n">class</span><span class="o">&lt;&lt;</span><span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>      <span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span> <span class="c1"># Use eigenclass para definir métodos de classe</span>
</span><span class='line'><span class="err">        </span><span class="c1"># Define method_added para notificação quando próximo método é definido</span>
</span><span class='line'><span class="err">        </span><span class="n">define_method</span> <span class="ss">:method_added</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'><span class="err">          </span><span class="c1"># Primeiro remover esse método hook</span>
</span><span class='line'><span class="err">          </span><span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">remove_method</span> <span class="ss">:method_added</span> <span class="p">}</span>
</span><span class='line'><span class="err">          </span><span class="c1"># Em seguida, sincronize o método que acabou de ser adicionado</span>
</span><span class='line'><span class="err">          </span><span class="nb">self</span><span class="o">.</span><span class="n">synchronize_method</span> <span class="nb">name</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Caso 4: qualquer outra invocação é um erro</span>
</span><span class='line'><span class="err">  </span><span class="k">else</span>
</span><span class='line'>    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;Invalid arguments to synchronize()&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Métodos de encadeamento para Rastreamento</h3>


<p>O Exemplo 1-3 suporta o rastreio de métodos denominados de um objeto. Ele define <code>trace!</code> e <code>untrace!</code> a cadeia e desencadeiam métodos chamados de um
objeto.</p>

<p>A coisa interessante sobre esse exemplo é que ele faz o seu encadeamento de um modo diferente a partir do Exemplo 1-2. Ele simplesmente define métodos
únicos no objeto e usa <code>super</code> dentro do <code>singleton</code> para a cadeia de definição do método original de exemplo. Nenhum método são criado aliases.</p>

<figure class='code'><figcaption><span>Exemplo 8-10. Encadeamento com métodos singleton para rastrear</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Define métodos trace! e untrace! de instância para todos os objetos.</span>
</span><span class='line'><span class="c1"># trace! &quot;Cadeias&quot; os métodos chamados por definir métodos singleton</span>
</span><span class='line'><span class="c1"># Que adiciona a funcionalidade de rastreamento e use super para chamar o original.</span>
</span><span class='line'><span class="c1"># untrace! exclui os métodos singleton para remover o rastreamento.</span>
</span><span class='line'><span class="n">classe</span> <span class="no">Object</span>
</span><span class='line'><span class="err">  </span><span class="c1"># os métodos trace especificados, enviando a saída para STDERR.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">trace!</span><span class="p">(</span><span class="o">*</span><span class="nb">methods</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@_traced</span> <span class="o">=</span> <span class="vi">@_traced</span> <span class="o">||</span> <span class="o">[]</span>    <span class="c1"># Lembre-se o conjunto de métodos traçados</span>
</span><span class='line'>
</span><span class='line'><span class="err">    </span><span class="c1"># Se nenhum método foi especificado, use todos os métodos públicos definidos</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Diretamente (não herdado) pela classe deste objeto</span>
</span><span class='line'><span class="err">    </span><span class="nb">methods</span> <span class="o">=</span> <span class="nb">public_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">methods</span><span class="o">.</span><span class="n">map!</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">to_sym</span> <span class="p">}</span>    <span class="c1"># Converta qualquer cordas para símbolos</span>
</span><span class='line'><span class="err">    </span><span class="nb">methods</span> <span class="o">-=</span> <span class="vi">@_traced</span>                   <span class="c1"># remove métodos que já estão traçadas</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">empty?</span>         <span class="c1"># Voltar mais cedo se não há nada a fazer</span>
</span><span class='line'><span class="err">    </span><span class="vi">@_traced</span> <span class="o">|=</span> <span class="nb">methods</span>           <span class="c1"># Adiciona métodos para definir métodos de traçados</span>
</span><span class='line'>
</span><span class='line'><span class="err">    </span><span class="c1"># Trace o fato de que estamos começando a traçar estes métodos</span>
</span><span class='line'><span class="err">    </span><span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Tracing </span><span class="si">#{</span><span class="nb">methods</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># Singleton métodos são definidos na eigenclass</span>
</span><span class='line'>    <span class="n">eigenclass</span> <span class="o">=</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="nb">methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="c1"># Para cada método m</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Define uma versão trace singleton do método m.</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Saída de informações de rastreamento e usar super para invocar o</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Método de instância que é o rastreamento.</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Queremos que os métodos definidos para ser capaz de aceitar blocos, de modo que</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Não pode usar define_method, e deve avaliar, em vez de uma string.</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Note que tudo entre %Q{} e a correspondência é uma</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Entre aspas de string, não um bloco. Observe também que há</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Dois níveis de interpolações de string aqui. # {} É interpolada</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Quando o método singleton é definida. E \ # {} é interpolada</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Quando o método singleton é invocado.</span>
</span><span class='line'><span class="err">      </span><span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="sx">%Q{</span>
</span><span class='line'><span class="sx">        def </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(*args, &amp;block)</span>
</span><span class='line'><span class="sx">          begin</span>
</span><span class='line'><span class="sx">            STDERR &lt;&lt; &quot;Entering: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(</span><span class="se">\#</span><span class="sx">{args.join(&#39;, &#39;)})</span><span class="se">\n</span><span class="sx">&quot;</span>
</span><span class='line'><span class="sx">            result = super</span>
</span><span class='line'><span class="sx">            STDERR &lt;&lt; &quot;Exiting: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx"> with </span><span class="se">\#</span><span class="sx">{result}</span><span class="se">\n</span><span class="sx">&quot;</span>
</span><span class='line'><span class="sx">            result</span>
</span><span class='line'><span class="sx">          rescue</span>
</span><span class='line'><span class="sx">            STDERR &lt;&lt; &quot;Aborting: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">: </span><span class="se">\#</span><span class="sx">{$!.class}: </span><span class="se">\#</span><span class="sx">{$!.message}&quot;</span>
</span><span class='line'><span class="sx">            raise</span>
</span><span class='line'><span class="sx">          end</span>
</span><span class='line'><span class="sx">        end</span>
</span><span class='line'><span class="sx">      }</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Untrace os métodos especificados ou todos os métodos rastreados</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">untrace!</span><span class="p">(</span><span class="o">*</span><span class="nb">methods</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>    <span class="c1"># Se nenhuma métodos especificados untrace</span>
</span><span class='line'>      <span class="nb">methods</span> <span class="o">=</span> <span class="vi">@_traced</span>    <span class="c1"># todos os métodos atualmente rastreados</span>
</span><span class='line'>      <span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Untracing all methods on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">else</span>                    <span class="c1"># Caso contrário, untrace</span>
</span><span class='line'>      <span class="nb">methods</span><span class="o">.</span><span class="n">map!</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">to_sym</span> <span class="p">}</span>  <span class="c1"># Converter string para símbolos</span>
</span><span class='line'>      <span class="nb">methods</span> <span class="o">&amp;=</span> <span class="vi">@_traced</span>   <span class="c1"># todos os métodos especificados que são rastreados</span>
</span><span class='line'>      <span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Untracing </span><span class="si">#{</span><span class="nb">methods</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="vi">@_traced</span> <span class="o">-=</span> <span class="nb">methods</span>     <span class="c1"># Retire-os do nosso conjunto de métodos de traçados</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># Remove os métodos traçados únicos do eigenclass</span>
</span><span class='line'>      <span class="c1"># Note que nós class_eval um bloco aqui, não uma string</span>
</span><span class='line'>      <span class="p">(</span><span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span><span class="p">)</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
</span><span class='line'>        <span class="nb">methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'>          <span class="n">remove_method</span> <span class="n">m</span>     <span class="c1"># undef_method não funciona corretamente</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># Se nenhum método são traçados mais, remover o nosso exemplo var</span>
</span><span class='line'>      <span class="k">if</span> <span class="vi">@_traced</span><span class="o">.</span><span class="n">empty?</span>
</span><span class='line'>        <span class="n">remove_instance_variable</span> <span class="ss">:@_traced</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai galera! Até a proxima!</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Criando Métodos Dinamicamente - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/09/15/criando-metodos-dinamicamente-number-ruby-1-dot-9/"/>
    
    <updated>2012-09-15T20:38:00-03:00</updated>
    <id>http://rrmartins.com/blog/2012/09/15/criando-metodos-dinamicamente-number-ruby-1-dot-9</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Criando Métodos Dinamicamente</b>... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Criando Métodos Dinamicamente</h1>


<p>Uma técnica importante em metaprogramação é a utilização de métodos que criam métodos. Os métodos <code>attr_reader</code> e <code>attr_accessor</code> são exemplos. Estes
métodos de instância privados do <code>Module</code> são usados como palavras-chave dentro de definições de classe. Eles aceitam nomes de atributos como seus
argumentos, e dinamicamente criam métodos com esses nomes. Os exemplos que se seguem são variantes sobre essa criação de atributos assessores dos
métodos e demonstra duas formas diferentes de criar dinamicamente métodos como este.</p>

<h3>Métodos definidos com class_eval</h3>


<p>O Exemplo 1-1 define métodos privados de instância do <code>Module</code> chamado <code>readonly</code> e <code>readwrite</code>. Estes métodos funcionam como <code>attr_reader</code>
e <code>attr_accessor</code>, e eles estão aqui para demonstrar como esses métodos são implementados. A implementação é na verdade muito simples: <code>readonly</code> e
<code>readwrite</code> primeiro construi uma seqüência de código Ruby contendo as instruções necessárias para definir <code>def</code> os métodos de acesso apropriados.
Em seguida, eles avaliam que a seqüência de código usando <code>class_eval</code>. Usando <code>class_eval</code> como esta gera a sobrecarga de analisar a cadeia de código.
A vantagem, contudo, é que os métodos que definem não precisa usar as APIs reflexivas, pois eles podem consultar ou definir o valor de uma variável de
instância diretamente.</p>

<figure class='code'><figcaption><span>Exemplo 1-1. Métodos de atributos com class_eval</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Module</span>
</span><span class='line'><span class="err">  </span><span class="kp">private</span> <span class="c1"># Os métodos que se seguem são todos privados</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Este método funciona como attr_reader, mas tem um nome mais curto</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">readonly</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># Se nenhum argumento, não faz nada</span>
</span><span class='line'><span class="err">    </span><span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>                 <span class="c1"># Comece com uma cadeia vazia de código</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Gera uma seqüência de código Ruby para definir métodos leitores de atributos.</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Observe como o símbolo é interpolado para a seqüência de código.</span>
</span><span class='line'><span class="err">    </span><span class="n">syms</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>                     <span class="c1"># Para cada símbolo</span>
</span><span class='line'><span class="err">      </span><span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;def </span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">; @</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">; end</span><span class="se">\n</span><span class="s2">&quot;</span>   <span class="c1"># O método de definição</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Finalmente, class_eval o código gerado para criar métodos de instância.</span>
</span><span class='line'><span class="err">    </span><span class="nb">class_eval</span> <span class="n">code</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Este método funciona como attr_accessor, mas tem um nome mais curto.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">readwrite</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'><span class="err">    </span><span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'><span class="err">    </span><span class="n">syms</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>
</span><span class='line'>      <span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;def </span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">; @</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2"> end</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>      <span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;def </span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">=(value); @</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2"> = value; end</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="nb">class_eval</span> <span class="n">code</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Métodos definidos com define_method</h3>


<p>O Exemplo 1-2 é uma posição diferente sobre os assessores de atributos. O método <code>attributes</code> é algo como o método <code>readwrite</code> definido no <code>Exemplo
1-1</code>. Em vez de tomar qualquer número de nomes de atributos como argumentos, que espera um único objeto <code>hash</code>. Este <code>hash</code> deve ter nomes de atributos
como suas chaves, e deve mapear os nomes de atributos para os valores padrões para os atributos. O método <code>class_attrs</code> funciona como atributos, mas
define os atributos de classe em vez de atributos de instância.</p>

<p>Lembre-se que Ruby permite que as chaves para ser omitidas em torno de <code>hash</code> literais quando eles são o argumento final em uma invocação de método.
Assim, o método <code>attributes</code> pode ser chamado com um código como este:</p>

<figure class='code'><figcaption><span>Metodo attributes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Point</span>
</span><span class='line'>  <span class="n">attributes</span> <span class="ss">:x</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="ss">:y</span> <span class="o">=&gt;</span> <span class="mi">0</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<<<<<<< HEAD
<p>Note que os arquivos de fluxo I/O, bem como o método e os objetos Binding, são dinâmicos demais para ser empacotado, não haveria nenhuma
maneira confiável para restaurar seu Estado.</p>

<p>YAML (&#8220;YAML não é Markup Language&#8221;) é uma alternativa comumente utilizada para o módulo Marshal que depósita objetos (e carrega objetos) a
partir de um texto com formato legível. É na biblioteca padrão, e você deve exigir usá-lo &#8216;yaml&#8217;.</p>

<h3>Objetos de congelamento</h3>


<p>Qualquer objeto pode ser congelado chamando seu método de freeze. A objeto congelado torna imutável e nenhum de seu estado interno pode
ser mudado, e uma tentativa de chamar qualquer um dos seus métodos de falha de modificadores:</p>

<figure class='code'><figcaption><span>Freeze</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;gelo&quot;</span> <span class="c1"># String são objetos mutáveis</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">freeze</span> <span class="c1"># Faça desta cadeia imutável</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">frozen?</span> <span class="c1"># Verdade: ele foi congelado</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">upcase!</span> <span class="c1"># TypeError: não pode modificar cadeia de congelados</span>
</span><span class='line'><span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;ni&quot;</span> <span class="c1"># TypeError: não pode modificar cadeia de congelados</span>
</span></code></pre></td></tr></table></div></figure>


<p>Congelar um objeto de classe impede a adição de quaisquer métodos para essa classe.</p>

<p>Você pode verificar se um objeto é congelado com o método frozen?. Uma vez congelado, não há maneira para &#8220;descongelar&#8221; um objeto. Se
você copiar um objeto congelado com clone, a cópia também será congelada. Se você copiar um objeto congelado com dup, no entanto, a
cópia não será congelada.</p>

<h3>Objetos contaminados e não confiáveis</h3>


<p>Aplicações Web deve muitas vezes acompanhar de dados de entrada, derivados de não confiáveis do usuário para evitar ataques de injeção
de SQL e riscos de segurança semelhantes. Ruby oferece uma solução simples para esse problema: qualquer objeto pode ser marcado como
contaminado, chamando seu método taint. Depois que um objeto está contaminado, qualquer objetos derivado, também será contaminado. O
taint de um objeto pode ser testado com o método tainted? método:</p>

<figure class='code'><figcaption><span>taint</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<p>No Ruby 1.9, podemos usar a sintaxe do <code>hash</code> é mais sucinta:</p>

<figure class='code'><figcaption><span>Attibutes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Point</span>
</span><span class='line'>  <span class="n">attributes</span> <span class="n">x</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">0</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Este é outro exemplo que utiliza sintaxe flexível de Ruby para criar métodos que se comportam como palavras-chave de linguagem.</p>

<p>A implementação do método de <code>attributes</code> no <code>Exemplo 1-2</code> é um pouco diferente do que a do método <code>readwrite</code> no <code>Exemplo 1-1</code>. Em vez de definir uma
seqüência de código Ruby e avaliá-lo com <code>class_eval</code>, o método <code>attributes</code> define o corpo dos acessos de atributos de um bloco e define os métodos
que utilizam <code>define_method</code>. Uma vez que este método técnico de definição não nos permitem identificadores interpolares diretamente no corpo do
método, temos de confiar em métodos reflexivos, como <code>instance_variable_get</code>. Devido a isso, os assessores definidos com <code>attributes</code> são susceptíveis
de ser menos eficientes do que os definidos com <code>readwrite</code>.</p>

<p>Um ponto interessante sobre o método <code>attributes</code> é que não armazena explicitamente os valores padrões para os atributos em uma variável de classe de
qualquer tipo. Em vez disso, o valor por defeito para cada atributo é capturado pelo âmbito de bloquear o método usado para definir.</p>

<p>O método <code>class_attrs</code> define os atributos de classe muito simples: ele invoca <code>attributes</code> na <a href="http://blog.caelum.com.br/metaprogramacao-eigenclass-em-ruby/">eigenclass</a> da classe. Este
significa que os métodos resultantes usam variáveis de instância de classe em vez de variáveis de classe regular.</p>

<figure class='code'><figcaption><span>Exemplo 1-2. Métodos de atributos com define_method</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;não confiáveis&quot;</span> <span class="c1"># Os objetos são normalmente não viciada</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">taint</span> <span class="c1"># Marcar como não confiável objeto contaminado</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">tainted?</span> <span class="c1"># Verdade: ele está contaminado</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">upcase</span><span class="o">.</span><span class="n">tainted?</span> <span class="c1"># Verdade: objetos derivados estão contaminados</span>
</span><span class='line'><span class="n">s</span><span class="o">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">].</span><span class="n">tainted?</span> <span class="c1"># Verdade: substrings estão contaminados</span>
</span></code></pre></td></tr></table></div></figure>


<p>De entrada, tais como usuário de linha de comando argumentos, ambiente de variáveis, e seqüências de leitura com gets, são automaticamente
contaminados. Quando a variavel global $SAFE é definida com um valor maior que zero, Ruby restringe vários métodos embutidos que eles não
vão trabalhar com dados adulterados. Cópias de objetos contaminados feitos com clone e dup permanecem contaminados. Um objeto contaminado
pode ser descontaminado com o método untaint. Você só deve fazer isso, claro, se você examinar o objeto e está convencido de que não apresenta riscos de segurança.</p>

<p>Em Ruby 1.9, os objectos podem não ser confiável para além de ser manchado. Os métodos untrusted?, untrust, e trust verificam e definem a
lealdade de um objeto. Código não confiável cria objetos não confiáveis, objetos contaminados e não é permitido para modificar objetos
confiáveis.</p>

<p>Boa noite amigos&#8230; até a proxima..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part V]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-v/"/>
    <updated>2012-05-20T14:04:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-v</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>
=======
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Module</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Este método define os atributos de métodos de reader e writer de nomeado</span>
</span><span class='line'><span class="err">  </span><span class="c1"># attributes, mas aguarda um argumento de attributes de nomes em hash mapeado para</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Valores padrões. Os métodos de reader gerados atributos retorna o</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Valor padrão se a variável de instância ainda não foi definido.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="nb">hash</span><span class="o">.</span><span class="n">each_pair</span> <span class="k">do</span> <span class="o">|</span><span class="n">symbol</span><span class="p">,</span> <span class="n">default</span><span class="o">|</span>   <span class="c1"># Para cada par de atributo/default</span>
</span><span class='line'><span class="err">      </span><span class="n">getter</span> <span class="o">=</span> <span class="n">symbol</span>                     <span class="c1"># Nome do método getter</span>
</span><span class='line'><span class="err">      </span><span class="n">setter</span> <span class="o">=</span> <span class="ss">:&quot;</span><span class="si">#{</span><span class="n">symbol</span><span class="si">}</span><span class="ss">=&quot;</span>              <span class="c1"># nome do método setter</span>
</span><span class='line'><span class="err">      </span><span class="n">variable</span> <span class="o">=</span> <span class="ss">:&quot;@</span><span class="si">#{</span><span class="n">symbol</span><span class="si">}</span><span class="ss">&quot;</span>            <span class="c1"># nome da variável de instância</span>
</span><span class='line'><span class="err">      </span><span class="n">define_method</span> <span class="n">getter</span> <span class="k">do</span>             <span class="c1"># Definir o método getter</span>
</span><span class='line'><span class="err">        </span><span class="k">if</span> <span class="n">instance_variable_defined?</span> <span class="n">variable</span>
</span><span class='line'><span class="err">          </span><span class="nb">instance_variable_get</span> <span class="n">variable</span>  <span class="c1"># Retorna variável, se definido</span>
</span><span class='line'><span class="err">        </span><span class="k">else</span>
</span><span class='line'><span class="err">          </span><span class="n">default</span>                         <span class="c1"># Caso contrário retornar padrão</span>
</span><span class='line'><span class="err">        </span><span class="k">end</span>
</span><span class='line'><span class="err">      </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">      </span><span class="n">define_method</span> <span class="n">setter</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>     <span class="c1"># Defini método setter</span>
</span><span class='line'><span class="err">        </span><span class="nb">instance_variable_set</span> <span class="n">variable</span><span class="p">,</span>   <span class="c1"># Defina a variável de instância</span>
</span><span class='line'><span class="err">                              </span><span class="n">value</span>       <span class="c1"># Para o valor do argumento</span>
</span><span class='line'><span class="err">      </span><span class="k">end</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Este método funciona como atributos, mas define métodos de classe em vez de</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Invocar atributos no eigenclass em vez de em si mesmo.</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Note que os métodos definidos usam variáveis de instância de classe</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Em vez de variáveis de classe regulares.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">class_attrs</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="n">eigenclass</span> <span class="o">=</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>    <span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">attributes</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Ambos os métodos são privados</span>
</span><span class='line'>  <span class="kp">private</span> <span class="ss">:attributes</span><span class="p">,</span> <span class="ss">:class_attrs</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos, até o proximo post!</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Missing Methods e Missing Constants - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/09/15/missing-methods-e-missing-constants-number-ruby-1-dot-9/"/>
    
    <updated>2012-09-15T12:46:00-03:00</updated>
    <id>http://rrmartins.com/blog/2012/09/15/missing-methods-e-missing-constants-number-ruby-1-dot-9</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Missing Methods e Missing Constants</b>... Estranho para alguns, mas, veremos que é simples!</p>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017




<<<<<<< HEAD
<h3>Conversão de objetos</h3>


<p></p>

<p>Muitas classes de Ruby definem métodos que retornam uma representação do objeto como um valor de uma classe diferente.
O método to_s, para a obtenção de uma representação de um objeto, é provavelmente o mais comumente implementado e mais conhecido
dos métodos. As subseções a seguir descrevem várias categorias de conversões.</p>

<!--more-->


<h5>Conversões explícitas</h5>


<p>As classes definem métodos de conversão explícitos para uso da aplicação de código que precisa de converter um valor para uma
outra representação. Os métodos mais comuns nesta categoria são to_s, to_i, to_f e to_a para converter a String, Integer, Float,
e array, respectivamente. Ruby 1.9 adiciona métodos to_c e to_r que se converterem ao <a href="http://ruby-doc.org/stdlib-1.9.2/libdoc/syck/rdoc/Complex.html">Complex</a> e <a href="http://ruby-doc.org/stdlib-1.9.2/libdoc/bigdecimal/rdoc/Rational.html">Rational</a>.</p>

<p>Métodos built-in normalmente não chamam esses métodos para você. Se você chamar um método que espera uma String e passar um objeto
de algum outro tipo, que o método não é esperado para converter o argumento com to_s. (Valores interpolados em aspas dupla em strings,
no entanto, são automaticamente convertidos com to_s.)</p>

<p>to_s é facilmente o mais importantes dos métodos de conversão, porque representações de seqüência de objetos são tão comumente
utilizadas em interfaces de usuário. Uma importante alternativa para to_s é o método inspect. to_s é geralmente destinados a retornar uma
representação legível do objeto, adequado para usuários finais. inspect, por outro lado, é destinados ao uso de depuração, e deve
retornar uma representação que é útil para os desenvolvedores de Ruby. O padrão do método inspect, herdado de Object, simplesmente chama
to_s.</p>

<h5>As conversões implícitas</h5>


<p>Às vezes, uma classe tem características fortes de uma outra classe. A classe Exception de Ruby representa um erro ou condição
inesperada em um programa e encapsula uma mensagem de erro. No Ruby 1.8, objetos Exception não são apenas conversível para strings,
que são strings como objetos e podem ser tratadas como se fossem strings em muitos contextos [*], Por exemplo:</p>

<figure class='code'><figcaption><span>class Exception</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.8</span>
</span><span class='line'><span class="n">e</span> <span class="o">=</span> <span class="no">Exception</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;não é realmente uma exceção&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Erro:&quot;</span> <span class="o">+</span> <span class="n">e</span> <span class="c1"># concatenação de String com uma exceção</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como os objetos de exceção são strings, eles podem ser usados ​​com a cadeia no operador de concatenação. Isso não funciona com a
maioria das outras classes de Ruby. A razão pela qual os objetos de Exceção pode se comportar como Objetos String é que, em Ruby
1.8, Exception implementa o método to_str, implícito de conversão, e o operador + definido pela String chama esse método em seu
do lado direito do operando.</p>

<p>Outros métodos de conversão implícitos são to_int para objetos que querem ser inteiro, como to_ary, para objetos que quer ser
array, e to_hash para objetos que querem ser hash. Infelizmente, as circunstâncias em que estes métodos de conversão são implícitos
chamados não são bem documentados. Entre as classes embutidas, estes métodos de conversões implícitas que normalmente não são implementadas, tampouco.</p>

<p>Observamos anteriormente, de passagem, que o operador == pode realizar um tipo fraco de tipo de conversão ao testar a igualdade.
Os operadores == definidos pelo Array, String, e Hash para ver se o operando do lado direito é da mesma classe como o operando esquerdo.
Se assim for, eles se comparam. Se não, verifica se o operando do lado direito tem um to_str, to_ary, ou método to_hash.
Eles não invocam estes métodos, mas se eles existem, eles invocam o método == do operando do lado direito e permiti que ele se decida
se é igual ao do operando esquerda.</p>

<p>No Ruby 1.9, as classes String, Array, Hash, RegExp e IO definiem tudas um método de classe chamado try_convert. Este métodos
convertem seu argumento se definido um método implícito apropriado de conversão, ou retorna contrário nil . Array.try_convert(o)
retorna o.to_ary se o método define, caso contrário, retorna nil. Estes métodos são try_convert conveniente se você quiser escrever
métodos que permitem conversões implícitas no seu argumento.</p>

<h5>Funções de conversão</h5>


<p>O módulo de Kernel define quatro métodos de conversão que se comportam como funções globais de conversão. Estas funções de array, Float,
Integer e String, têm os mesmos nomes que as classes para que se convertam, e eles são incomuns em que eles começam com uma
letra maiúscula.</p>

<p>A função Array tenta converter seu argumento para um array chamando to_ary. Se esse método é não definido ou retorna nil, ou ele tenta
o método to_a. Se to_a não está definido retorna nulo, a função Array simplesmente retorna um novo array contendo o argumento como
seu único elemento.</p>

<p>A função Float converte argumentos numéricos para objetos Float diretamente. Para qualquer valor não numérico, que chama o método to_f.</p>

<p>A função Integer converte o argumento para um Fixnum ou Bignum. Se o argumento é um valor numérico, ele é convertido diretamente. Valores
de Float são truncados e não arredondado. Se o argumento é uma string, ele procura por um indicador de radix(um condutor 0 para octal,
0x para hexadecimal, ou 0b para binário) e converte a string em conformidade. Ao contrário String.to_i não permiti caracteres não
numéricos à direita. Para qualquer outro tipo de argumento, a função Integer tenta converter primeiro com to_int e depois com to_i.</p>

<p>Finalmente, a função String converte o argumento para uma string simplesmente chamando seu método to_s.</p>

<h5>Tipo de operador Aritmético</h5>


<p>Tipos numéricos definem um método de conversão chamado <a href="http://www.ruby-doc.org/core-1.9.2/Numeric.html#method-i-coerce">coerce</a>. A intenção deste método é o de converter o argumento para o mesmo tipo como o objeto numérico no qual o método é invocado, ou
para converter ambos os objetos para algum tipo mais geralmente compatíveis. O método de coerce sempre retorna uma matriz que tem dois
valores numéricos do mesmo tipo. O primeiro elemento do array é o valor convertido do argumento para coerce. O segundo elemento do
retornado do array é o valor(convertido, se necessário) em que foi invocado coerce:</p>

<figure class='code'><figcaption><span>Coerc</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [1.0, 1.1]: coagir Fixnum para Flutuar</span>
</span><span class='line'><span class="nb">require</span> <span class="s2">&quot;rational&quot;</span> <span class="c1"># Use números racionais</span>
</span><span class='line'><span class="n">r</span> <span class="o">=</span> <span class="no">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># terceira Um como um número racional</span>
</span><span class='line'><span class="n">r</span><span class="o">.</span><span class="n">coerce</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># [Rational (2,1), Rational (1,3)]: Fixnum para Rational</span>
</span></code></pre></td></tr></table></div></figure>


<p>O método coerce é usado pelos operadores aritméticos. O operador + definido por Fixnum não sabe sobre números Rational, por exemplo, e se
o operando do lado direito é um valor rational, não se sabe como adicionar. coerce fornece a solução. Operadores numéricos são escritos
de modo que, se eles não sabem o tipo do operando do lado direito, que invocam o método coerce do operando do lado direito, passando o
operando da esquerda como um argumento. Voltando ao nosso exemplo de adição de um Fixnum e um Rational, o método coerce de Rational
retorna um array de dois valores racionais. Agora, o operador + definido por Fixnum pode simplesmente invocar + sobre os valores no array.</p>

<h5>Conversões de tipos Booleanos</h5>


<p>Valores booleanos merecem uma menção especial no contexto de conversão de tipo. Ruby é muito rigoroso com seus valores booleanos: true e
falso têm métodos to_s, que retornam &#8220;true&#8221; e &#8220;falso&#8221;, mas definem nenhum outro método de conversão. E não há nenhum método to_b
para converter os outros valores para Booleanos.</p>

<p>Em algumas Linguagens, é falsa a mesma coisa que 0, ou pode ser convertidos para 0. Em Ruby, os valores verdadeiros e falsos são os
seus próprios objetos distintos, e não existem conversões implícitas que convertem os outros valores para verdadeiro ou falso.
Esta é apenas metade da história, no entanto. Operadores booleanos de Ruby e de sua condicional e construções em loops que usam
expressões booleanas podem trabalhar com outros valores que o verdadeiro e o falso. A regra é simples: em expressões Boolean, qualquer
valor diferente de false ou nil se comporta como (mas não é convertida em) verdadeiro. nil, por outro lado se comporta como falsa.</p>

<p>Suponha que você queira testar se a variável x é nula ou não. Em algumas línguagens, você deve escrever explicitamente uma expressão
de comparação que avalia a verdadeira ou falso:</p>

<figure class='code'><figcaption><span>True ou False</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="kp">nil</span> <span class="c1">#  a expressão &quot;x! = nil&quot; retorna true ou false para o caso</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">x</span> <span class="c1"># x Imprimir se ela é definida</span>
=======
<h1>Missing Methods e Missing Constants</h1>


<p>O método <code>method_missing</code> é uma parte fundamental da pesquisa de algoritmo em método em Ruby e fornece uma maneira poderosa para capturar e manipular
invocações arbitrárias sobre um objeto. O método <code>const_missing</code> de <code>Module</code> executa uma função similar para o algoritmo de pesquisa constante e que
nos permite calcular ou lazily inicializa as constantes. Os exemplos que seguem demonstram ambos métodos.</p>

<h3>Constantes Unicode Codepoint com const_missing</h3>


<p>O Exemplo 1-1 define um módulo <code>Unicode</code> que aparece para definir uma constante (uma string UTF-8) para cada <code>Unicode codepoint</code> de <code>U+0000</code> a
<code>U+10FFFF</code>. O único modo prático para suportar estas muitas constantes é a utilização do método <code>const_missing</code>. O código faz a suposição de que se uma
constante é referenciada uma vez, é susceptível de ser utilizado de novo, de modo que o método <code>const_missing</code> chama <code>Module.const_set</code> para definir
uma constante real para se referir a cada valor calculado.</p>

<figure class='code'><figcaption><span>Exemplo 1-1. Constantes Unicode codepoint com const_missing</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Todo codepoints Unicode. Ele usa const_missing para defini-los lazily.</span>
</span><span class='line'><span class="c1"># Exemplos:</span>
</span><span class='line'><span class="c1">#   copyright = Unicode::U00A9</span>
</span><span class='line'><span class="c1">#   euro = Unicode::U20AC</span>
</span><span class='line'><span class="c1">#   infinity = Unicode::U221E</span>
</span><span class='line'><span class="k">module</span> <span class="nn">Unicode</span>
</span><span class='line'>  <span class="c1"># Este método permite-nos definir constantes Unicode codepoint lazily.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">const_missing</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>  <span class="c1"># constante indefinida passada como um símbolo</span>
</span><span class='line'>    <span class="c1"># Verifique se o nome da constante é da forma certa.</span>
</span><span class='line'>    <span class="c1"># Capital U seguido de um número hexadecimal entre 0000 e 10FFFF.</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">name</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=~</span> <span class="sr">/^U([0-9a-fA-F]{4,5}|10[0-9a-fA-F]{4})$/</span>
</span><span class='line'><span class="err">      </span><span class="c1"># $1 é o número hexadecimal correspondente. Converte em um inteiro.</span>
</span><span class='line'>      <span class="n">codepoint</span> <span class="o">=</span> <span class="vg">$1</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Converte o número para uma string UTF-8 com a magia do Array.pack.</span>
</span><span class='line'>      <span class="n">utf8</span> <span class="o">=</span> <span class="o">[</span><span class="n">codepoint</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Faz a imutável string UTF-8.</span>
</span><span class='line'><span class="err">      </span><span class="n">utf8</span><span class="o">.</span><span class="n">freeze</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Define uma constante real para pesquisa mais rápida da próxima vez, e retorna</span>
</span><span class='line'><span class="err">      </span><span class="c1"># O texto UTF-8 para este tempo.</span>
</span><span class='line'><span class="err">      </span><span class="nb">const_set</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">utf8</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="k">else</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Eleva um erro para constantes do formulário errado.</span>
</span><span class='line'><span class="err">      </span><span class="k">raise</span> <span class="no">NameError</span><span class="p">,</span> <span class="s2">&quot;Uninitialized constant: Unicode::</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Rastreamento Invocações de método com method_missing</h3>


<p>No início deste post, demonstrei uma extensão para a classe <code>Hash</code> usando <code>method_missing</code>. Agora, no <code>Exemplo 1-2</code>, temos que demonstrar o uso de
<code>method_missing</code> delega as chamadas arbitrárias em um objeto para outro objeto. Neste exemplo, o que fazemos nesta ordem para a saída de rastreamento
de mensagens para o objeto.</p>

<p><code>Exemplo 1-2</code> define um método de instância <code>Object.trace</code> e uma classe <code>TracedObject</code>. O método <code>trace</code> retorna uma instância de <code>TracedObject</code> que
usa <code>method_missing</code> para pegar invocações, rastreá-las, e delegá-las ao objeto que está sendo rastreado. Você pode usar como este:</p>

<figure class='code'><figcaption><span>Rastrear Metodos</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">reverse</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">a</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isso produz a seguinte saída de rastreamento:</p>

<figure class='code'><figcaption><span>Retorno</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Invocando</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
</span><span class='line'><span class="no">Volta</span><span class="p">:</span> <span class="o">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span> <span class="n">a</span> <span class="n">partir</span> <span class="n">de</span> <span class="n">a</span><span class="o">.</span><span class="n">reverse</span>
</span><span class='line'><span class="no">Invocando</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="no">Raising</span><span class="p">:</span> <span class="no">IndexError</span><span class="p">:</span> <span class="err">í</span><span class="n">ndice</span> <span class="n">de</span> <span class="mi">3</span> <span class="n">de</span> <span class="n">matriz</span> <span class="n">de</span> <span class="n">a</span><span class="o">.</span><span class="n">fetch</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que, além de demonstrar <code>method_missing</code>, o <code>Exemplo 1-2</code> demonstra também <code>Module.instance_methods</code>, <code>Module.undef_method</code> e <code>Kernel.caller</code>.</p>

<figure class='code'><figcaption><span>Exemplo 1-2. Rastreamento invocações de método com method_missing</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Se comporta exatamente como o original, mas que traça todas as chamadas de método</span>
</span><span class='line'><span class="c1"># No objeto. Se rastreamento mais de um objeto, especifique um nome para</span>
</span><span class='line'><span class="c1"># Aparecer na saída. Por padrão, as mensagens serão enviadas para STDERR,</span>
</span><span class='line'><span class="c1"># Mas você pode especificar qualquer stream (ou qualquer objeto que aceita strings</span>
</span><span class='line'><span class="c1"># Como argumentos para &lt;&lt;).</span>
</span><span class='line'><span class="n">classe</span> <span class="no">Object</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="nb">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="no">STDERR</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Retorna um TracedObject que traços e delegados tudo mais para nós.</span>
</span><span class='line'><span class="err">    </span><span class="no">TracedObject</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Esta classe usa method_missing para rastrear chamadas de método e</span>
</span><span class='line'><span class="c1"># Então delega ele para algum outro objeto. Ele exclui a maioria de seus próprios</span>
</span><span class='line'><span class="c1"># Métodos de instância para que eles não ficam no caminho de method_missing.</span>
</span><span class='line'><span class="c1"># Note que apenas métodos invocados através da TracedObject será rastreado.</span>
</span><span class='line'><span class="c1"># Se o objeto delegado chama métodos em si, aquelas invocações</span>
</span><span class='line'><span class="c1"># Não será rastreado.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">TracedObject</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Indefine todos os nossos métodos de instância públicos não críticos.</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Observe o uso do Module.instance_methods e Module.undef_method.</span>
</span><span class='line'>  <span class="nb">instance_methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
</span><span class='line'><span class="err">    </span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">to_sym</span>   <span class="c1"># Ruby 1.8 retorna string, em vez de símbolos</span>
</span><span class='line'>    <span class="k">next</span> <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="ss">:object_id</span> <span class="o">||</span> <span class="n">m</span> <span class="o">==</span> <span class="ss">:__id__</span> <span class="o">||</span> <span class="n">m</span> <span class="o">==</span> <span class="ss">:__send__</span>
</span><span class='line'><span class="err">    </span><span class="n">undef_method</span> <span class="n">m</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Inicializa esta instancia do TracedObject.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="vi">@o</span> <span class="o">=</span> <span class="n">o</span>            <span class="c1"># objeto que delegar</span>
</span><span class='line'><span class="err">    </span><span class="vi">@n</span> <span class="o">=</span> <span class="nb">name</span>         <span class="c1"># O nome do objeto a aparecer no rastreamento de mensagens</span>
</span><span class='line'><span class="err">    </span><span class="vi">@trace</span> <span class="o">=</span> <span class="n">stream</span>   <span class="c1"># Onde essas mensagens de rastreamento são enviados</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Este é o principal método de TracedObject. Ele é invocado por apenas</span>
</span><span class='line'><span class="err">  </span><span class="c1"># Sobre qualquer invocação de método em um TracedObject.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'><span class="err">    </span><span class="n">m</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">shift</span>         <span class="c1"># O primeiro é o nome do método</span>
</span><span class='line'><span class="err">    </span><span class="k">begin</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Acompanhe a invocação do método.</span>
</span><span class='line'><span class="err">      </span><span class="n">arglist</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">a</span><span class="o">.</span><span class="n">inspect</span><span class="p">}</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
</span><span class='line'><span class="err">      </span><span class="vi">@trace</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Invoking: </span><span class="si">#{</span><span class="vi">@n</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="s2">(</span><span class="si">#{</span><span class="n">arglist</span><span class="si">}</span><span class="s2">) at </span><span class="si">#{</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Invoque o método em nosso objeto de delegação e obtem o valor de retorno.</span>
</span><span class='line'><span class="err">      </span><span class="n">r</span> <span class="o">=</span> <span class="vi">@o</span><span class="o">.</span><span class="n">send</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Traça um retorno normal do método.</span>
</span><span class='line'><span class="err">      </span><span class="vi">@trace</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Returning: </span><span class="si">#{</span><span class="n">r</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2"> from </span><span class="si">#{</span><span class="vi">@n</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="s2"> to </span><span class="si">#{</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Retorna o valor que o objeto delegado retornado.</span>
</span><span class='line'><span class="err">      </span><span class="n">r</span>
</span><span class='line'><span class="err">    </span><span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Traçar um retorno anormal do método.</span>
</span><span class='line'><span class="err">      </span><span class="vi">@trace</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Raising: </span><span class="si">#{</span><span class="n">e</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">e</span><span class="si">}</span><span class="s2"> from </span><span class="si">#{</span><span class="vi">@n</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'><span class="err">      </span><span class="c1"># E re-envia qualquer exceção que o objeto delegado levantada.</span>
</span><span class='line'><span class="err">      </span><span class="k">raise</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="err">  </span><span class="c1"># Retorna o objeto que delegou.</span>
</span><span class='line'><span class="err">  </span><span class="k">def</span> <span class="nf">__delegate</span>
</span><span class='line'><span class="err">    </span><span class="vi">@o</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Objetos sincronizados por delegação</h3>


<p>No post anterior, vimos um método global sincronizado, que aceita um objeto e executa um bloco sob a proteção do <code>Mutex</code> associado a esse objeto.
A maior parte do exemplo consistiu na aplicação do método <code>Object.mutex</code>. O método sincronizado foi trivial:</p>

<figure class='code'><figcaption><span>Mutex</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<<<<<<< HEAD
<p>Esse código funciona em Ruby, mas é mais comum simplesmente para tomar vantagem do fato de que todos os outros valores do que zero e
falso se comportam como verdadeiras:</p>

<figure class='code'><figcaption><span>True ou False</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="c1"># Se x é não-nula</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">x</span> <span class="c1"># Em seguida, imprimi-lo</span>
=======
<p>O Exemplo 1-3 modifica este método de modo que, quando chamado sem um bloco, ele retorna um invólucro em torno do objeto <code>SynchronizedObject</code>.
<code>SynchronizedObject</code> é uma classe que delega com base em <code>method_missing</code>. É muito parecido com a classe <code>TracedObject</code>, Exemplo 1-2, mas Ruby 1.9 está
escrito com uma subclasse de <code>BasicObject</code>, por isso não há necessidade de excluir explicitamente os métodos de instância de objeto. Note que o código
deste exemplo não está sozinho, que exige o método <code>Object.mutex</code> definido anteriormente.</p>

<figure class='code'><figcaption><span>Exemplo 1-3. Métodos de sincronização com method_missing</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="n">o</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="no">SynchronizedObject</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># A classe delega usando method_missing de segurança da thread</span>
</span><span class='line'><span class="c1"># Em vez de estender objetos e excluir nossos métodos que acabamos de estender de</span>
</span><span class='line'><span class="c1"># BasicObject, que é definido no Ruby 1.9. BasicObject não</span>
</span><span class='line'><span class="c1"># Herda do Object ou do Kernel, de modo que os métodos de uma BasicObject não pode</span>
</span><span class='line'><span class="c1"># Chamar os métodos de nível superior: eles não são apenas lá.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">SynchronizedObject</span>  <span class="o">&lt;</span> <span class="no">BasicObject</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">o</span><span class="p">);</span> <span class="vi">@delegate</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__delegate</span><span class="p">;</span> <span class="vi">@delegate</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@delegate</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span>
</span><span class='line'>      <span class="vi">@delegate</span><span class="o">.</span><span class="n">send</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<<<<<<< HEAD
<p>É importante lembrar que os valores como 0, 0.0, e uma string vazia &#8220;&#8221; comportam-se como verdadeiro em Ruby, que é surpreendente se você
está acostumado a linguagens como C ou JavaScript.</p>

<p>É isso amigos&#8230;</p>

<p>Até Mais..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part IV]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-iv/"/>
    <updated>2012-05-20T13:01:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-iv</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Ordem de Object</h3>


<p></p>

<p>Praticamente todas as classes podem definir o método ==, sendo útil para testar as suas instâncias para a igualdade. Algumas
classes também podem definir uma ordenação. Ou seja: para quaisquer duas instâncias de uma classe, as duas instâncias devem ser iguais,
ou uma instância deve ser &#8220;menos que&#8221; a outra. Numbers são das classes mais óbvias para que tal ordenação seja definido.
String são também ordena, de acordo com o numéro de ordenação dos códigos de caracteres que compõem as strings. Se uma classe define
uns casos de pedido, em seguida, a classe pode ser comparada e classificada.</p>

<!--more-->


<p>Em Ruby, classes definem um ordenação através da implementação do operador &lt;=>. Este operador deve retornar -1 se o operando da esquerda
é menor que o operando da direita, 0 se os dois operandos são iguais, e 1 se o operando esquerdo é maior que o operando direito.
Se os dois operandos não podem ser  significativamente comparados (se o operando direito é de uma classe diferente, por exemplo),
em seguida, o operador deve retornar nil:</p>

<figure class='code'><figcaption><span>Operador <=></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span> <span class="c1"># -1</span>
</span><span class='line'><span class="mi">5</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span> <span class="c1"># 0</span>
</span><span class='line'><span class="mi">9</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span> <span class="c1"># 1</span>
</span><span class='line'><span class="s2">&quot;1&quot;</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span> <span class="c1"># nil: inteiros e strings não são comparáveis</span>
</span></code></pre></td></tr></table></div></figure>


<p>O operador &lt;=> é tudo que é necessário para comparar os valores. Mas não é particularmente intuitivo. Assim, as classes que definem
este operador tipicamente também incluir o Módulo <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> como um mixin.
(Módulos e mixins são abordados em Módulos como Mixins). O mixin Comparable define o seguinte operador em termos de &lt;=>:</p>

<pre><code>&lt;   -   Menor que
&lt;=  -   Menor ou igual
==  -   Igual
&gt;=  -   Maior ou igual
&gt;   -   Maior que
</code></pre>

<p><a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> não define o operador !=; o Ruby automaticamente define o
operador como a negação do operador ==. Além destes operadores de comparação, <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> também define um método útil de comparação com o between? :</p>

<figure class='code'><figcaption><span>Comparable between?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">between?</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># verdadeiro: 0 &lt;= 1 &lt;= 10</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se o operador &lt;=> retornar nil, todos os operadores de comparação dele derivados retornam falso. O especial Float com valor NaN é um exemplo:</p>

<figure class='code'><figcaption><span>Float NaN</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
=======
<p>É isso ai amigos&hellip; :)</p>

<p>Até o proximo! :D</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Estruturas de Controle Personalizados - #Ruby 1.9]]></title>
    <link href="http://rrmartins.com/blog/2012/09/13/estruturas-de-controle-personalizados-number-ruby-1-dot-9/"/>
    
    <updated>2012-09-13T22:50:00-03:00</updated>
    <id>http://rrmartins.com/blog/2012/09/13/estruturas-de-controle-personalizados-number-ruby-1-dot-9</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Estruturas de Controle Personalizados</b>... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Estruturas de Controle Personalizados</h1>


<p>Uso de blocos em Ruby, juntamente com sua sintaxe de parênteses opcional, tornam muito fácil de definir métodos que parecem <code>iterator</code> e se comportam
como estruturas de controle. O método <code>loop</code> do <code>Kernel</code> é um exemplo simples. Neste post, desenvolvo mais três exemplos. Os exemplos aqui usam
segmentação da API do Ruby, você pode precisar de ler Threads e Concorrência para compreender todos os detalhes.</p>

<h3>Executando Delaying e Repeating: `after` e `every`</h3>


<p>O exemplo 1-1 define métodos globais nomeados após os dias. Cada um leva um argumento numérico que representa um número de segundos e devem ter um
bloco associado. Depois cria um novo segmento e retorna o objeto <code>Thread</code> imediatamente. O segmento recém-criado dorme para o número especificado de
segundos e, então, chama (sem argumentos) o bloco que você forneceu. Tudo é semelhante, mas ele chama o bloco repetidamente, &ldquo;dorme&rdquo; o número
especificado de segundos entre chamadas. O segundo argumento para todos é um valor para passar para a primeira chamada do bloco. O valor de retorno de
cada invocação se torna o valor que passou para a próxima invocação. O bloco associado a cada intervalo pode ser usado para prevenir qualquer
invocações futuras.</p>

<p>Aqui está um exemplo de código que usa <code>after</code> e <code>every</code>:</p>

<figure class='code'><figcaption><span>after e every</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;afterevery&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">after</span> <span class="n">i</span> <span class="p">{</span> <span class="nb">puts</span> <span class="n">i</span><span class="p">}</span> <span class="p">}</span>  <span class="c1"># Lentamente imprimir os números 1-5</span>
</span><span class='line'><span class="nb">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                            <span class="c1"># Aguarde cinco segundos</span>
</span><span class='line'><span class="n">every</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span> <span class="k">do</span> <span class="o">|</span><span class="n">count</span><span class="o">|</span>               <span class="c1"># Agora, lentamente, imprimir 6-10</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">count</span>
</span><span class='line'>  <span class="k">break</span> <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">10</span>
</span><span class='line'><span class="err">  </span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>                         <span class="c1"># O valor próximo de contagem</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="nb">sleep</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>                            <span class="c1"># Dê um tempo acima para executar</span>
</span></code></pre></td></tr></table></div></figure>


<p>Chamando o <code>sleep</code> no final deste código, evita o programa de sair antes que a <code>thread</code> seja criada por poder todas completar sua contagem. Com esse
exemplo de como <code>after</code> e <code>every</code> são usadas, agora estamos prontos para apresentar a sua implementação.</p>

<figure class='code'><figcaption><span>Exemplo 1-1. Os métodos after e every</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># Defini métodos de kernel after e every por adiar blocos de código.</span>
</span><span class='line'><span class="c1"># Exemplos:</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1">#   after 1 { puts &quot;done&quot; }</span>
</span><span class='line'><span class="c1">#   every 60 { redraw_clock }</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># Ambos os métodos retornam objetos Thread. Chame kill sobre os objetos devolvidos</span>
</span><span class='line'><span class="c1"># Para cancelar a execução do código.</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># Note que essa é uma implementação muito ingênua. A mais robusta</span>
</span><span class='line'><span class="c1"># Implementação usaria uma Thread timer para todas as tarefas globais,</span>
</span><span class='line'><span class="c1"># Permitiria uma maneira de recuperar o valor de um bloco diferido, e iria</span>
</span><span class='line'><span class="c1"># Fornecer uma maneira de esperar por todas as tarefas pendentes para ser concluído.</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Executar o bloco after depois de esperar o número especificado de segundos.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">after</span><span class="p">(</span><span class="n">seconds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>       <span class="c1"># Em um novo segmento ...</span>
</span><span class='line'>    <span class="nb">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>    <span class="c1"># Primeiro espera</span>
</span><span class='line'>    <span class="n">block</span><span class="o">.</span><span class="n">call</span>        <span class="c1"># Em seguida, chamar o bloco</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span> <span class="c1"># Retorna o objeto Thread de imediato</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Repete sleep e after executando o bloco.</span>
</span><span class='line'><span class="c1"># Passa valor para o bloco na primeira chamada.</span>
</span><span class='line'><span class="c1"># Em chamadas subseqüentes, passar o valor da chamada anterior.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">every</span><span class="p">(</span><span class="n">seconds</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>  <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>                 <span class="c1"># Em um novo segmento ...</span>
</span><span class='line'>    <span class="kp">loop</span> <span class="k">do</span>                     <span class="c1"># loop para sempre (ou até ruptura no bloco)</span>
</span><span class='line'>      <span class="nb">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>            <span class="c1"># sleep</span>
</span><span class='line'><span class="err">      </span><span class="n">value</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># E invocar bloco</span>
</span><span class='line'><span class="err">    </span><span class="k">end</span> <span class="c1"># Em seguida, repita ..</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span> <span class="c1"># cada retorna o Tópico</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<h3>Thread de segurança com blocos sincronizados</h3>


<p>Ao escrever programas que usam várias <code>Threads</code>, é importante que duas <code>threads</code> não tente modificar o mesmo objeto, ao mesmo tempo. Uma maneira de
fazer isto é colocar o código que deve ser feito em uma <code>thread</code> segura em um bloco associado a uma chamada para o método de <code>synchronize</code> de um objeto
<code>Mutex</code>. No Exemplo 1-2 que levar isso a um passo adiante, e emula a palavra-chave <code>synchronized</code> do Java com um método global chamado <code>synchronized</code>.
Este método <code>synchronized</code> espera um único objeto como argumento e um bloco. Ele obtém um <code>Mutex</code> associado ao objeto, e usa <code>Mutex.synchronize</code> para
invocar o bloco. A parte complicada é que o objeto de Ruby, ao contrário de objetos Java, não tem um <code>Mutex</code> que lhes estão associados. Então o Exemplo
1-2 também define um método de instância chamado <code>mutex</code> em Object. Curiosamente, a implementação deste método <code>mutex</code> usa <code>synchoronized</code> na sua forma
de palavras-chave novo estilo!</p>

<p><code>Mutex</code> -> <a href="http://www.ruby-doc.org/core-1.9.2/Mutex.html"><a href="http://www.ruby-doc.org/core-1.9.2/Mutex.html">http://www.ruby-doc.org/core-1.9.2/Mutex.html</a></a></p>

<figure class='code'><figcaption><span>Exemplo 1-2. Simples blocos sincronizados</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<<<<<<< HEAD
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">nan</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1"># zero dividido por zero não é um número</span>
</span><span class='line'><span class="n">nan</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="c1"># false: não é menor que zero</span>
</span><span class='line'><span class="n">nan</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="c1"># false: não é maior que zero</span>
</span><span class='line'><span class="n">nan</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1"># false: não é igual a zero</span>
</span><span class='line'><span class="n">nan</span> <span class="o">==</span> <span class="n">nan</span> <span class="c1"># false: não é mesmo igual a si mesmo!</span>
</span><span class='line'><span class="n">nan</span><span class="o">.</span><span class="n">equal?</span><span class="p">(</span><span class="n">nan</span><span class="p">)</span> <span class="c1"># isso é verdade, claro</span>
</span></code></pre></td></tr></table></div></figure>


<p>Observe que a definição de &lt;=> e incluindo o módulo <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> define um operador == para o sua classe. Algumas classes que definem o seu próprio operador ==, normalmente quando eles podem
implementar esta forma mais eficiente do que um teste de igualdade com base no operador &lt;=>. É possível definir classes que
implementam diferentes noções de igualdade em seus operadores == e &lt;=>. Uma classe pode fazer comparações de string case-sensitive
para o operador ==, por exemplo, mas, em seguida, fazem comparações de maiúsculos e minúsculos com &lt;=>, de modo que as instâncias da classe
se classificam com mais naturalidade. Em geral, porém, é melhor se &lt;=> retorna 0 se e somente se == retorna true.</p>

<p>É isso amigos&#8230; o proximo post vamos conversar um pouco de Conversões de Object&#8217;s.</p>

<p>Até Mais..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part III]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-iii/"/>
    <updated>2012-05-19T16:58:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-iii</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Igualdade objeto</h3>


<p>Ruby tem um número surpreendente de maneiras de comparar objetos para igualdade, e é importante entender como eles funcionam, assim você sabe quando usar cada método.</p>

<!--more-->




<h3>O método equal? </h3>


<p>O método equal? é definido pelo objeto para testar se os dois valores referem-se exatamente o mesmo objeto. Para qualquer dos dois
distintos objetos, esse método sempre retorna false:</p>

<figure class='code'><figcaption><span>equal?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># Uma referência a um objeto String</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># Duas referências a outro objeto String</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">equal?</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># falsa: a e b são objetos diferentes</span>
</span><span class='line'><span class="n">b</span><span class="o">.</span><span class="n">equal?</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1"># verdadeiro: b e c referem-se ao mesmo objeto</span>
</span></code></pre></td></tr></table></div></figure>


<p>Por convenção, nunca subclasses substituem o método equal?.</p>

<p>Outra maneira de determinar se os dois objetos são, de fato, do mesmo objetivo é verificar a sua object_id:</p>

<figure class='code'><figcaption><span>equal?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">object_id</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">object_id</span> <span class="c1"># Funciona como a.equal? ​​(b)</span>
</span></code></pre></td></tr></table></div></figure>




<h3>O operador ==</h3>


<p>O operador == é a forma mais comum para testar a igualdade. Na Classe Object, é simplesmente uns testes de sinónimos para equal?, e
se duas referências de objeto são idênticos. A maioria das classes redefinem este operador para permitir instâncias distintas para ser
testado para igualdade:</p>

<figure class='code'><figcaption><span>Operador ==</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># uma string</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># Um objeto String diferente com o mesmo conteúdo</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">equal?</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># falsa: a e b não se referem ao mesmo objeto</span>
</span><span class='line'><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="c1"># verdade: mas estes dois objetos distintos têm valores iguais</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note que o único sinal de igual nesse código é o operador de atribuição. Leva dois sinais de igual para testar a igualdade
em Ruby (esta é uma convenção que compartilha Ruby com muitas outras linguagens de programação).</p>

<p>Padrão de Classes do Ruby definem o operador == para implementar uma razoável definição de igualdade. Isso inclui Array
e as classes de hash. Dois Arrays são iguais de acordo com == se tiverem o mesmo número de elementos,
e se os seus elementos correspondentes são todos iguais de acordo com ==. Dois hashes são == se contiverem o mesmo número de pares
chave/valor, e se as chaves e valores são, eles próprios iguais. (Os valores são comparados com o operador ==,
mas chaves de hash são comparados com o método eql?.)</p>

<pre><code>Igualdade para programadores Java

Se você é um programador Java, você está acostumado a usar o operador == para testar se dois objetos são
o mesmo objeto, e você está acostumado a usar o método equals para testar se dois objetos distintos têm o mesmo valor. 
Convenção do Ruby é apenas sobre o oposto de Java.
</code></pre>

<p>As classes numéricas realizam conversões de tipo simples nas suas operações de ==, de modo que (por exemplo) o
Fixnum 1 e o Float 1.0 comparados como iguais. O operador == de classes, como String e Array, normalmente requerem dois operandos
para ser da mesma classe. Se o operando do lado direito define uma to_str ou função de conversão to_ary, então estes operadores invocam
o operador == definido pelo lado direito operando, e deixam que objeto decidem se é igual ao lado esquerdo, sendo string ou array.
Assim, é possível (embora não comum) para definir classes com comportamento comparação de string ou array.</p>

<p>!= (&#8220;Não-igual&#8221;) é usado em Ruby para testar a desigualdade. Quando o Ruby vê !=, Ele simplesmente usa o operador == e depois
inverte o resultado. Isto significa que uma única classe precisa definir o operador == para definir a sua própria noção de
igualdade. Ruby dá o operador != de graça. No Ruby 1.9, no entanto, as classes podem explicitamente definir os seus próprios operadores !=.</p>

<h3>O método eql?</h3>


<p>O método eql? é definido pelo objeto como um sinônimo para equal?. Classes que se sobrepõem a ele normalmente usá ele como uma
versão rígida do operador == que não faz nenhum tipo de conversão. Por exemplo:</p>

<figure class='code'><figcaption><span>eql?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="c1"># verdade: Fixnum e objetos flutuantes podem ser ==</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">eql</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># falsa: mas eles nunca são eql!</span>
</span></code></pre></td></tr></table></div></figure>


<p>A classe Hash usa eql? para verificar se duas chaves de hash são iguais. Se dois objetos são eql?, os métodos de hash também
deve retornar o mesmo valor. Normalmente, se você criar uma classe e defini o operador ==, você pode simplesmente escrever um
método de hash e definir eql? para usar ==.</p>

<h3>O operador ===</h3>


<p>O operador === é comumente chamado de &#8220;caso de igualdade&#8221; e é usado para testar se o valor-alvo de uma declaração caso corresponde
a qualquer das cláusulas, quando dessa declaração.</p>

<p>Classe Object define por padrão o operador === para que ele chama o operador ==. Para muitas classes, por conseguinte, a igualdade
caso é o mesmo que == (igualdade). Mas certas classes principais definem === de maneira diferente, e nestes casos, é mais de um membro
ou operador correspondente. Range define === para testar se um valor está dentro do intervalo. Regexp define === para testar se uma
string corresponde à expressão regular. E Class define === para testar se um objeto é uma instância dessa Class. No Ruby 1.9, Symbol
define === retornando true se o operando do lado direito é o mesmo símbolo como o esquerda ou se é uma cadeia guardando o mesmo texto.
Exemplos:</p>

<figure class='code'><figcaption><span>Operador ===</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span> <span class="o">===</span> <span class="mi">5</span> <span class="c1"># verdadeiro: 5 está na gama de 1 .. 10</span>
</span><span class='line'><span class="sr">/\d+/</span> <span class="o">===</span> <span class="s2">&quot;123&quot;</span> <span class="c1"># verdade: a seqüência corresponde à expressão regular</span>
</span><span class='line'><span class="nb">String</span> <span class="o">===</span> <span class="s2">&quot;s&quot;</span> <span class="c1"># verdade: &quot;s&quot; é uma instância da classe String</span>
</span><span class='line'><span class="ss">:s</span> <span class="o">===</span> <span class="s2">&quot;s&quot;</span> <span class="c1"># verdadeiro no Ruby 1.9</span>
</span></code></pre></td></tr></table></div></figure>


<p>É raro ver o operador === usado explicitamente como este. Mais comumente, a sua utilização é simplesmente implícita em uma instrução case.</p>

<h3>O operador =~</h3>


<p>O operador =~ é definido pela String e Regexp (e Symbol no Ruby 1.9) para realizar ligações de padrões, e isso não é realmente um
operador de igualdade em tudo. Mas isso não tem um sinal de igual na mesma, de modo que ele está aqui para ser completo.
Objeto define uma versão sem o operador de =~, que sempre retorna false. Você pode definir este operador em sua própria classe,
se essa classe define um tipo de correspondência de operação padrão ou tem uma noção de igualdade aproximada, por exemplo.
!~ é definido como o inverso da =~. É definível em Ruby 1.9 mas não no Ruby 1.8</p>

<p>É isso ai rubistas&#8230; Até a proxima!</p>
]]></content>
  </entry>
  
</feed>
=======
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;thread&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 1.8 mantém Mutex nesta biblioteca</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Obter o Mutex associado com o objeto o, e então avalia</span>
</span><span class='line'><span class="c1"># Bloco sob a proteção do Mutex.</span>
</span><span class='line'><span class="c1"># Este funciona como a palavra-chave synchronized do Java.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Object.mutex na verdade não existe. Temos que definir isso.</span>
</span><span class='line'><span class="c1"># Este método retorna um Mutex único para cada objeto, e</span>
</span><span class='line'><span class="c1"># Sempre retorna o mesmo Mutex para qualquer objeto particular.</span>
</span><span class='line'><span class="c1"># Cria Mutexes lazily, o que requer sincronização para</span>
</span><span class='line'><span class="c1"># Segurança da Thread.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Object</span>
</span><span class='line'>  <span class="c1"># Retorna o Mutex para este objeto, criando, se necessário.</span>
</span><span class='line'>  <span class="c1"># A parte difícil é ter certeza de que duas threads não chamam</span>
</span><span class='line'>  <span class="c1"># Isso ao mesmo tempo e acabam por criar dois mutexes diferentes.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">mutex</span>
</span><span class='line'>    <span class="c1"># Se este objeto já tem um mutex, basta devolvê-lo</span>
</span><span class='line'>    <span class="k">return</span> <span class="vi">@__mutex</span> <span class="k">if</span> <span class="vi">@__mutex</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># Caso contrário, nós temos que criar um mutex para o objeto.</span>
</span><span class='line'><span class="err">    </span><span class="c1"># Para fazer isso com segurança que temos para sincronizar em nosso objeto de classe.</span>
</span><span class='line'>    <span class="n">synchronized</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Verifique novamente: no momento em que entrar neste bloco sincronizado,</span>
</span><span class='line'><span class="err">      </span><span class="c1"># Alguma outra thread pode já ter criado o mutex.</span>
</span><span class='line'>      <span class="vi">@__mutex</span> <span class="o">=</span> <span class="vi">@__mutex</span> <span class="o">||</span> <span class="no">Mutex</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="err">    </span><span class="p">}</span>
</span><span class='line'><span class="err">    </span><span class="c1"># O valor de retorno é @__mutex</span>
</span><span class='line'><span class="err">  </span><span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># O método Object.mutex definido acima, necessita para bloquear a classe</span>
</span><span class='line'><span class="c1"># Se o objeto não tiver um Mutex ainda. Se a classe não tem</span>
</span><span class='line'><span class="c1"># Mutex próprio ainda, então a classe da classe (a Class do Object)</span>
</span><span class='line'><span class="c1"># Será bloqueada. A fim de evitar recursão infinita, devemos</span>
</span><span class='line'><span class="c1"># Garantir que o objeto da classe tem um mutex.</span>
</span><span class='line'><span class="no">Class</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="vi">@__mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="o">.</span><span class="n">new</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>É isso ai amigos, até o proximo! :)</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Reflexão e Metaprogramação - ObjectSpace e GC - #Ruby 1.9 - Part VII]]></title>
    <link href="http://rrmartins.com/blog/2012/09/10/reflexao-e-metaprogramacao-objectspace-e-gc-number-ruby-1-dot-9-part-vii/"/>
    
    <updated>2012-09-10T23:26:00-03:00</updated>
    <id>http://rrmartins.com/blog/2012/09/10/reflexao-e-metaprogramacao-objectspace-e-gc-number-ruby-1-dot-9-part-vii</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>ObjectSpace e GC</b>... Estranho para alguns, mas, veremos que é simples!</p>




<h1>ObjectSpace e GC</h1>


<p>O módulo <code>ObjectSpace</code> define um punhado de métodos de baixo nível que pode ser ocasionalmente útil para depurar ou trabalhar com metaprogramação.
O método mais notável é <code>each_object</code>, um iterador que pode render cada objeto (ou a cada instância de uma classe especificada) que o intérprete sabe
sobre:</p>

<figure class='code'><figcaption><span>ObjectSpace</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Imprima uma lista de todas as classes conhecidas</span>
</span><span class='line'><span class="no">ObjectSpace</span><span class="o">.</span><span class="n">each_object</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">c</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ObjectSpace._id2ref</code> é o inverso da <code>Object.object_id:</code> leva um objeto como seu argumento ID e retorna ao objeto correspondente, ou levanta uma
RangeError se não há nenhum objeto com que ID.</p>

<p><code>ObjectSpace.define_finalizer</code> permite o registo de uma <code>Proc</code> ou um bloco de código a ser chamado quando um objeto especificado é <code>garbage collected</code>.
Você deve ter cuidado ao registar um finalizador tal, no entanto, como o bloco não tem permissão de <code>finalizer</code> usar o objeto lixo coletado. Quaisquer
valores necessários para finalizar o objeto deve ser capturados no âmbito do bloco <code>finalizer</code>, de modo a que estejam disponíveis sem desreferência do
objeto. Use <code>ObjectSpace.undefine_finalizer</code> para excluir todos os blocos inscritos para um objeto <code>finalizer</code>.</p>

<p>O final método <code>ObjectSpace</code> é <code>ObjectSpace.garbage_collect</code>, que força o <code>garbage collected</code> de Ruby para ser executado. Funcionalidade de <code>garbage
collected</code> também está disponível através do módulo <code>GC</code>. <code>GC.start</code> é sinônimo de <code>ObjectSpace.garbage_collect</code>. <code>garbage collected</code> pode ser
desativado temporariamente com <code>GC.disable</code>, e ele pode ser ativado novamente com <code>GC.enable</code>.</p>

<p>A combinação do <code>_id2ref</code> e métodos <code>define_finalizer</code> permite a definição de &ldquo;fracos&rdquo; objetos de referência, que possuem uma referência a um valor sem
impedir o valor de ser coletado se tornar de outra forma inacessível. Consulte a classe <code>weakref</code> na biblioteca padrão (em lib/weakref.rb) para um exemplo.</p>

<p>Até o proximo post amigos&hellip;</p>

<p>Conhecimento nunca é d+ ! :)</p>
]]></content>
    
  </entry>
  
<<<<<<< HEAD
=======
  <entry>
    
    <title type="html"><![CDATA[Reflexão e Metaprogramação - Tracing - #Ruby 1.9 - Part VI]]></title>
    <link href="http://rrmartins.com/blog/2012/09/10/reflexao-e-metaprogramacao-tracing-number-ruby-1-dot-9-part-vi/"/>
    
    <updated>2012-09-10T22:50:00-03:00</updated>
    <id>http://rrmartins.com/blog/2012/09/10/reflexao-e-metaprogramacao-tracing-number-ruby-1-dot-9-part-vi</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de continuar nos aprofundando um pouco mais de
<b>Reflexão e Metaprogramação</b> agora <b>Tracing</b>... Estranho para alguns, mas, veremos que é simples!</p>




<h1>Tracing</h1>


<p>Ruby define uma série de características para rastrear a execução de um programa. Estes principalmente são os úteis para a depuração do código e
imprimir mensagens de erro informativos. Duas das mais simples das características são as palavras-chave da linguagem: <code>__FILE__</code> e <code>__LINE__</code>.
Essas palavras-chave sempre avaliam o nome do arquivo e o número da linha dentro do arquivo em que se aparece, e eles permitem que uma mensagem de erro
para especificar o local exato em que ela foi gerado:</p>

<figure class='code'><figcaption><span>__FILE__ e __LINE__</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">STDERR</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="bp">__FILE__</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="bp">__LINE__</span><span class="p">):</span> <span class="n">invalid</span> <span class="n">data</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como um aparte, note que os métodos <code>Kernel.eval</code>, <code>Object.instance_eval</code>, e <code>Module.class_eval</code> todos aceitam um nome de arquivo (ou outra seqüência) e
um número de linha como os seus dois últimos argumentos. Se você está avaliando o código que você tenha extraído de um arquivo de algum tipo, você pode
usar esses argumentos para especificar os valores de <code>__FILE__</code> e <code>__LINE__</code> para a avaliação.</p>

<p>Você, sem dúvida, notou que quando uma exceção não tratada, a mensagem de erro impressa no console contém nome e informações de número de linha. Esta
informação é baseada em <strong>FILE</strong> e <strong>LINE</strong>, é claro. Cada Objeto de exceção tem um backtrace associado a ele que mostra exatamente onde ele foi criado,
onde o método que levantou a exceção foi invocado, onde esse método foi chamado, e assim por diante. O método <code>Exception.backtrace</code> retorna um <code>array</code> de
<code>strings</code> contendo essa informação. O primeiro elemento do <code>array</code> é este o local em que ocorreu a excepção, e cada elemento subsequente é um quadro de
pilha maior.</p>

<p>Você não precisa levantar uma exceção para obter um rastreamento da pilha atual, no entanto. O método <code>Kernel.caller</code> retorna o estadp atual na pilha de
chamadas da mesma forma como <code>Exception.backtrace</code>. Com nenhum argumento, o <code>caller</code> retorna um rastreamento de pilha, cujo primeiro elemento é o método
que chamou o método que chama de <code>caller</code>. Isto é, <code>caller[0]</code> especifica o local a partir do qual o método atual foi chamado. Você também pode chamar
de <code>caller</code> com um argumento que especifica quantos quadros de pilha a cair a partir do início do registo de <code>caller</code>. O padrão é <code>1</code>, e do
<code>caller(0)[0]</code> especifica o local em que o método <code>caller</code> é invocado. Isto significa, por exemplo, que o <code>caller[0]</code> é a mesma coisa que o
<code>caller(0)[1]</code> e que o <code>caller(2)</code> é o mesmo como <code>caller[1 .. -1]</code>.</p>

<p>Rastreamentos de pilha devolvidos por <code>Exception.backtrace</code> e <code>Kernel.caller</code> também incluem nomes de métodos. Antes de Ruby 1.9, você deve analisar as
seqüências de rastreamento de pilha para extrair nomes de métodos. No Ruby 1.9, no entanto, você pode obter o nome (como um símbolo) da execução
atual do método com <code>Kernel.__method__</code> ou seu sinônimo <code>Kernel.__callee__</code>. <code>__method__</code> é útil em conjunção com <strong>FILE</strong> e <strong>LINE</strong>:</p>

<figure class='code'><figcaption><span>raise</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">raise</span> <span class="s2">&quot;Assertion failed in </span><span class="si">#{</span><span class="n">__method__</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="bp">__FILE__</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="bp">__LINE__</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que <code>__method__</code> retorna o nome pelo qual um método foi originalmente definido, mesmo que o método foi invocado por um alias.</p>

<p>Em vez de simplesmente imprimi o nome e número em que ocorre um erro, você pode dar um passo adiante e mostrar a linha real de código. Se o seu programa
define uma constante global <code>SCRIPT_LINES__</code> e define-a igual a um <code>hash</code>, então os requisitos e métodos de carregar, adicionar uma entrada para este
<code>hash</code> para cada arquivo que carregar. As chaves de hash são nomes de arquivos e os valores associados com essas chaves são <code>arrays</code> que contêm as
linhas destes arquivos. Se você quiser incluir o arquivo principal (em vez que apenas incluir os arquivos que ele necessita), no <code>hash</code>, inicializá-lo
assim:</p>

<figure class='code'><figcaption><span>SCRIPT_LINES__</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SCRIPT_LINES__</span> <span class="o">=</span> <span class="p">{</span><span class="bp">__FILE__</span> <span class="o">=&gt;</span> <span class="no">File</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span><span class="bp">__FILE__</span><span class="p">)}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se você fizer isso, então você pode obter a linha atual de código-fonte em qualquer lugar em seu programa com esta expressão:</p>

<figure class='code'><figcaption><span>SCRIPT_LINES__</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SCRIPT_LINES__</span><span class="o">[</span><span class="bp">__FILE__</span><span class="o">][</span><span class="bp">__LINE__</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ruby permite rastrear atribuições para variáveis globais com <code>Kernel.trace_var</code>. Passe este método um símbolo que dá nome a uma variável global e uma
<code>string</code> ou bloco de código. Quando o valor das alterações de nomes de variáveis, a cadeia de caracteres será avaliada ou o bloco será invocado. Quando
um bloco é especificado, o novo valor da variável é passado como um argumento. Para parar o rastreamento da variável, chame <code>Kernel.untrace_var</code>. No
seguinte exemplo, notar o uso de <code>caller[1]</code>, para determinar o local do programa em que o bloco de rastreamento da variável foi invocado:</p>

<figure class='code'><figcaption><span>variavies globais</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Imprime a mensagem de cada vez $ mudanças SAFE</span>
</span><span class='line'><span class="nb">trace_var</span><span class="p">(:</span><span class="vg">$SAFE</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;$SAFE set to </span><span class="si">#{</span><span class="n">v</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="nb">caller</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>O último método de rastreamento é <code>Kernel.set_trace_func</code>, que registra um <code>Proc</code> a ser chamado após cada linha de um programa Ruby. <code>set_trace_func</code>
é útil se você quer escrever um módulo depurador que permite que linha por linha de passo através de um programa, mas não vamos cobri-lo em detalhes aqui.</p>

<p>Até a proxima amigos&hellip; =D</p>
]]></content>
    
  </entry>
  
>>>>>>> f0fad74ab02c4e5669e277aa283faa25f065f1cb
</feed>
>>>>>>> e6afad1eda35d241cd16bfeee03436f0db5a7017
