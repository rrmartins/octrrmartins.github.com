<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Rodrigo Martins]]></title>
  <link href="http://rrmartins.github.com/atom.xml" rel="self"/>
  <link href="http://rrmartins.github.com/"/>
  <updated>2012-06-02T18:50:37-03:00</updated>
  <id>http://rrmartins.github.com/</id>
  <author>
    <name><![CDATA[Rodrigo Martins]]></name>
    <email><![CDATA[rodrigo@rrmartins.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Invocações de método]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/invocacoes-de-metodo/"/>
    <updated>2012-06-02T15:36:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/invocacoes-de-metodo</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Invocações de método</h1>


<p>Uma expressão de invocação de método tem quatro partes:</p>

<ul>
<li><p>Uma expressão arbitrária cujo valor é o objeto no qual o método é chamado. Esta expressão é seguido por . ou :: para separá-lo a partir
do nome do método que se segue. A expressão e o separador são opcionais; se omitido, o método é invocada em si mesmo.</p></li>
<li><p>O nome do método a ser invocado. Este é o único pedaço exigido de uma expressão chamada de método.</p></li>
<li><p>Valores com o argumento passado para o método. A lista de argumentos podem ser colocados entre parênteses, mas estes são geralmente
opcionais. Se há mais de um argumento, eles são separados uns dos outros com vírgulas. O número e tipo de argumentos necessários
dependem da definição do método. Alguns métodos podem ser chamodos sem argumentos.</p></li>
<li><p>Um bloco opcional de código delimitado por chaves ou por um par <code>do/end</code>. O método pode invocar esse código usando a palavra-chave de
 <code>yield</code>. Esta capacidade de associar código arbitrário com qualquer invocação de método é a base para métodos poderosos em Ruby.</p></li>
</ul>


<p>Um nome do método é normalmente separado do objeto sobre o qual é chamado com um <code>..</code>, e com o <code>::</code>, que também é permitido, mas é raramente
usado porque pode fazer invocações de método parecem mais com referênciar constantes expressões.</p>

<p>Quando o interpretador Ruby tem o nome de um método e um objeto em que deve ser invocado, ele encontra a definição adequada do método
chamado usando um processo conhecido como &#8220;método de pesquisa&#8221; ou &#8220;resolução de nome do método.&#8221; Os detalhes não são importantes aqui,
mas eles são explicados completamente no método de pesquisa.</p>

<p>O valor de uma invocação expressão de método é o valor da expressão avaliada pelo último método no corpo do código. Aqui, no entanto, são
alguns exemplos de invocações de método:</p>

<figure class='code'><figcaption><span>Ruby</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;Olá mundo&quot;</span> <span class="c1"># &quot;puts&quot; invocado em auto, com uma seqüência de arg</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># &quot;sqrt&quot; invocado em Matemática objeto com uma arg</span>
</span><span class='line'><span class="n">message</span><span class="o">.</span><span class="n">length</span> <span class="c1"># &quot;comprimento&quot; invocado em mensagem objeto; não args</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">p</span> <span class="n">x</span><span class="p">}</span> <span class="c1"># &quot;cada&quot; chamado em um objeto, com um bloco associado</span>
</span></code></pre></td></tr></table></div></figure>


<p>Um dos exemplos do método de invocação mostradas anteriormente foi <code>message.length</code>. Você pode ser tentado a pensar-lo como uma variável
de expressão de referência, avaliando para o valor do comprimento da variável do objeto mensage. Este não é o caso, no entanto, Ruby tem
um modelo de programação muito orientada a objetos: objetos em Ruby podem encapsular qualquer número de variáveis ​​de instância interna,
mas expõem métodos apenas para o mundo exterior. Como o método <code>length</code> não espera argumentos e é chamado sem os parênteses opcionais,
parece que referência uma variável. Na verdade, isso é intencional. Métodos como estes são chamados para atribuir métodos de acesso, e
dizemos que o objeto da <code>mensage</code> tem um atributo de <code>lenght</code>. Como veremos, é possível que o objeto de <code>mensage</code>
para definir um método chamado <code>length=</code>. Se este método espera um único argumento, então é um método setter do atributo e
Ruby invoca em resposta a atribuição. Se um tal método é definido, então estas duas linhas de código seria tanto chamar o mesmo método:</p>

<figure class='code'><figcaption><span>Length</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">message</span><span class="o">.</span><span class="n">length</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># invocação do método tradicional</span>
</span><span class='line'><span class="n">message</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># invocação Método como a atribuição</span>
</span></code></pre></td></tr></table></div></figure>


<p>Agora, considere a seguinte linha de código, assumindo que uma variável contém um <code>Array</code>:</p>

<figure class='code'><figcaption><span>Array</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Você pode pensar novamente que este é um tipo especial de variável de referência, onde a variável em questão é na verdade um elemento do
<code>Array</code>. Novamente, no entanto, esta é invocação do método. O intérprete Ruby converte o acesso ao <code>Array</code> para isso:</p>

<figure class='code'><figcaption><span>Array</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">[</span><span class="o">]</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>O acesso ao <code>Array</code> torna-se uma invocação do método chamado <code>[]</code>, com o índice do <code>Array</code> como seu
argumento. Esta sintaxe de acesso de <code>Array</code> não se limita a <code>Arrays</code>. Qualquer objeto é permitido para definir um
método chamado <code>[]</code>. Quando o objeto é &#8220;indexado&#8221;, com o indix entre parênteses, os valores dentro dos parênteses será passado
para o método. Se o método <code>[]</code> é escrito para esperar três argumentos, então você deve colocar três expressões separados por
vírgula dentro dos colchetes.</p>

<p>Atribuição de <code>Arrays</code> também é feito através de invocação de método. Se o objeto o define um método chamado <code>[]=</code>, então a expressão <code>o[x] = y</code> torna-se <code>o.[] = (x, y)</code>, e a expressão <code>o[x, y] = z</code> se torna <code>o.[] = (x , y, z)</code>.</p>

<p>Muitos operadores do Ruby são definidos como métodos, e expressões como <code>x + y</code> são avaliados como <code>x.+(y)</code>, onde o
nome de método é <code>+</code>. O fato de que muitos dos operadores do Ruby são definidos como métodos que significa você pode redefinir
esses operadores na sua próprias classes.</p>

<p>Agora, vamos considerar esta expressão muito simples:</p>

<figure class='code'><figcaption><span>Ruby</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se uma variável x nomeada existe (Isto é, se o interpretador Ruby tem visto uma atribuição a x), então esta é uma variável de referência.
Se nenhuma variável existe, então esta é uma invocação do método x, sem argumentos.</p>

<p>A palavra <code>super</code> em Ruby é um tipo especial de invocação de método. Esta palavra é usada ao criar uma subclasse de outra
classe. Por si só, <code>super</code> passa os argumentos do método corrente para o método com o mesmo nome na superclasse. Ele também
pode ser usado como se fosse realmente o nome de um método e pode ser seguido por uma lista de argumentos arbitrários. A palavra-chave
<code>super</code> é abordada em detalhes no Aumentando Comportamento por encadeamento.</p>

<p>Até a Proxima&#8230; :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variáveis ​​não inicializadas]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas/"/>
    <updated>2012-06-02T11:30:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/02/variaveis-nao-inicializadas</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis ​​não inicializadas</p>




<h1>Variáveis ​​não inicializadas</h1>


<p>Em geral, você deve sempre atribuir um valor para, ou inicializar as variáveis ​​antes de usá-las em expressões. Em algumas circunstâncias,
no entanto, Ruby lhe permitirá utilizar variáveis ​​que ainda não foram inicializadas. As regras são diferentes para diferentes tipos de variáveis:</p>

<h4>Variáveis ​​de classe</h4>


<pre><code>Variáveis ​​de classe deve sempre ter um valor atribuído a elas antes que serem utilizadas. Ruby levanta uma NameError se 
referir a uma variável de classe à qual nenhum valor foi atribuído.
</code></pre>

<h4>Variáveis ​​de instância</h4>


<pre><code>Se você se referir a uma variável de instância não inicializada, Ruby retorna nil. Considera-se má programação de 
contar com esse comportamento, no entanto. Ruby vai emitir um aviso sobre a variável não inicializada se você executá-la 
com a opção -w.
</code></pre>

<h4>As variáveis ​​globais</h4>


<pre><code>Variáveis ​​globais não inicializadas são como o exemplo de variáveis não inicializadas: elas igualam a nil, mas mostra 
um aviso quando o Ruby é executado com o flag do -w.
</code></pre>

<h4>As variáveis ​​locais</h4>


<pre><code>Este caso é mais complicado que os outros, porque variáveis locais ​​não têm um caractere de pontuação como um prefixo. 
Este significa que variáveis ​​locais referênciam olhando apenas como uma invocação de método de expressões. Se o 
interpretador Ruby tem visto uma atribuição de uma variável local, ele sabe que é uma variável e não um método, 
e pode retornar o valor da variável. Se não tiver havido nenhuma atribuição, então o Ruby trata a expressão como uma 
invocação de método. Se nenhum método com esse nome existe, Ruby levanta um NameError.

Em geral, portanto, a tentativa de usar uma variável local antes de ter sido inicializada resulta em um erro. Existe 
uma peculiaridade, uma variável passa a existir quando o interpretador Ruby vê uma expressão de atribuição para essa 
variável. Este é o caso, mesmo se essa atribuição não é realmente executada. A variável que existe, mas não foi 
atribuído um valor, é dado o valor nulo   como padrão. Por exemplo:
</code></pre>

<figure class='code'><figcaption><span>Variaveis</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">if</span> <span class="kp">false</span> <span class="c1"># atribuição Isso nunca é executado</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">a</span> <span class="c1"># Imprime nulo: a variável existe mas não é atribuída</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">b</span> <span class="c1"># NameError: nenhuma variável ou método chamado existe b</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html">Variaveis Ruby 1.9.2</a></p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variáveis de Referência]]></title>
    <link href="http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia/"/>
    <updated>2012-06-01T13:16:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/06/01/variaveis-de-referencia</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Variáveis de Referência</p>




<h1>Variáveis de Referência</h1>


<p>Uma variável é simplesmente um nome para um valor. As variáveis ​​são criadas e os valores que lhes são atribuídos por expressões
de atribuição. Quando o nome de uma variável aparece num programa em qualquer lugar que não seja o lado esquerdo de uma atribuição, é uma
variável de referência à expressão e avaliado como o valor da variável:</p>

<figure class='code'><figcaption><span>Referência</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="c1"># Esta é uma atribuição de expressão</span>
</span><span class='line'><span class="n">one</span> <span class="c1"># Essa referência de expressão da variável, que imprimi 1.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>Existem quatro tipos de variáveis ​​em Ruby, e regras <a href="http://pt.wikipedia.org/wiki/Item_lexical">lexicais</a> para governar seus nomes. Variáveis que começam com $ são variáveis ​​globais, visível ao longo de um programa Ruby. Variáveis ​​que começam com @ e @@ são
variáveis ​​de instância e variáveis ​​de classe, usado em programação orientada a objeto. E as variáveis ​​cujos nomes começam com um sublinhado
ou uma letra minúscula são variáveis ​​locais, definidas apenas dentro do atual método ou bloco.</p>

<p>Variáveis ​​sempre são simples, nomes não qualificados. Se um . ou :: aparece em uma expressão, em seguida, que a expressão é ou um
uma referência a uma constante ou uma invocação de método. Por exemplo, Math::PI é uma referência a uma constante, e a expressão
item.preco é uma invocação do método chamado preco (preço) sobre o valor realizado pela variável item.</p>

<p>O interpretador Ruby predefine um número de variáveis ​​globais quando ele é iniciado.</p>

<p>Até a próxima.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emergencia]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/28/emergencia/"/>
    <updated>2012-05-28T13:24:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/28/emergencia</id>
    <content type="html"><![CDATA[<p>Emergencia</p>

<p>A emergencia é um dos princípios fundamentais da agilidade, e é a coisa mais próxima da magia pura. Propriedades emergenciais não são
projetadas ou vêm prontas, elas simplesmente acontecem como um resultado dinâmico do resto do sistema. “Emergencia” vem do Latim da metade
do século 17, que significa “ocorrência não prevista”. Você não pode planejá-la ou agendá-la, mas pode cultivar um ambiente em que a deixe
ocorrer, se beneficiando dela.</p>

<p>Um exemplo clássico de emergência está no comportamento dos bandos de pássaros. Uma simulação de computador pode usar apenas três regras
simples (parecidas com “não colida-se com outros”) e de repente você tem comportamento complexo quando o bando vai batendo as asas
graciosamente pelos céus, se remodelando em torno de obstáculos e assim por diante. Nenhum desses comportamentos avançados (como se
remodelar na mesma forma ao redor de obstáculos) é especificado pelas regras; eles emergem da dinâmica do sistema.</p>

<p>Regras simples, como na simulação dos pássaros, leva a comportamentos complexos. Regras complexas, como com leis tributárias na maioria
dos países, levam a comportamentos estúpidos.</p>

<p>Muitas práticas comuns de desenvolvimento de software tem o infeliz efeito-colateral de eliminar qualquer chance de comportamento emergente. A maioria das tentativas de otimização – amarrando alguma coisa muito explicitamente – reduz a extensão e escopo de interações e relacionamentos, que é a origem da emergencia. No exemplo do bando de pássaros, assim como sistemas bem-desenhados, são as interações e relacionamentos que criam os comportamentos interessantes.</p>

<p>Quanto mais amarramos as coisas, menos espaço deixamos para uma solução criativa e emergente. Seja tanto travando requisitos, antes de serem bem entendidos ou otimizando o código prematuramente, como inventando navegações e cenários de fluxo de trabalho complexas, antes de deixar o usuário final usar o sistema, o resultado é o mesmo: um sistema exageramente complicado e estúpido ao invés de um sistema limpo e elegante que aproveita a emergencia.</p>

<p>Mantenha pequeno. Mantenha simples. Deixe acontecer.</p>

<pre><code>—Andrew Hunt, The Pragmatic Programmers 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A presença de paixão]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/28/naa-presencao-de-paixao/"/>
    <updated>2012-05-28T13:13:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/28/naa-presencao-de-paixao</id>
    <content type="html"><![CDATA[<p>Como um apaixonado por codigo aberto, estou lendo o livro <a href="http://gettingreal.37signals.com/GR_por.php">&#8220;Caindo na Real&#8221;</a>, e me deparei com uma parte muito boa..</p>

<p>Então, vejam ai uma parte muito boa, só para dar um gostinho! :D</p>

<h2>A presença de paixão</h2>


<p>Em design, onde o significado é normalmente e controversamente subjetivo ou dolorosamente indecifrável, poucas coisas são mais aparentes e lúcidas do que a presença de paixão. Isso é verdade seja quando o design do produto o agrada ou o deixa frio; em ambos os casos é difícil não detectar o investimento emocional das mãos que o construíram.</p>

<p>Entusiasmo se manifesta prontamente, claro, mas indiferença é igualmente inesquecível. Se seu compromisso não vem com paixão genuína para o trabalho às mãos, isso se torna um vazio que é quase impossível de conciliar, não importa o quão elaborado ou atrativo é o design.</p>

<pre><code>—Khoi Vinh, Subtraction.com
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Literais e Palavras-Chaves Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais/"/>
    <updated>2012-05-27T12:15:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/27/literais-e-palavras-chaves-literais</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Literais e Plavras-chaves literais</p>




<h1>Literais e Plavras-chaves literais</h1>


<p>Literais são valores como 1.0, &#8220;Hello world&#8221;, e [] que são incorporados diretamente em seu texto do programa.</p>

<p>É interessante notar que muitos literais, tais como números, são as principais expressões - as expressões mais simples possíveis não
compostas de expressões simples. Literais, tais como Array e literais de hash e strings duplas citadas que usam interpolação, incluem
sub-expressões e são, portanto, expressões não primárias.</p>

<p>Determinadas palavras-chave em Ruby são expressões primárias e podem ser considerados palavras-chave literais ou formas especializadas
de referência da variável:</p>

<pre><code>nil            -&gt;   Avalia o valor nulo, de NilClass classe.
true           -&gt;   Avalia-se à instância singleton da Classe TrueClass, que um objeto representa o valor booleano 
                    verdadeiro.
false          -&gt;   Avalia-se à instância singleton da Classe FalseClass, que um objeto representa os valores booleanos
                    falsos.
self           -&gt;   Auto avalia o objeto atual.
__FILE__       -&gt;   Avalia a uma string que nomeia o arquivo que o Ruby Intérprete (IRB) está em execução. Isto pode ser
                    útil em erro de mensagens.
__LINE__       -&gt;   Avalia como um inteiro que especifica o número da linha dentro da linha do código atual do __FILE__.
__ENCODING__   -&gt;   Avalia a um objeto Encoding que especifica a codificação do arquivo atual. (Ruby 1.9 apenas.)
</code></pre>

<p>É isso ai galera, até o proximo post.. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Expressões e Operadores - O inicio]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/23/aexpressoes-e-operadores-o-inicio/"/>
    <updated>2012-05-23T07:22:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/23/aexpressoes-e-operadores-o-inicio</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://www.ruby-doc.org/core-1.9.2/">Ruby</a>, é hora de nos aprofundar falando um pouco de Expressões e Operadores</p>




<h1>Expressões e Operadores</h1>


<p>Uma expressão é um pedaço de código Ruby que o interpretador Ruby pode avaliar para produzir um valor. Aqui estão alguns exemplos
de expressões:</p>

<figure class='code'><figcaption><span>Expressões</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">2</span> <span class="c1"># Um literal numérico</span>
</span><span class='line'><span class="n">x</span> <span class="c1"># Uma referência variável local</span>
</span><span class='line'><span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># invocação Um método</span>
</span><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="no">Math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Atribuição</span>
</span><span class='line'><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="c1"># Multiplicação com o operador *</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como você pode ver, expressões primárias, tal como literais, referências variáveis, e invocações de método podem ser combinadas em
expressões maiores com operadores, tais como o operador de atribuição e o operador de multiplicação.</p>

<p>Muitas linguagens de programação diferenciam entre expressões de baixo nível e alto nível de declarações, tais como condicionais e loops.
Nestas linguagens, as declarações de controlar o fluxo de um programa, mas eles não têm valores. Eles são executados, em vez de avaliados.
Em Ruby, não há distinção clara entre as afirmações e expressões; tudo em Ruby, incluindo a definição de classe e de método, pode ser
avaliado como uma expressão e retorna um valor. É ainda útil, no entanto, diferenciam sintaxe normalmente usada como expressões de sintaxe
tipicamente usadas ​​como indicações.</p>

<p>Até mais amigos.. ainda vem muito conteudo legal com por ai.. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arranhando sua própria coceira]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/22/arranhando-sua-propria-coceira/"/>
    <updated>2012-05-22T13:21:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/22/arranhando-sua-propria-coceira</id>
    <content type="html"><![CDATA[<p>Como um apaixonado por codigo aberto, estou lendo o livro <a href="http://gettingreal.37signals.com/GR_por.php">&#8220;Caindo na Real&#8221;</a>, e me deparei com uma parte do livro The Progmatic Programmers, o proximo que irei ler.</p>

<p>Então, vejam ai uma parte muito boa, só para dar um gostinho! :D</p>

<h2>Arranhando sua proípria coceira</h2>


<p>O mundo de Código Aberto abraçou esse mantra há muito tempo – eles chamam de “arranhando sua própria coceira”. Para os desenvolvedores de código aberto, significa que terão as ferramentas que querem, entregues da maneira que querem. Mas os benefícios vão mais a fundo.</p>

<p>Como designer ou desenvolvedor de uma nova aplicação, você precisa encarar centenas de micro-decisões todos os dias: azul ou verde? Uma tabela ou duas? Estática ou dinâmica? Abortar ou recuperar? Como tomamos essas decisões? Se é algo que reconhecemos como importante, poderíamos perguntar. O resto, chutamos. E todos esses chutes constroem um tipo de débito em nossas aplicações – uma rede interconectada de coisas que assumimos.</p>

<p>Como um desenvolvedor, detesto isso. O conhecimento de todas essas bombasrelógio em pequena escala nas aplicações que escrevo somam-se ao meu stress. Desenvolvedores de código aberto, arranhando suas próprias coceiras, não sofrem isso. Porque eles são seus próprios usuários, eles sabem a resposta correta para 90% das decisões que precisam tomar. Acho que é uma das razões que as pessoas chegam em casa após um dia duro de trabalho de codificação e ainda trabalham com código aberto: é relaxante.</p>

<pre><code>— Dave Thomas, The Pragmatic Programmers
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part VI]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-vi/"/>
    <updated>2012-05-20T19:08:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-vi</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Copiando objetos</h3>


<p>A classe Object define dois métodos estreitamente relacionados para copiar objetos. Tanto o clone e como o dup retornar uma cópia
superficial do objeto em que eles são chamados. Se o objeto copiado inclui o estado interno que se refere a outros objetos, apenas as
referências a objetos são copiadas, não os próprios objetos referenciados.</p>

<p>Se o objecto a ser copiado define um método initialize_copy, em seguida, clone e dup simplesmente alocam uma nova instância vazia da
classe e chamam o método initialize_copy nesta instância vazio. O objeto a ser copiado é passado como um argumento, para este &#8220;Construtor
de cópias&#8221;, podendo inicializar a cópia. Para exemplo, o método initialize_copy pode copiar recursivamente os dados internos de um objeto
para que o objeto resultante, não sendo uma simples cópia superficial do original.</p>

<p>Classes também podem substituir os métodos clone e dup diretamente para produzir qualquer tipo de copia que eles desejam.</p>

<p>Há duas diferenças importantes entre os métodos clone e dup definidos pelo objeto. Primeiro, as cópias do clone tanto o congelado e
quanto o estado contaminado(definido em breve) de um objeto, enquanto dup apenas copia o estado contaminado, chamando dup sobre um objeto
congelado retorna uma cópia descongelada. Em segundo lugar, clone cópia quaisquer métodos singleton do objeto, enquanto que dup não.</p>

<h3>Objetos Empacotamento</h3>


<p>Você pode salvar o estado de um objeto passando para a classe <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html">Marshal</a>, com o método <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-dump">dump</a>. Se você passar um objeto de fluxo de I/O como o segundo argumento, escreve o estado do objeto Marshal.dump (e, de forma recursiva, quaisquer objetos que referencia) para esse fluxo.
Caso contrário, ele simplesmente retorna o estado codificado como uma string binária.</p>

<p>Para restaurar um objeto empacotado, passe uma string ou um fluxo de contendo I/O do objeto de <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-load">Marshal.load</a>.</p>

<p>O empacotamento de um objeto é uma maneira muito simples para salvar seu estado para uma utilização posterior, e estes métodos podem ser
usados ​​para fornecer um arquivo automático no formato de programas Ruby. Note, no entanto, que o formato binário usado por <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-dump">Marshal.dump</a> e <a href="http://www.ruby-doc.org/core-1.9.2/Marshal.html#method-c-load">Marshal.load</a> é dependente da versão, e nas mais recentes versões do Ruby não são garantidos para ser capaz de ler
objetos empacotados escritos por versões mais antigas do Ruby.</p>

<p>Outro uso para Marshal.dump e Marshal.load é criar cópias de profundidade de objetos:</p>

<figure class='code'><figcaption><span>Marshal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</span><span class='line'>  <span class="no">Marshal</span><span class="o">.</span><span class="n">load</span> <span class="p">(</span><span class="no">Marshal</span><span class="o">.</span><span class="n">dump</span> <span class="p">(</span><span class="n">o</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note que os arquivos de fluxo I/O, bem como o método e os objetos Binding, são dinâmicos demais para ser empacotado, não haveria nenhuma
maneira confiável para restaurar seu Estado.</p>

<p>YAML (&#8220;YAML não é Markup Language&#8221;) é uma alternativa comumente utilizada para o módulo Marshal que depósita objetos (e carrega objetos) a
partir de um texto com formato legível. É na biblioteca padrão, e você deve exigir usá-lo &#8216;yaml&#8217;.</p>

<h3>Objetos de congelamento</h3>


<p>Qualquer objeto pode ser congelado chamando seu método de freeze. A objeto congelado torna imutável e nenhum de seu estado interno pode
ser mudado, e uma tentativa de chamar qualquer um dos seus métodos de falha de modificadores:</p>

<figure class='code'><figcaption><span>Freeze</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;gelo&quot;</span> <span class="c1"># String são objetos mutáveis</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">freeze</span> <span class="c1"># Faça desta cadeia imutável</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">frozen?</span> <span class="c1"># Verdade: ele foi congelado</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">upcase!</span> <span class="c1"># TypeError: não pode modificar cadeia de congelados</span>
</span><span class='line'><span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;ni&quot;</span> <span class="c1"># TypeError: não pode modificar cadeia de congelados</span>
</span></code></pre></td></tr></table></div></figure>


<p>Congelar um objeto de classe impede a adição de quaisquer métodos para essa classe.</p>

<p>Você pode verificar se um objeto é congelado com o método frozen?. Uma vez congelado, não há maneira para &#8220;descongelar&#8221; um objeto. Se
você copiar um objeto congelado com clone, a cópia também será congelada. Se você copiar um objeto congelado com dup, no entanto, a
cópia não será congelada.</p>

<h3>Objetos contaminados e não confiáveis</h3>


<p>Aplicações Web deve muitas vezes acompanhar de dados de entrada, derivados de não confiáveis do usuário para evitar ataques de injeção
de SQL e riscos de segurança semelhantes. Ruby oferece uma solução simples para esse problema: qualquer objeto pode ser marcado como
contaminado, chamando seu método taint. Depois que um objeto está contaminado, qualquer objetos derivado, também será contaminado. O
taint de um objeto pode ser testado com o método tainted? método:</p>

<figure class='code'><figcaption><span>taint</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;não confiáveis&quot;</span> <span class="c1"># Os objetos são normalmente não viciada</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">taint</span> <span class="c1"># Marcar como não confiável objeto contaminado</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">tainted?</span> <span class="c1"># Verdade: ele está contaminado</span>
</span><span class='line'><span class="n">s</span><span class="o">.</span><span class="n">upcase</span><span class="o">.</span><span class="n">tainted?</span> <span class="c1"># Verdade: objetos derivados estão contaminados</span>
</span><span class='line'><span class="n">s</span><span class="o">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">].</span><span class="n">tainted?</span> <span class="c1"># Verdade: substrings estão contaminados</span>
</span></code></pre></td></tr></table></div></figure>


<p>De entrada, tais como usuário de linha de comando argumentos, ambiente de variáveis, e seqüências de leitura com gets, são automaticamente
contaminados. Quando a variavel global $SAFE é definida com um valor maior que zero, Ruby restringe vários métodos embutidos que eles não
vão trabalhar com dados adulterados. Cópias de objetos contaminados feitos com clone e dup permanecem contaminados. Um objeto contaminado
pode ser descontaminado com o método untaint. Você só deve fazer isso, claro, se você examinar o objeto e está convencido de que não apresenta riscos de segurança.</p>

<p>Em Ruby 1.9, os objectos podem não ser confiável para além de ser manchado. Os métodos untrusted?, untrust, e trust verificam e definem a
lealdade de um objeto. Código não confiável cria objetos não confiáveis, objetos contaminados e não é permitido para modificar objetos
confiáveis.</p>

<p>Boa noite amigos&#8230; até a proxima..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part V]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-v/"/>
    <updated>2012-05-20T14:04:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-v</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Conversão de objetos</h3>


<p></p>

<p>Muitas classes de Ruby definem métodos que retornam uma representação do objeto como um valor de uma classe diferente.
O método to_s, para a obtenção de uma representação de um objeto, é provavelmente o mais comumente implementado e mais conhecido
dos métodos. As subseções a seguir descrevem várias categorias de conversões.</p>

<!--more-->


<h5>Conversões explícitas</h5>


<p>As classes definem métodos de conversão explícitos para uso da aplicação de código que precisa de converter um valor para uma
outra representação. Os métodos mais comuns nesta categoria são to_s, to_i, to_f e to_a para converter a String, Integer, Float,
e array, respectivamente. Ruby 1.9 adiciona métodos to_c e to_r que se converterem ao <a href="http://ruby-doc.org/stdlib-1.9.2/libdoc/syck/rdoc/Complex.html">Complex</a> e <a href="http://ruby-doc.org/stdlib-1.9.2/libdoc/bigdecimal/rdoc/Rational.html">Rational</a>.</p>

<p>Métodos built-in normalmente não chamam esses métodos para você. Se você chamar um método que espera uma String e passar um objeto
de algum outro tipo, que o método não é esperado para converter o argumento com to_s. (Valores interpolados em aspas dupla em strings,
no entanto, são automaticamente convertidos com to_s.)</p>

<p>to_s é facilmente o mais importantes dos métodos de conversão, porque representações de seqüência de objetos são tão comumente
utilizadas em interfaces de usuário. Uma importante alternativa para to_s é o método inspect. to_s é geralmente destinados a retornar uma
representação legível do objeto, adequado para usuários finais. inspect, por outro lado, é destinados ao uso de depuração, e deve
retornar uma representação que é útil para os desenvolvedores de Ruby. O padrão do método inspect, herdado de Object, simplesmente chama
to_s.</p>

<h5>As conversões implícitas</h5>


<p>Às vezes, uma classe tem características fortes de uma outra classe. A classe Exception de Ruby representa um erro ou condição
inesperada em um programa e encapsula uma mensagem de erro. No Ruby 1.8, objetos Exception não são apenas conversível para strings,
que são strings como objetos e podem ser tratadas como se fossem strings em muitos contextos [*], Por exemplo:</p>

<figure class='code'><figcaption><span>class Exception</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.8</span>
</span><span class='line'><span class="n">e</span> <span class="o">=</span> <span class="no">Exception</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;não é realmente uma exceção&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Erro:&quot;</span> <span class="o">+</span> <span class="n">e</span> <span class="c1"># concatenação de String com uma exceção</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como os objetos de exceção são strings, eles podem ser usados ​​com a cadeia no operador de concatenação. Isso não funciona com a
maioria das outras classes de Ruby. A razão pela qual os objetos de Exceção pode se comportar como Objetos String é que, em Ruby
1.8, Exception implementa o método to_str, implícito de conversão, e o operador + definido pela String chama esse método em seu
do lado direito do operando.</p>

<p>Outros métodos de conversão implícitos são to_int para objetos que querem ser inteiro, como to_ary, para objetos que quer ser
array, e to_hash para objetos que querem ser hash. Infelizmente, as circunstâncias em que estes métodos de conversão são implícitos
chamados não são bem documentados. Entre as classes embutidas, estes métodos de conversões implícitas que normalmente não são implementadas, tampouco.</p>

<p>Observamos anteriormente, de passagem, que o operador == pode realizar um tipo fraco de tipo de conversão ao testar a igualdade.
Os operadores == definidos pelo Array, String, e Hash para ver se o operando do lado direito é da mesma classe como o operando esquerdo.
Se assim for, eles se comparam. Se não, verifica se o operando do lado direito tem um to_str, to_ary, ou método to_hash.
Eles não invocam estes métodos, mas se eles existem, eles invocam o método == do operando do lado direito e permiti que ele se decida
se é igual ao do operando esquerda.</p>

<p>No Ruby 1.9, as classes String, Array, Hash, RegExp e IO definiem tudas um método de classe chamado try_convert. Este métodos
convertem seu argumento se definido um método implícito apropriado de conversão, ou retorna contrário nil . Array.try_convert(o)
retorna o.to_ary se o método define, caso contrário, retorna nil. Estes métodos são try_convert conveniente se você quiser escrever
métodos que permitem conversões implícitas no seu argumento.</p>

<h5>Funções de conversão</h5>


<p>O módulo de Kernel define quatro métodos de conversão que se comportam como funções globais de conversão. Estas funções de array, Float,
Integer e String, têm os mesmos nomes que as classes para que se convertam, e eles são incomuns em que eles começam com uma
letra maiúscula.</p>

<p>A função Array tenta converter seu argumento para um array chamando to_ary. Se esse método é não definido ou retorna nil, ou ele tenta
o método to_a. Se to_a não está definido retorna nulo, a função Array simplesmente retorna um novo array contendo o argumento como
seu único elemento.</p>

<p>A função Float converte argumentos numéricos para objetos Float diretamente. Para qualquer valor não numérico, que chama o método to_f.</p>

<p>A função Integer converte o argumento para um Fixnum ou Bignum. Se o argumento é um valor numérico, ele é convertido diretamente. Valores
de Float são truncados e não arredondado. Se o argumento é uma string, ele procura por um indicador de radix(um condutor 0 para octal,
0x para hexadecimal, ou 0b para binário) e converte a string em conformidade. Ao contrário String.to_i não permiti caracteres não
numéricos à direita. Para qualquer outro tipo de argumento, a função Integer tenta converter primeiro com to_int e depois com to_i.</p>

<p>Finalmente, a função String converte o argumento para uma string simplesmente chamando seu método to_s.</p>

<h5>Tipo de operador Aritmético</h5>


<p>Tipos numéricos definem um método de conversão chamado <a href="http://www.ruby-doc.org/core-1.9.2/Numeric.html#method-i-coerce">coerce</a>. A intenção deste método é o de converter o argumento para o mesmo tipo como o objeto numérico no qual o método é invocado, ou
para converter ambos os objetos para algum tipo mais geralmente compatíveis. O método de coerce sempre retorna uma matriz que tem dois
valores numéricos do mesmo tipo. O primeiro elemento do array é o valor convertido do argumento para coerce. O segundo elemento do
retornado do array é o valor(convertido, se necessário) em que foi invocado coerce:</p>

<figure class='code'><figcaption><span>Coerc</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [1.0, 1.1]: coagir Fixnum para Flutuar</span>
</span><span class='line'><span class="nb">require</span> <span class="s2">&quot;rational&quot;</span> <span class="c1"># Use números racionais</span>
</span><span class='line'><span class="n">r</span> <span class="o">=</span> <span class="no">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># terceira Um como um número racional</span>
</span><span class='line'><span class="n">r</span><span class="o">.</span><span class="n">coerce</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># [Rational (2,1), Rational (1,3)]: Fixnum para Rational</span>
</span></code></pre></td></tr></table></div></figure>


<p>O método coerce é usado pelos operadores aritméticos. O operador + definido por Fixnum não sabe sobre números Rational, por exemplo, e se
o operando do lado direito é um valor rational, não se sabe como adicionar. coerce fornece a solução. Operadores numéricos são escritos
de modo que, se eles não sabem o tipo do operando do lado direito, que invocam o método coerce do operando do lado direito, passando o
operando da esquerda como um argumento. Voltando ao nosso exemplo de adição de um Fixnum e um Rational, o método coerce de Rational
retorna um array de dois valores racionais. Agora, o operador + definido por Fixnum pode simplesmente invocar + sobre os valores no array.</p>

<h5>Conversões de tipos Booleanos</h5>


<p>Valores booleanos merecem uma menção especial no contexto de conversão de tipo. Ruby é muito rigoroso com seus valores booleanos: true e
falso têm métodos to_s, que retornam &#8220;true&#8221; e &#8220;falso&#8221;, mas definem nenhum outro método de conversão. E não há nenhum método to_b
para converter os outros valores para Booleanos.</p>

<p>Em algumas Linguagens, é falsa a mesma coisa que 0, ou pode ser convertidos para 0. Em Ruby, os valores verdadeiros e falsos são os
seus próprios objetos distintos, e não existem conversões implícitas que convertem os outros valores para verdadeiro ou falso.
Esta é apenas metade da história, no entanto. Operadores booleanos de Ruby e de sua condicional e construções em loops que usam
expressões booleanas podem trabalhar com outros valores que o verdadeiro e o falso. A regra é simples: em expressões Boolean, qualquer
valor diferente de false ou nil se comporta como (mas não é convertida em) verdadeiro. nil, por outro lado se comporta como falsa.</p>

<p>Suponha que você queira testar se a variável x é nula ou não. Em algumas línguagens, você deve escrever explicitamente uma expressão
de comparação que avalia a verdadeira ou falso:</p>

<figure class='code'><figcaption><span>True ou False</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="kp">nil</span> <span class="c1">#  a expressão &quot;x! = nil&quot; retorna true ou false para o caso</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">x</span> <span class="c1"># x Imprimir se ela é definida</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Esse código funciona em Ruby, mas é mais comum simplesmente para tomar vantagem do fato de que todos os outros valores do que zero e
falso se comportam como verdadeiras:</p>

<figure class='code'><figcaption><span>True ou False</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="c1"># Se x é não-nula</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">x</span> <span class="c1"># Em seguida, imprimi-lo</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>É importante lembrar que os valores como 0, 0.0, e uma string vazia &#8220;&#8221; comportam-se como verdadeiro em Ruby, que é surpreendente se você
está acostumado a linguagens como C ou JavaScript.</p>

<p>É isso amigos&#8230;</p>

<p>Até Mais..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part IV]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-iv/"/>
    <updated>2012-05-20T13:01:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/20/classe-objects-em-ruby-1-dot-9-2-part-iv</id>
    <content type="html"><![CDATA[<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Ordem de Object</h3>


<p></p>

<p>Praticamente todas as classes podem definir o método ==, sendo útil para testar as suas instâncias para a igualdade. Algumas
classes também podem definir uma ordenação. Ou seja: para quaisquer duas instâncias de uma classe, as duas instâncias devem ser iguais,
ou uma instância deve ser &#8220;menos que&#8221; a outra. Numbers são das classes mais óbvias para que tal ordenação seja definido.
String são também ordena, de acordo com o numéro de ordenação dos códigos de caracteres que compõem as strings. Se uma classe define
uns casos de pedido, em seguida, a classe pode ser comparada e classificada.</p>

<!--more-->


<p>Em Ruby, classes definem um ordenação através da implementação do operador &lt;=>. Este operador deve retornar -1 se o operando da esquerda
é menor que o operando da direita, 0 se os dois operandos são iguais, e 1 se o operando esquerdo é maior que o operando direito.
Se os dois operandos não podem ser  significativamente comparados (se o operando direito é de uma classe diferente, por exemplo),
em seguida, o operador deve retornar nil:</p>

<figure class='code'><figcaption><span>Operador <=></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span> <span class="c1"># -1</span>
</span><span class='line'><span class="mi">5</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span> <span class="c1"># 0</span>
</span><span class='line'><span class="mi">9</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span> <span class="c1"># 1</span>
</span><span class='line'><span class="s2">&quot;1&quot;</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span> <span class="c1"># nil: inteiros e strings não são comparáveis</span>
</span></code></pre></td></tr></table></div></figure>


<p>O operador &lt;=> é tudo que é necessário para comparar os valores. Mas não é particularmente intuitivo. Assim, as classes que definem
este operador tipicamente também incluir o Módulo <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> como um mixin.
(Módulos e mixins são abordados em Módulos como Mixins). O mixin Comparable define o seguinte operador em termos de &lt;=>:</p>

<pre><code>&lt;   -   Menor que
&lt;=  -   Menor ou igual
==  -   Igual
&gt;=  -   Maior ou igual
&gt;   -   Maior que
</code></pre>

<p><a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> não define o operador !=; o Ruby automaticamente define o
operador como a negação do operador ==. Além destes operadores de comparação, <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> também define um método útil de comparação com o between? :</p>

<figure class='code'><figcaption><span>Comparable between?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">between?</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># verdadeiro: 0 &lt;= 1 &lt;= 10</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se o operador &lt;=> retornar nil, todos os operadores de comparação dele derivados retornam falso. O especial Float com valor NaN é um exemplo:</p>

<figure class='code'><figcaption><span>Float NaN</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">nan</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1"># zero dividido por zero não é um número</span>
</span><span class='line'><span class="n">nan</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="c1"># false: não é menor que zero</span>
</span><span class='line'><span class="n">nan</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="c1"># false: não é maior que zero</span>
</span><span class='line'><span class="n">nan</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1"># false: não é igual a zero</span>
</span><span class='line'><span class="n">nan</span> <span class="o">==</span> <span class="n">nan</span> <span class="c1"># false: não é mesmo igual a si mesmo!</span>
</span><span class='line'><span class="n">nan</span><span class="o">.</span><span class="n">equal?</span><span class="p">(</span><span class="n">nan</span><span class="p">)</span> <span class="c1"># isso é verdade, claro</span>
</span></code></pre></td></tr></table></div></figure>


<p>Observe que a definição de &lt;=> e incluindo o módulo <a href="http://ruby-doc.org/core-1.9.2/Comparable.html">Comparable</a> define um operador == para o sua classe. Algumas classes que definem o seu próprio operador ==, normalmente quando eles podem
implementar esta forma mais eficiente do que um teste de igualdade com base no operador &lt;=>. É possível definir classes que
implementam diferentes noções de igualdade em seus operadores == e &lt;=>. Uma classe pode fazer comparações de string case-sensitive
para o operador ==, por exemplo, mas, em seguida, fazem comparações de maiúsculos e minúsculos com &lt;=>, de modo que as instâncias da classe
se classificam com mais naturalidade. Em geral, porém, é melhor se &lt;=> retorna 0 se e somente se == retorna true.</p>

<p>É isso amigos&#8230; o proximo post vamos conversar um pouco de Conversões de Object&#8217;s.</p>

<p>Até Mais..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part III]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-iii/"/>
    <updated>2012-05-19T16:58:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-iii</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Igualdade objeto</h3>


<p>Ruby tem um número surpreendente de maneiras de comparar objetos para igualdade, e é importante entender como eles funcionam, assim você sabe quando usar cada método.</p>

<!--more-->




<h3>O método equal? </h3>


<p>O método equal? é definido pelo objeto para testar se os dois valores referem-se exatamente o mesmo objeto. Para qualquer dos dois
distintos objetos, esse método sempre retorna false:</p>

<figure class='code'><figcaption><span>equal?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># Uma referência a um objeto String</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># Duas referências a outro objeto String</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">equal?</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># falsa: a e b são objetos diferentes</span>
</span><span class='line'><span class="n">b</span><span class="o">.</span><span class="n">equal?</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1"># verdadeiro: b e c referem-se ao mesmo objeto</span>
</span></code></pre></td></tr></table></div></figure>


<p>Por convenção, nunca subclasses substituem o método equal?.</p>

<p>Outra maneira de determinar se os dois objetos são, de fato, do mesmo objetivo é verificar a sua object_id:</p>

<figure class='code'><figcaption><span>equal?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">object_id</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">object_id</span> <span class="c1"># Funciona como a.equal? ​​(b)</span>
</span></code></pre></td></tr></table></div></figure>




<h3>O operador ==</h3>


<p>O operador == é a forma mais comum para testar a igualdade. Na Classe Object, é simplesmente uns testes de sinónimos para equal?, e
se duas referências de objeto são idênticos. A maioria das classes redefinem este operador para permitir instâncias distintas para ser
testado para igualdade:</p>

<figure class='code'><figcaption><span>Operador ==</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># uma string</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># Um objeto String diferente com o mesmo conteúdo</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">equal?</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># falsa: a e b não se referem ao mesmo objeto</span>
</span><span class='line'><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="c1"># verdade: mas estes dois objetos distintos têm valores iguais</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note que o único sinal de igual nesse código é o operador de atribuição. Leva dois sinais de igual para testar a igualdade
em Ruby (esta é uma convenção que compartilha Ruby com muitas outras linguagens de programação).</p>

<p>Padrão de Classes do Ruby definem o operador == para implementar uma razoável definição de igualdade. Isso inclui Array
e as classes de hash. Dois Arrays são iguais de acordo com == se tiverem o mesmo número de elementos,
e se os seus elementos correspondentes são todos iguais de acordo com ==. Dois hashes são == se contiverem o mesmo número de pares
chave/valor, e se as chaves e valores são, eles próprios iguais. (Os valores são comparados com o operador ==,
mas chaves de hash são comparados com o método eql?.)</p>

<pre><code>Igualdade para programadores Java

Se você é um programador Java, você está acostumado a usar o operador == para testar se dois objetos são
o mesmo objeto, e você está acostumado a usar o método equals para testar se dois objetos distintos têm o mesmo valor. 
Convenção do Ruby é apenas sobre o oposto de Java.
</code></pre>

<p>As classes numéricas realizam conversões de tipo simples nas suas operações de ==, de modo que (por exemplo) o
Fixnum 1 e o Float 1.0 comparados como iguais. O operador == de classes, como String e Array, normalmente requerem dois operandos
para ser da mesma classe. Se o operando do lado direito define uma to_str ou função de conversão to_ary, então estes operadores invocam
o operador == definido pelo lado direito operando, e deixam que objeto decidem se é igual ao lado esquerdo, sendo string ou array.
Assim, é possível (embora não comum) para definir classes com comportamento comparação de string ou array.</p>

<p>!= (&#8220;Não-igual&#8221;) é usado em Ruby para testar a desigualdade. Quando o Ruby vê !=, Ele simplesmente usa o operador == e depois
inverte o resultado. Isto significa que uma única classe precisa definir o operador == para definir a sua própria noção de
igualdade. Ruby dá o operador != de graça. No Ruby 1.9, no entanto, as classes podem explicitamente definir os seus próprios operadores !=.</p>

<h3>O método eql?</h3>


<p>O método eql? é definido pelo objeto como um sinônimo para equal?. Classes que se sobrepõem a ele normalmente usá ele como uma
versão rígida do operador == que não faz nenhum tipo de conversão. Por exemplo:</p>

<figure class='code'><figcaption><span>eql?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="c1"># verdade: Fixnum e objetos flutuantes podem ser ==</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">eql</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># falsa: mas eles nunca são eql!</span>
</span></code></pre></td></tr></table></div></figure>


<p>A classe Hash usa eql? para verificar se duas chaves de hash são iguais. Se dois objetos são eql?, os métodos de hash também
deve retornar o mesmo valor. Normalmente, se você criar uma classe e defini o operador ==, você pode simplesmente escrever um
método de hash e definir eql? para usar ==.</p>

<h3>O operador ===</h3>


<p>O operador === é comumente chamado de &#8220;caso de igualdade&#8221; e é usado para testar se o valor-alvo de uma declaração caso corresponde
a qualquer das cláusulas, quando dessa declaração.</p>

<p>Classe Object define por padrão o operador === para que ele chama o operador ==. Para muitas classes, por conseguinte, a igualdade
caso é o mesmo que == (igualdade). Mas certas classes principais definem === de maneira diferente, e nestes casos, é mais de um membro
ou operador correspondente. Range define === para testar se um valor está dentro do intervalo. Regexp define === para testar se uma
string corresponde à expressão regular. E Class define === para testar se um objeto é uma instância dessa Class. No Ruby 1.9, Symbol
define === retornando true se o operando do lado direito é o mesmo símbolo como o esquerda ou se é uma cadeia guardando o mesmo texto.
Exemplos:</p>

<figure class='code'><figcaption><span>Operador ===</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span> <span class="o">===</span> <span class="mi">5</span> <span class="c1"># verdadeiro: 5 está na gama de 1 .. 10</span>
</span><span class='line'><span class="sr">/\d+/</span> <span class="o">===</span> <span class="s2">&quot;123&quot;</span> <span class="c1"># verdade: a seqüência corresponde à expressão regular</span>
</span><span class='line'><span class="nb">String</span> <span class="o">===</span> <span class="s2">&quot;s&quot;</span> <span class="c1"># verdade: &quot;s&quot; é uma instância da classe String</span>
</span><span class='line'><span class="ss">:s</span> <span class="o">===</span> <span class="s2">&quot;s&quot;</span> <span class="c1"># verdadeiro no Ruby 1.9</span>
</span></code></pre></td></tr></table></div></figure>


<p>É raro ver o operador === usado explicitamente como este. Mais comumente, a sua utilização é simplesmente implícita em uma instrução case.</p>

<h3>O operador =~</h3>


<p>O operador =~ é definido pela String e Regexp (e Symbol no Ruby 1.9) para realizar ligações de padrões, e isso não é realmente um
operador de igualdade em tudo. Mas isso não tem um sinal de igual na mesma, de modo que ele está aqui para ser completo.
Objeto define uma versão sem o operador de =~, que sempre retorna false. Você pode definir este operador em sua própria classe,
se essa classe define um tipo de correspondência de operação padrão ou tem uma noção de igualdade aproximada, por exemplo.
!~ é definido como o inverso da =~. É definível em Ruby 1.9 mas não no Ruby 1.8</p>

<p>É isso ai rubistas&#8230; Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part II]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-ii/"/>
    <updated>2012-05-19T13:14:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2-part-ii</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>




<h3>Identidade do objeto</h3>


<p>Cada objeto tem um identificador de objeto, um Fixnum, que você pode obter com o método object_id. O valor retornado por este
método é constante e exclusivo para a vida útil do objeto. Enquanto o objeto é acessível, ele terá sempre a mesma identificação, e não
outro objeto que irá partilhar do mesmo ID.</p>

<p>O ID de método é um sinônimo preterido para object_id. Ruby 1.8 emite um aviso se você usá-lo, e ele foi removido em
Ruby 1.9.</p>

<p><strong>id</strong> é um sinônimo válido para object_id. Ele existe como um retorno, assim você pode acessar ID de um objeto, mesmo se o método
object_id foi indefinido ou substituído.</p>

<p>A classe <a href="http://ruby-doc.org/core-1.9.3/Object.html">Object</a> implementa o método de hash para simplesmente retornar um
ID objeto.</p>

<!--more-->




<h3>Classe de Objeto e Tipo de Objeto</h3>


<p>Existem várias maneiras de determinar a classe de um objeto em Ruby. O mais simples é simplesmente perguntar para ele:</p>

<figure class='code'><figcaption><span>Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span> <span class="o">=</span> <span class="s2">&quot;teste&quot;</span> <span class="c1"># Este é um valor</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">class</span> <span class="c1"># Retorna um objeto que representa a classe String</span>
</span></code></pre></td></tr></table></div></figure>


<p>Se você estiver interessado na hierarquia de classe de um objeto, você pode perguntar para qualquer classe qual é sua superclasse:</p>

<figure class='code'><figcaption><span>Class - Ruby 1.8</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">class</span> <span class="c1"># String: o é um objeto String</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span> <span class="c1"># Object: superclasse de String é objeto</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span> <span class="c1"># nil: Object não tem superclasse</span>
</span></code></pre></td></tr></table></div></figure>


<p>No Ruby 1.9, Object já não é a verdadeira raiz da hierarquia de classes:</p>

<figure class='code'><figcaption><span>Class - Ruby 1.9</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9</span>
</span><span class='line'><span class="no">Object</span><span class="o">.</span><span class="n">superclass</span> <span class="c1"># BasicObject: Object tem uma superclasse em 1.9</span>
</span><span class='line'><span class="no">BasicObject</span><span class="o">.</span><span class="n">superclass</span> <span class="c1"># nil: BasicObject não tem nenhuma superclasse</span>
</span></code></pre></td></tr></table></div></figure>


<p>Assim, uma forma particularmente simples para verificar a classe de um objeto é, por comparação direta:</p>

<figure class='code'><figcaption><span>Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">class</span> <span class="o">==</span> <span class="nb">String</span> <span class="c1"># true se o é uma String</span>
</span></code></pre></td></tr></table></div></figure>


<p>O método instance_of? faz a mesma coisa e é um pouco mais elegante:</p>

<figure class='code'><figcaption><span>Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">instance_of?</span> <span class="nb">String</span> <span class="c1"># verdade se o é uma String</span>
</span></code></pre></td></tr></table></div></figure>


<p>Normalmente, quando testamos a classe de um objeto, também gostaríamos saber se o objeto é uma instância de qualquer subclasse
dessa classe. Para testar isso, use o método is_a?, ou seu sinônimo kind_of?</p>

<figure class='code'><figcaption><span>Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Este é o valor que estamos trabalhando com</span>
</span><span class='line'><span class="n">x</span><span class="o">.</span><span class="n">instance_of?</span> <span class="no">Fixnum</span> <span class="c1"># verdade: é uma instância de Fixnum</span>
</span><span class='line'><span class="n">x</span><span class="o">.</span><span class="n">instance_of?</span> <span class="no">Numeric</span> <span class="c1"># false: instance_of? não verifica a herança</span>
</span><span class='line'><span class="n">x</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Fixnum</span> <span class="c1"># verdadeiro: x é um Fixnum</span>
</span><span class='line'><span class="n">x</span><span class="o">.</span><span class="n">is_a?</span> <span class="nb">Integer</span> <span class="c1"># verdade: x é um número inteiro</span>
</span><span class='line'><span class="n">x</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Numeric</span> <span class="c1"># verdade: x é um numérico</span>
</span><span class='line'><span class="n">x</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Comparable</span> <span class="c1"># verdade: funciona também com módulos mixin</span>
</span><span class='line'><span class="n">x</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Object</span> <span class="c1"># verdadeira para qualquer valor de x</span>
</span></code></pre></td></tr></table></div></figure>


<p>A classe Class define o operador === em tal modo que ele pode ser usado no lugar do is_a?:</p>

<figure class='code'><figcaption><span>Class method ===</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Numeric</span> <span class="o">===</span> <span class="n">x</span> <span class="c1"># verdade: x is_a Numérico</span>
</span></code></pre></td></tr></table></div></figure>


<p>Essa expressão é exclusivo para Ruby e é, provavelmente, menos legível do que utilizando o mais tradicional método is_a?.</p>

<p>Cada objeto tem uma classe bem definida em Ruby, e que a classe nunca muda durante a vida útil do objeto. Um objeto
type, por outro lado, é mais fluido. O tipo de um objeto está relacionada à sua classe, mas a classe é apenas parte de um
tipo de objeto. Quando falamos sobre o tipo de um objeto, nós entendemos o conjunto de comportamentos que caracterizam o objeto.
Outra maneira é colocar o tipo de um objeto em um conjunto de métodos que podem responder.
(Esta definição torna-se recursiva, porque não é apenas o nome dos métodos que importam, mas também os tipos de argumentos que os
métodos podem aceitar.)</p>

<p>Na programação com Ruby, que muitas vezes não se preocupam com a classe de um objeto, nós só queremos saber se podemos invocar
algum método nele.  Considere-se, por exemplo, o operador &lt;&lt;. Arrays, strings, files e outros I/O relacionados ao definir as classes
isso como um operador de acréscimo. Se estamos escrevendo um método que produz produção textual, podemos escrever, genericamente,
a usar esse operador. Então, o nosso método pode ser invocado com qualquer argumento que implementa &lt;&lt;. Nós não nos importamos com a
classe do argumento, basta que possamos anexá-lo. Nós podemos testar para isto com o método respond_to? :</p>

<figure class='code'><figcaption><span>Class respond_to?</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">respond_to?</span> <span class="ss">:&quot;&lt;&lt;&quot;</span> <span class="c1"># Verdadeiro se o operador tem uma &lt;&lt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>A deficiência desta abordagem é que ela só verifica o nome de um método, não os argumentos para esse método. Por exemplo,
Fixnum e Bignum implementam &lt;&lt; como um operador de deslocamento à esquerda e espera o argumento de ser um número em vez de uma string.
Objetos inteiros parecem ser &#8220;appendable&#8221; (adicionável) quando usamos um respond_to? de teste, mas que produzem um erro quando
adiciona um código em string. Não há uma solução geral para este problema, mas um recurso ad-hoc, neste caso,
é explicitamente excluir objectos numéricos com o método is_a? :</p>

<figure class='code'><figcaption><span>Class</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">respond_to?</span> <span class="ss">:&quot;&lt;&lt;&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Numeric</span>
</span></code></pre></td></tr></table></div></figure>


<p>Outro exemplo do tipo distinção-versus-classe é a classe StringIO<a href="partir%20da%20Biblioteca%20padrão%20do%20Ruby">*</a>. StringIO permite a
leitura e gravação das strings como se fossem Objetos de IO. StringIO[*] imita os objetos IO API-StringIO definem os mesmos métodos
que os objetos IO fazem. Mas StringIO não é uma subclasse de IO. Se você escrever um método que espera um argumento de fluxo,
e testa a classe do argumento com is_a? IO, em seguida, o método não funciona com argumentos StringIO.</p>

<p>[*] -> <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/stringio/rdoc/StringIO.html">StringIO</a></p>

<p>É isso ai rubistas&#8230; A cada vez que leio sobre, me apaixono mais. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classe Objects em Ruby 1.9.2 - Part I]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2/"/>
    <updated>2012-05-19T10:23:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de <a href="http://ruby-doc.org/core-1.9.3/Object.html">Objects</a>, é hora de nos aprofundar.</p>




<h1>Objetos</h1>


<p>Ruby é uma forma muito pura de linguagem orientada a objetos: todos os valores são
objetos, e não há distinção entre tipos primitivos e tipos de objetos, como existem em muitos
outras línguas. Em Ruby, todos os objetos herdam de uma classe chamada
<a href="http://ruby-doc.org/core-1.9.3/Object.html">Object</a> e compartilhar os métodos definidos
por essa classe. Esta seção explica as características comuns de todos os objetos
em Ruby. Teremos algumas partes para falar desta classe tão poderosa, mas é muito importante para o entendimento de OO em Ruby.</p>

<!--more-->


<h3>Referências de objeto</h3>


<p>Quando trabalhamos com objetos em Ruby, realmente estamos trabalhando com referências a objetos. Não é o
próprio objeto que manipula, mas uma referência a ele<a href="http://rrmartins.github.com/blog/2012/05/19/classe-objects-em-ruby-1-dot-9-2/#referencia">[*]</a>.
Quando atribuir um valor a uma variável, não estamos copiando um objeto &#8220;em&#8221; variável que, nós
São apenas armazenar uma referência a um objeto para essa variável. Alguns
código deixa isso claro:</p>

<figure class='code'><figcaption><span>Objects</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Ruby&quot;</span> <span class="c1"># Criar um objeto String. Armazenar uma referência a ele em s.</span>
</span><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="n">s</span> <span class="c1"># Copiar a referência a t. s e t referem-se ambos para o mesmo objeto.</span>
</span><span class='line'><span class="n">t</span><span class="o">[-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="c1"># Modificar o objeto através da referência t.</span>
</span><span class='line'><span class="nb">print</span> <span class="n">s</span> <span class="c1"># Acesse o objeto modificado através de s. Prints &quot;Esfregue&quot;.</span>
</span><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;Java&quot;</span> <span class="c1"># t agora se refere a um objeto diferente.</span>
</span><span class='line'><span class="nb">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="c1"># Imprime &quot;RubJava&quot;.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Quando você passar um objeto para um método em Ruby, é um objeto
referência que é passado para o método. Não é o objeto em si,
e não é uma referência para a referência ao objecto. Outra forma
dizer isso é que os argumentos do método são passados ​​por
valor e não por referência, mas
que os valores passados ​​são referências de objeto.</p>

<p>Porque as referências de objeto são passados ​​para os métodos, os métodos podem usar
essas referências para modificar o objeto subjacente. Essas modificações
são, então, visível quando o método retorna.</p>

<h3>Valores imediatos</h3>


<p>Nós dissemos que todos os valores em Ruby são objetos e todos os objetos
são manipulados por referência. Na implementação de referência, no entanto objetos Fixnum e Symbol são realmente &#8220;valores imediatos&#8221;,
em vez de referências. Nenhuma destas duas classes tem métodos diferenciados, de modo que os
Objetos Fixnum e símbolo são imutáveis, o que significa que não há realmente nenhuma maneira de dizer que eles são manipulados por
valor, e não pela existência de valores de referencia.</p>

<p>A existência de valores imediatos deve ser considerado um detalhe de implementação. A única diferença prática entre
valores imediatos e valores de referência é que os valores imediatos
não pode ter métodos singleton definidas sobre eles.</p>

<h3>Vida útil de objeto</h3>


<p>As classes internas em Ruby descritas neste capítulo têm sintaxes literal e instâncias dessas classes são criadas simplesmente por
inclusão de valores literalmente em seu código. Objetos de outras classes precisam ser explicitamente criados,
e isso é feito na maioria das vezes com um método chamado de new:</p>

<figure class='code'><figcaption><span>Class.new</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">myObject</span> <span class="o">=</span> <span class="no">MyClass</span><span class="o">.</span><span class="n">New</span>
</span></code></pre></td></tr></table></div></figure>


<p>new é um método do Classe Class. Atribui na memória para manter o objeto new, então ele inicializa o estado do
recém alocados objetos &#8220;vazio&#8221;, invocando seu método initialize. Os argumentos para new são passadas diretamente para inicializar.
A maioria das classes definem um método initialize para executar qualquer inicialização, sendo necessário para instâncias.</p>

<p>Os métodos new e initialize fornecer o padrão técnico para a criação de novas classes, mas classes também podem definir outros
métodos, conhecidos como &#8220;métodos de fábrica&#8221;, que retornam instâncias.</p>

<p>Objetos Ruby não precisa ser desalocada explicitamente, como o fazem as linguagens C, C++, entre outras. Ruby usa uma técnica chamada
<a href="http://www.rubyinside.com.br/como-o-ruby-gerencia-memoria-e-faz-garbage-collection-3018">garbage collection</a> (coleta de lixo) automaticamente, para destruir objetos que não são mais necessários. Um objeto se torna um candidato para o garbage collection quando é
inacessível, quando não há referências restantes para o objeto com exceção de outros objetos inacessíveis.</p>

<p>O fato de que Ruby usa garbage collection, isso significa que programas em Ruby são menos suscetíveis a vazamentos de memória
que os programas escritos em linguagems que requerem objetos e memória para ser desalocada explicitamente e liberado.
Mas o garbage collection não significa que vazamentos de memória são impossíveis:
qualquer código que cria vida longa tem referências a objetos que de outro modo seria de curta duração pode ser uma fonte de
falhas de memória. Considere um hash usado como um cache. Se o cache não é podado usando algum tipo de algoritmo
menos utilizado recentemente, os objetos em cache permanecem acessíveis enquanto o hash em si é alcançável. Se o hash
é referenciado por uma variável global, então será acessível como desde que o interpretador Ruby está sendo executado.</p>

<p><a href="referencia"></a></p>

<pre><code>[*] -&gt; Se você está familiarizado com C ou C++, você pode pensar de uma
referência como um ponteiro: o endereço do objeto na memória. Ruby
não utiliza ponteiros, no entanto. Referências em Ruby são opacas e
internas para a implementação. Não há maneira de tirar o
tratamento de um valor não referenciado, um valor, ou fazer ponteiro aritmético.
</code></pre>

<p>Um pouco de conceito de Objetos, logo teremos mais na pratica&#8230;</p>

<p>Até a proxima</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[True, False e Nil]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/18/true/"/>
    <updated>2012-05-18T12:58:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/18/true</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de True, False e Nil, é hora de nos aprofundar.</p>




<h2>True, False e Nil</h2>


<p>Ruby tem alguma das palavras-chave, as palavras: True, False e nil(nulo). True e False são os dois valores booleanos, e eles
representar a verdade e a falsidade, sim e não, ligado e desligado, de um objeto. nil é um valor especial reservado para indicar
a ausência de valor.</p>

<p>Cada uma dessas palavras-chave avaliada como um objeto especial. True avalia a um objeto que é uma instância de <a href="http://ruby-doc.org/stdlib-1.9.2/libdoc/singleton/rdoc/Singleton.html">Singleton</a> de TrueClass. Da mesma forma, False e nil são exemplos de FalseClass e NilClass. Note que não há nenhuma classe Boolean em Ruby. TrueClass e False Class ambos têm como objeto de sua superclasse.</p>

<p>Se você quiser verificar se um valor é nulo, você pode simplesmente compará-lo a nil, ou usar o método nil?</p>

<figure class='code'><figcaption><span>NilClass</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span> <span class="o">==</span> <span class="kp">nil</span> <span class="c1"># o é nil</span>
</span><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">nil?</span> <span class="c1"># Outra maneira de testar</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note que True, False e nil se referem a objetos, e não números. False e nil não são a mesma coisa que 0, e True
não é a mesma coisa que 1. Quando o Ruby exige um valor booleano, nil se comporta como False e qualquer valor diferente de
nil ou False se comporta como True.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Symbols - Ruby 1.9.2]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/16/symbols-ruby-1-dot-9-2/"/>
    <updated>2012-05-16T21:37:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/16/symbols-ruby-1-dot-9-2</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de Symbol, é hora de nos aprofundar.</p>




<h2>Symbol</h2>


<p>Uma implementação típica de um interpretador Ruby mantém um símbolo em tabela
que ele armazena os nomes de todas as classes, métodos e variáveis ​​que ele conhece.
Isso permite que tal intérprete evite mais comparações de string: refere-se a nomes de métodos (por exemplo) pelo sua
posição na presente tabela de símbolos. Isso transforma uma string relativamente pesada em uma certa operação, e relativamente leve com operação de números inteiro.</p>

<!--more-->


<p>Esses símbolos não são puramente interno para o intérprete, pois eles podem também ser usado por
programas Ruby. Um objeto de Symbol refere-se a um símbolo. Um símbolo literal é escrito prefixando um identificador ou uma string com um
dois pontos:</p>

<figure class='code'><figcaption><span>Symbol</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">:symbol</span> <span class="c1"># Symbol Um literal</span>
</span><span class='line'><span class="ss">:&quot;symbol&quot;</span> <span class="c1"># O mesmo literal</span>
</span><span class='line'><span class="ss">:&#39;another long symbol&#39;</span> <span class="s2">&quot;# são úteis para símbolos com espaços</span>
</span><span class='line'><span class="s2">s = &quot;</span><span class="n">string</span><span class="s2">&quot;</span>
</span><span class='line'><span class="s2">sym = :&quot;</span><span class="c1">#{s}&quot; # O Symbol :string</span>
</span></code></pre></td></tr></table></div></figure>


<p>Símbolos têm também uma sintaxe literal %s que permite delimitadores arbitrários da mesma maneira
que %q e %Q pode ser usado para strings:</p>

<figure class='code'><figcaption><span>Symbol</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sx">%s[&quot;]</span> <span class="c1"># O mesmo que: &#39;&quot;&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Os símbolos são usados ​​frequentemente para se referir a nomes de métodos no reflexivo
código. Por exemplo, suponha que queremos para saber se algum objeto tem um método each:</p>

<figure class='code'><figcaption><span>Symbol</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">o</span><span class="o">.</span><span class="n">respond_to?</span> <span class="ss">:each</span>
</span></code></pre></td></tr></table></div></figure>


<p>Aqui está outro exemplo. Ele testa se um determinado objeto responde a um método especificado, e, em caso afirmativo, invoca o método:</p>

<figure class='code'><figcaption><span>Symbol</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">nome</span> <span class="o">=</span> <span class="ss">:size</span>
</span><span class='line'><span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">respond_to?</span> <span class="n">nome</span>
</span><span class='line'>  <span class="n">o</span><span class="o">.</span><span class="n">send</span> <span class="p">(</span><span class="n">nome</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Você pode converter uma String para um Symbol utilizando os métodos intern ou to_sym. E você pode converter um Symbol de volta para uma String com o método to_s ou sue alias id2name:</p>

<figure class='code'><figcaption><span>Symbol</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">str</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span> <span class="c1"># Comece com uma string</span>
</span><span class='line'><span class="n">sym</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="n">intern</span>  <span class="c1"># Converter para um símbolo</span>
</span><span class='line'><span class="n">sym</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="n">to_sym</span> <span class="c1"># Outra maneira de fazer a mesma coisa</span>
</span><span class='line'><span class="n">str</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">to_s</span> <span class="c1"># converter de volta para uma string</span>
</span><span class='line'><span class="n">str</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">id2name</span> <span class="c1"># Outra maneira de fazê-lo</span>
</span></code></pre></td></tr></table></div></figure>


<p>Duas seqüências podem ter o mesmo conteúdo e ainda ser completamente de objetos distintos. Este nunca é o caso com símbolos.
Duas strings com o mesmo conteúdo irá tanto converter para exatamente o mesmo objeto symbol. Dois objetos distintos Symbols terá sempre conteúdo diferente.</p>

<p>Sempre que você escrever código que usa string não para o seu conteúdo textual,
mas como uma espécie de identificador único, considere o uso de symbols em vez disso.
Ao invés de escrever um método que espera um argumento para ser ou a string de &#8220;AM&#8221; ou &#8220;PM&#8221;, por exemplo, você poderia escrevê-lo para
esperar o símbolo :AM ou o símbolo :PM. Comparando-se dois objetos Symbols de igualdade, é muito mais rápido
de comparar duas strings para a igualdade. Por esta razão, os símbolos são geralmente preferido para strings como chaves de hash.</p>

<p>No Ruby 1.9, a classe símbolo define um número de métodos String, como length, o size, os operadores de comparação, e mesmo os operadores
[] e =~. Isto faz com que os símbolos sejam um pouco permutável com string e permite a sua utilização como uma espécie de imutável
(E não garbage-collected) string.</p>

<p>É isso ai amigos até a proxima.. :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testando Associações em Range - Part II]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/15/testando-associacoes-em-range/"/>
    <updated>2012-05-15T21:49:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/15/testando-associacoes-em-range</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos continuar falando de Range, é hora de nos aprofundar.</p>




<h2>Teste Associação em um intervalo</h2>


<p>A classe Range define métodos para determinar se um valor arbitrário é um membro de (isto é, está incluído no) um Range. Antes de entrar em
detalhes sobre estes métodos, é necessário explicar que associaçãoem range pode ser definido de duas maneiras diferentes que estão relacionadas com a diferença entre os intervalos contínuos e discretos. Um valor x é um membro do range entre begin..end pela primeira definição se:</p>

<figure class='code'><figcaption><span>Range</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">begin</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>E X é um membro do range begin&#8230;end (com três pontos), se:</p>

<figure class='code'><figcaption><span>Range</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">begin</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Todos os valores de ponto de extremidade deve implementar o operador &lt;=>, assim que esta definição de associação funciona para qualquer objeto Range e não requer um ponto final para implementar o método succ. Esse é o teste de associação contínua.</p>

<p>A segunda definição de filiação discreta independe succ. Ele trata um intervalo begin..end como um conjunto que inclui begin, begin.succ, begin.succ.succ, e assim por diante. Por esta definição, a associação do Range é ajustada a associação, e um valor de x está incluído numa range apenas se for um valor retornado por uma das invocações de succ. Observe que os testes de associação discreta é potencialmente
uma operação muito mais cara do que os testes de associação contínua.</p>

<p>Com isso de fundo, podemos descrever os métodos de distribuição para testar a associação. Ruby 1.8 suporta dois métodos, include?
e member?. Eles são sinônimos, e ambos usam a associação contínua, teste:</p>

<figure class='code'><figcaption><span>Range</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="mi">100</span> <span class="c1"># O intervalo de números inteiros de 0 a 99</span>
</span><span class='line'><span class="n">r</span><span class="o">.</span><span class="n">member?</span> <span class="mi">50</span> <span class="c1"># =&gt; verdadeira: 50 é um membro da range</span>
</span><span class='line'><span class="n">r</span><span class="o">.</span><span class="n">include?</span> <span class="mi">100</span> <span class="c1"># =&gt; falso: 100 está excluída a partir do intervalo</span>
</span><span class='line'><span class="n">r</span><span class="o">.</span><span class="n">include?</span> <span class="mi">99</span><span class="o">.</span><span class="mi">9</span> <span class="c1"># =&gt; verdadeira: 99,9 é inferior a 100</span>
</span></code></pre></td></tr></table></div></figure>


<p>A situação é diferente no Ruby 1.9. Essa versão da linguagem introduz um novo método, cover?, que
funciona como include? e member? do Ruby 1.8, ele sempre usa o teste de associação contínua.
include? e member? ainda são sinônimos no Ruby 1.9. Se os pontos finais do intervalo são números, estes métodos utilizam o
teste de associação contínua, assim como eles fizeram no Ruby 1.8. Se os desfechos não são numéricas, no entanto, eles ao invés de
usar o teste de associação discreta. Podemos ilustrar estas mudanças com um Range discreto de Srintgs (você pode querer usar ri entender como String.succ funciona):</p>

<figure class='code'><figcaption><span>ri String.succ</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">=</span> <span class="nb">String</span><span class="o">.</span><span class="n">succ</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="n">from</span> <span class="n">ruby</span> <span class="n">site</span><span class="p">)</span>
</span><span class='line'><span class="o">------------------------------------------------------------------------------</span>
</span><span class='line'>  <span class="n">str</span><span class="o">.</span><span class="n">succ</span>   <span class="o">-&gt;</span> <span class="n">new_str</span>
</span><span class='line'>  <span class="n">str</span><span class="o">.</span><span class="n">next</span>   <span class="o">-&gt;</span> <span class="n">new_str</span>
</span><span class='line'>
</span><span class='line'><span class="o">------------------------------------------------------------------------------</span>
</span><span class='line'>
</span><span class='line'><span class="no">Returns</span> <span class="n">the</span> <span class="n">successor</span> <span class="n">to</span> <span class="n">str</span><span class="o">.</span> <span class="no">The</span> <span class="n">successor</span> <span class="n">is</span> <span class="n">calculated</span> <span class="n">by</span>
</span><span class='line'><span class="n">incrementing</span> <span class="n">characters</span> <span class="n">starting</span> <span class="n">from</span> <span class="n">the</span> <span class="n">rightmost</span> <span class="n">alphanumeric</span> <span class="p">(</span><span class="ow">or</span> <span class="n">the</span>
</span><span class='line'><span class="n">rightmost</span> <span class="n">character</span> <span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">alphanumerics</span><span class="p">)</span> <span class="k">in</span> <span class="n">the</span> <span class="n">string</span><span class="o">.</span> <span class="no">Incrementing</span>
</span><span class='line'><span class="n">a</span> <span class="n">digit</span> <span class="n">always</span> <span class="n">results</span> <span class="k">in</span> <span class="n">another</span> <span class="n">digit</span><span class="p">,</span> <span class="ow">and</span> <span class="n">incrementing</span> <span class="n">a</span> <span class="n">letter</span> <span class="n">results</span> <span class="k">in</span>
</span><span class='line'><span class="n">another</span> <span class="n">letter</span> <span class="n">of</span> <span class="n">the</span> <span class="n">same</span> <span class="k">case</span><span class="o">.</span> <span class="no">Incrementing</span> <span class="n">nonalphanumerics</span> <span class="n">uses</span> <span class="n">the</span>
</span><span class='line'><span class="n">underlying</span> <span class="n">character</span> <span class="n">set</span><span class="s1">&#39;s collating sequence.</span>
</span><span class='line'>
</span><span class='line'><span class="s1">If the increment generates a ``carry,&#39;</span><span class="err">&#39;</span> <span class="n">the</span> <span class="n">character</span> <span class="n">to</span> <span class="n">the</span> <span class="n">left</span> <span class="n">of</span> <span class="n">it</span> <span class="n">is</span>
</span><span class='line'><span class="n">incremented</span><span class="o">.</span> <span class="no">This</span> <span class="n">process</span> <span class="n">repeats</span> <span class="k">until</span> <span class="n">there</span> <span class="n">is</span> <span class="n">no</span> <span class="n">carry</span><span class="p">,</span> <span class="n">adding</span> <span class="n">an</span>
</span><span class='line'><span class="n">additional</span> <span class="n">character</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'>  <span class="s2">&quot;abcd&quot;</span><span class="o">.</span><span class="n">succ</span>        <span class="c1">#=&gt; &quot;abce&quot;</span>
</span><span class='line'>  <span class="s2">&quot;THX1138&quot;</span><span class="o">.</span><span class="n">succ</span>     <span class="c1">#=&gt; &quot;THX1139&quot;</span>
</span><span class='line'>  <span class="s2">&quot;&lt;&lt;koala&gt;&gt;&quot;</span><span class="o">.</span><span class="n">succ</span>   <span class="c1">#=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;</span>
</span><span class='line'>  <span class="s2">&quot;1999zzz&quot;</span><span class="o">.</span><span class="n">succ</span>     <span class="c1">#=&gt; &quot;2000aaa&quot;</span>
</span><span class='line'>  <span class="s2">&quot;ZZZ9999&quot;</span><span class="o">.</span><span class="n">succ</span>     <span class="c1">#=&gt; &quot;AAAA0000&quot;</span>
</span><span class='line'>  <span class="s2">&quot;***&quot;</span><span class="o">.</span><span class="n">succ</span>         <span class="c1">#=&gt; &quot;**+&quot;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">END</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>Range</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">triplica</span> <span class="o">=</span> <span class="s2">&quot;AAA&quot;</span><span class="o">.</span><span class="n">.</span><span class="s2">&quot;ZZZ&quot;</span>
</span><span class='line'><span class="n">triplica</span><span class="o">.</span><span class="n">include?</span> <span class="s2">&quot;ABC&quot;</span> <span class="c1"># verdade, rápido em 1.8 e lento em 1.9</span>
</span><span class='line'><span class="n">triplica</span><span class="o">.</span><span class="n">include?</span> <span class="s2">&quot;ABCD&quot;</span> <span class="c1"># verdadeira em 1.8, false em 1.9</span>
</span><span class='line'><span class="n">triplica</span><span class="o">.</span><span class="n">cover?</span> <span class="s2">&quot;ABCD&quot;</span> <span class="c1"># verdadeiro e rápido em 1.9</span>
</span><span class='line'><span class="n">triplica</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">include?</span> <span class="s2">&quot;ABCD&quot;</span> <span class="c1"># false e lento em 1.8 e 1.9</span>
</span></code></pre></td></tr></table></div></figure>


<p>Na prática, a maioria dos Ranges têm pontos de extremidade numéricos, e o Range de mudanças na API entre Ruby 1.8
e 1.9 têm pouco impacto.</p>

<p>É isso ai, até a proxima&#8230; :D</p>

<p>E bons estudos..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ranges - Ruby 1.9.2 - Part I ]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/13/ranges-ruby-1-dot-9-2-part-i/"/>
    <updated>2012-05-13T02:16:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/13/ranges-ruby-1-dot-9-2-part-i</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>




<p>Hoje vamos falar um pouco de Range, é hora de nos aprofundar.</p>




<h2>Ranges</h2>


<p>Um objeto Range representa os valores entre um valor de início e um valor final. Range literais são escritas pela colocação de dois ou três pontos entre o início e o valor fim. Se dois pontos são usados, então o intervalo é inclusivo e o valor final é parte do intervalo. Se três pontos são usados, então o intervalo é exclusiva e o valor final não é parte do range:</p>

<figure class='code'><figcaption><span>Range</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span> <span class="c1"># Os números inteiros de 1 a 10, incluindo 10</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="mi">10</span> <span class="c1"># Os números entre 1 e 10, excluindo-se 10</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testar se um valor está incluído em um intervalo com o método include? (mas ver abaixo para uma discussão de alternativas):</p>

<figure class='code'><figcaption><span>Range</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">cold_war</span> <span class="o">=</span> <span class="mi">1945</span> <span class="o">.</span><span class="n">.</span> <span class="mi">1989</span>
</span><span class='line'><span class="n">cold_war</span><span class="o">.</span><span class="n">include?</span> <span class="no">DateTime</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">year</span>
</span></code></pre></td></tr></table></div></figure>


<p>O que esta implícita na definição de um intervalo é a noção de ordem. Se um intervalo são os valores entre dois pontos,
há, obviamente, deve ser alguma forma para comparar os valores para os pontos de extremidade. Em Ruby, isso é feito
com o operador de comparação &lt;=>, que compara seus dois operandos e avalia a -1, 0 ou 1, dependendo da sua ordem relativa
(ou igualdade). Classes, tais como números e strings que têm uma ordenação definir o operador &lt;=>. o
valor só pode ser utilizado como um ponto de extremidade do intervalo se ele responde a esta
operador. Os pontos de extremidade de um intervalo e os valores &#8220;em&#8221; range são
tipicamente, todos da mesma classe. Tecnicamente, no entanto, qualquer valor que é
compatível com o &lt;=> operador do ponto da extremidade do range pode ser considerado um membro do intervalo.</p>

<p>O objetivo primário para os ranges é comparação: para ser capaz de determinar se um valor está dentro ou fora do range. Um importante
objetivo secundário é a iteração: se a classe dos parâmetros de um range definido um método succ (por sucessor), então existe um conjunto discreto de membros de intervalo, e eles podem
ser repetido a cada passo, e métodos de Enumerable. Considere o intervalo &#8216;A&#8217; .. &#8216;c&#8217;, por exemplo:</p>

<figure class='code'><figcaption><span>Range</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">r</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span> <span class="o">.</span><span class="n">.</span> <span class="s1">&#39;c&#39;</span>
</span><span class='line'><span class="n">r</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">l</span><span class="o">|</span> <span class="nb">print</span> <span class="s2">&quot;[</span><span class="si">#{</span><span class="n">l</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">}</span> <span class="c1"># imprime &quot;[a] [b] [c]&quot;</span>
</span><span class='line'><span class="n">r</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">l</span><span class="o">|</span> <span class="nb">print</span> <span class="s2">&quot;[</span><span class="si">#{</span><span class="n">l</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">}</span> <span class="c1"># imprime &quot;[a] [c]&quot;</span>
</span><span class='line'><span class="n">r</span><span class="o">.</span><span class="n">to_a</span> <span class="c1"># =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]: Enumerable define to_a</span>
</span></code></pre></td></tr></table></div></figure>


<p>A razão pela qual isto funciona é que a classe String define um método succ e &#8216;a&#8217;.succ é &#8216;b&#8217; e &#8216;b&#8217;.succ é &#8216;c&#8217;. Intervalos que
podem ser iterados como este, são intervalos discretos. Faixas cuja ponto final não definem um método succ não pode ser iterada,
e assim eles podem ser chamadas de contínua. Note-se que os intervalos com terminais inteiros são discretos, mas números de ponto flutuante como ponto final são contínuas.</p>

<p>Faixas com terminais inteiros são os mais comuns de serem usados ​​em programas típicos de Ruby. Porque eles são discretos, os ranges inteiros podem sasurusados para cordas de índice e matrizes. Eles são também uma forma conveniente para
representam uma coleção enumerável de valores ascendentes. Observe que o código atribui um range literal a uma variável, e
em seguida, chama métodos no intervalo através da variável. Se você quiser ou
invocar diretamente em uma ampla literal, você deve colocar parênteses o literal, ou a invocação do método é na verdade sobre o ponto final da variavel, em vez de o objecto range em si:</p>

<figure class='code'><figcaption><span>Range</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span> <span class="o">.</span><span class="n">.</span> <span class="mi">3</span><span class="o">.</span><span class="n">to_a</span> <span class="c1"># tenta chamar to_a sobre o número 3</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span> <span class="o">.</span><span class="n">.</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span> <span class="no">To_a</span> <span class="c1"># =&gt; [1,2,3]</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Até a proxima!!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte III - Hashs Codes]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/10/o-mundo-hash-no-ruby-1-dot-9-2-parte-iii-hashs-codes/"/>
    <updated>2012-05-10T13:01:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/10/o-mundo-hash-no-ruby-1-dot-9-2-parte-iii-hashs-codes</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Hoje vamos falar um pouco mais de Hash, é hora de nos aprofundar.</p>




<h3>Códigos de Hash, Igualdade e mutáveis ​​Chaves</h3>


<p>Hashs[1] de Ruby são implementadas, sem surpresa, com um conjunto de dados de
estrutura conhecida como uma tabela hash. Objetos usados como chaves em um hash deve ter um método chamado de hash que retorna <a href="http://www.ruby-doc.org/core-1.9.2/Fixnum.html">Fixnum</a> hashcode para a chave. Se duas chaves são iguais, elas devem ter o mesmo
hashcode. Chaves desiguais também pode ter a mesma hashcode, mas hash&#8217;s de tabelas são mais eficientes quando hashcodes duplicados são raros.</p>

<p>A classe Hash compara chaves igualdade com o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-eql-3F">eql?</a>. Para
outras classes Ruby, eql? obras como o operador == . Se você definir uma nova classe que
substitui o método eql?, você deve também substituir o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-hash">hash</a>, ou se não as instâncias de sua classe não vam funcionar como chaves em um hash.</p>

<p>Se você definir uma classe e não sobreescrever o método eql?, em seguida, as instâncias dessa classe são
comparadas com a identidade do objeto quando usado como chave de hash. Duas instâncias distintas de sua classe são distintas chaves de hash mesmo que eles representam o mesmo conteúdo. Neste caso, o método padrão hash é apropriado: retorna a única object_id do objeto.</p>

<p>Note-se que objetos mutáveis ​​são problemáticos como chaves de hash. Mudar o conteúdo de um objeto geralmente muda seu hashcode. Se você usar um objeto como uma chave e então alterar esse objeto, a tabela de hash ficará corrompida, e o hash não funciona corretamente.</p>

<p>Porque strings são mutáveis, mas comumente usamos chaves de hash, Ruby trata eles como um caso especial e faz cópias privadas de todas as cadeias utilizadas como chaves. Este é o único caso especial, no entanto, você deve ser muito cuidado ao usar qualquer outro objeto mutável como uma chave hash. Considera fazendo uma cópia privada ou chamando o método <a href="http://ruby-doc.org/core-1.9.2/Object.html#method-i-freeze">freeze</a>.
Se você deve usar chaves de hash mutável, chame o método <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html#method-i-rehash">rehash</a> do Hash cada vez que você alterar uma chave.</p>

<p>-> <a href="http://www.ruby-doc.org/core-1.9.2/Hash.html">Hash</a></p>

<p>Até a proxima!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O Mundo Hash no Ruby 1.9.2 - Parte II - Hashs Literais]]></title>
    <link href="http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2-parte-ii-hashs-literais/"/>
    <updated>2012-05-08T22:28:00-03:00</updated>
    <id>http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2-parte-ii-hashs-literais</id>
    <content type="html"><![CDATA[<p>Continuando os estudos de Ruby, e a leitura do livro The Ruby Programming Language</p>


<p>Na primeira parte eu fiz uma introdução do Hash:
-> <a href="http://rrmartins.github.com/blog/2012/05/08/o-mundo-hash-no-ruby-1-dot-9-2/">O Mundo Hash no Ruby 1.9.2 - Parte I</a></p>

<p>Vamos lá!</p>

<p>Um literal de hash é escrita como uma lista separada por vírgulas de chave/valor de
pares, colocados dentro de chaves. Chaves e valores são separados
com um caractere de dois &#8220;arrow&#8221;: &#8216;=>&#8217;. O objeto Hash criado anteriormente também pode ser
criado com o literal seguinte:</p>

<!--more-->




<figure class='code'><figcaption><span>Hash Literal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span><span class="err">ú</span><span class="n">meros</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;um&quot;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;dois&quot;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;três&quot;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Em geral, objetos <a href="http://www.ruby-doc.org/core-1.9.2/Symbol.html">Símbolos</a> trabalham mais eficientemente como chaves de hash de strings, fazem assim:</p>

<figure class='code'><figcaption><span>Hash Literal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span><span class="err">ú</span><span class="n">meros</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:um</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span><span class="ss">:dois</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span><span class="ss">:tr</span><span class="err">ê</span><span class="n">s</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Os <a href="http://www.ruby-doc.org/core-1.9.2/Symbol.html">Símbolos</a> são imutáveis, escrito como
prefixados identificadores, que serão explicados em maior detalhe em um outro post.</p>

<p>Ruby 1.8 permite vírgulas em lugar de setas, mas isso não teve a sintaxe substituída, mais suportado no Ruby 1.9:</p>

<figure class='code'><figcaption><span>Hash Literal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="n">numeros</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:um</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:dois</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">:tres</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="c1"># Igual, mas mais difícil de ler</span>
</span></code></pre></td></tr></table></div></figure>


<p>Tanto Ruby 1.8 quanto no Ruby 1.9 permite uma única vírgula à direita do
final da lista de chave / valor:</p>

<figure class='code'><figcaption><span>Hash Literal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span><span class="err">ú</span><span class="n">meros</span> <span class="o">=</span> <span class="p">{:</span> <span class="n">um</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,:</span> <span class="n">dois</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span> <span class="c1"># vírgula extra ignorado</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ruby 1.9 suporta muito útil e sucinto a sintaxe literal de Hash
quando as chaves são símbolos. Neste caso, move-se para o fim da chave de hash e substitui a seta:</p>

<figure class='code'><figcaption><span>Hash Literal</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span><span class="err">ú</span><span class="n">meros</span> <span class="o">=</span> <span class="p">{</span><span class="n">um</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dois</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tres</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note-se que pode não haver qualquer espaço entre a chave Hash
identificador e dos dois pontos.</p>

<p>Até breve!</p>
]]></content>
  </entry>
  
</feed>
