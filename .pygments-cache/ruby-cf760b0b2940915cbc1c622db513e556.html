<div class="highlight"><pre><span class="c1"># Define um alias corrente Module.synchronize_method de métodos de instância</span>
<span class="c1"># Assim que sincronizar a instância antes da execução.</span>
<span class="k">class</span> <span class="nc">Module</span>
<span class="err">  </span><span class="c1"># Esta é uma função auxiliar para o encadeamento alias.</span>
<span class="err">  </span><span class="c1"># Dado o nome de um método (como uma string ou símbolo) e um prefixo, cria</span>
<span class="err">  </span><span class="c1"># Um alias exclusivo para o método, e retornar o nome do alias</span>
<span class="err">  </span><span class="c1"># Como um símbolo. Quaisquer caracteres de pontuação em nome método original</span>
<span class="err">  </span><span class="c1"># Serão convertidos em números para que os operadores podem ser alias.</span>
<span class="err">  </span><span class="k">def</span> <span class="nf">create_alias</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;alias&quot;</span><span class="p">)</span>
<span class="err">    </span><span class="c1"># Cole o prefixo do nome original e converter pontuação</span>
<span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">#{</span><span class="n">original</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">aka</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span><span class="sr">/([\=\|\&amp;\+\-\*\/\^\!\?\~\%\&lt;\&gt;\[\]])/</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">num</span> <span class="o">=</span> <span class="vg">$1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>                       <span class="c1"># Ruby 1.8 character -&gt; ordinal</span>
      <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">ord</span> <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">is_a?</span> <span class="nb">String</span> <span class="c1"># Ruby 1.9 character -&gt; ordinal</span>
      <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">num</span><span class="o">.</span><span class="n">to_s</span>
    <span class="p">}</span>
<span class="err">    </span>
<span class="err">    </span><span class="c1"># Mantenha acrescentando ressalta até chegarmos a um nome que não está em uso</span>
<span class="err">    </span><span class="n">aka</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="k">while</span> <span class="nb">method_defined?</span> <span class="n">aka</span> <span class="ow">or</span> <span class="nb">private_method_defined?</span> <span class="n">aka</span>

<span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="n">aka</span><span class="o">.</span><span class="n">to_sym</span>           <span class="c1"># Converter o nome de alias de um símbolo</span>
<span class="err">    </span><span class="n">alias_method</span> <span class="n">aka</span><span class="p">,</span> <span class="n">original</span> <span class="c1"># Na verdade criar o alias</span>
<span class="err">    </span><span class="n">aka</span> 											 <span class="c1"># Retorna o nome do alias</span>
<span class="err">  </span><span class="k">end</span>

<span class="err">  </span><span class="c1"># Alias correntam o método nomeado para adicionar sincronização</span>
<span class="err">  </span><span class="k">def</span> <span class="nf">synchronize_method</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="err">    </span><span class="c1"># Primeiro, fazemos um alias para a versão dessincronizado do método.</span>
<span class="err">    </span><span class="n">aka</span> <span class="o">=</span> <span class="n">create_alias</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;unsync&quot;</span><span class="p">)</span>
<span class="err">    </span><span class="c1"># Agora redefini o original para invocar o alias em um bloco sincronizado.</span>
<span class="err">    </span><span class="c1"># Queremos o método definido como sendo capaz de aceitar os blocos, de modo que</span>
<span class="err">    </span><span class="c1"># Não pode usar define_method, e deve avaliar vez uma string com</span>
<span class="err">    </span><span class="c1"># Class_eval. Note-se que tudo entre% Q {} e da correspondência</span>
<span class="err">    </span><span class="c1"># É uma string entre aspas, e não um bloco.</span>
<span class="err">    </span><span class="nb">class_eval</span> <span class="sx">%Q{</span>
<span class="sx">      def </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(*args, &amp;block)</span>
<span class="sx">        synchronized(self) { </span><span class="si">#{</span><span class="n">aka</span><span class="si">}</span><span class="sx">(*args, &amp;block) }</span>
<span class="sx">      end</span>
<span class="sx">    }</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Este método global sincronizado agora pode ser usado de três maneiras diferentes.</span>
<span class="k">def</span> <span class="nf">synchronized</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="err">  </span><span class="c1"># Caso 1: com um argumento e um bloco, sincronizar sobre o objeto</span>
<span class="err">  </span><span class="c1"># E executar o bloco</span>
	<span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nb">block_given?</span>
    <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">mutex</span><span class="o">.</span><span class="n">synchronize</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>

<span class="err">  </span><span class="c1"># Caso dois: com um argumento que não é um símbolo e nenhum bloco</span>
<span class="err">  </span><span class="c1"># Devolve um invólucro de SynchronizedObject</span>
<span class="err">  </span><span class="k">elsif</span> <span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">is_a?</span> <span class="no">Symbol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">block_given?</span>
    <span class="no">SynchronizedObject</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span>

<span class="err">  </span><span class="c1"># Caso três: quando invocado em um módulo com nenhum bloco, alias a cadeia</span>
<span class="err">  </span><span class="c1"># Chamado métodos para adicionar sincronização. Ou, se não há argumentos,</span>
<span class="err">  </span><span class="c1"># Então apelido acorrentam o próximo método definido.</span>
<span class="err">  </span><span class="k">elsif</span> <span class="nb">self</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Module</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">block_given?</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Synchronize the named methods</span>
      <span class="n">args</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="nb">self</span><span class="o">.</span><span class="n">synchronize_method</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">else</span>
<span class="err">      </span><span class="c1"># Se nenhum método é especificado pelo synchronize o método seguinte define</span>
<span class="err">      </span><span class="n">eigenclass</span> <span class="o">=</span> <span class="n">class</span><span class="o">&lt;&lt;</span><span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>
      <span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span> <span class="c1"># Use eigenclass para definir métodos de classe</span>
<span class="err">        </span><span class="c1"># Define method_added para notificação quando próximo método é definido</span>
<span class="err">        </span><span class="n">define_method</span> <span class="ss">:method_added</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
<span class="err">          </span><span class="c1"># Primeiro remover esse método hook</span>
<span class="err">          </span><span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="p">{</span> <span class="n">remove_method</span> <span class="ss">:method_added</span> <span class="p">}</span>
<span class="err">          </span><span class="c1"># Em seguida, sincronize o método que acabou de ser adicionado</span>
<span class="err">          </span><span class="nb">self</span><span class="o">.</span><span class="n">synchronize_method</span> <span class="nb">name</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>

<span class="err">  </span><span class="c1"># Caso 4: qualquer outra invocação é um erro</span>
<span class="err">  </span><span class="k">else</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;Invalid arguments to synchronize()&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
