<div class="highlight"><pre><span class="c1"># Definimos este módulo para manter o estado global do require, de modo que</span>
<span class="c1"># Nós não alteramos o espaço global mais do que o necessário.</span>
<span class="k">module</span> <span class="nn">ClassTrace</span>
<span class="err">  </span> <span class="c1"># Esta matriz mantém a nossa lista de arquivos carregados e classes definidas.</span>
<span class="err">  </span> <span class="c1"># Cada elemento é um subarray segurando a classe definida ou o</span>
<span class="err">  </span> <span class="c1"># Arquivo carregado e o quadro de pilha onde ele foi definido ou carregado.</span>
<span class="err">  </span> <span class="n">T</span> <span class="o">=</span> <span class="o">[]</span>  <span class="c1"># Array para armazenar os arquivos carregados</span>

<span class="err">  </span> <span class="c1"># Agora defini a constante OUT para especificar onde saída do rastreamento vai.</span>
<span class="err">  </span> <span class="c1"># O padrão é stderr, mas também pode vir a partir de argumentos na linha de comando</span>
<span class="err">  </span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;--traceout&quot;</span><span class="p">)</span>    <span class="c1"># Se existe argumento</span>
<span class="err">    </span> <span class="no">OUT</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>  <span class="c1"># Abre o arquivo especificado</span>
<span class="err">    </span> <span class="no">ARGV</span><span class="o">[</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="kp">nil</span>                  <span class="c1"># E remova os argumentos</span>
<span class="err">  </span> <span class="k">else</span>
<span class="err">    </span> <span class="no">OUT</span> <span class="o">=</span> <span class="no">STDERR</span>                     <span class="c1"># Caso contrário, o padrão para STDERR</span>
<span class="err">  </span> <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Passo 1 encadeamento Alias: definir aliases para os métodos originais</span>
<span class="k">alias</span> <span class="n">original_require</span> <span class="nb">require</span>
<span class="k">alias</span> <span class="n">original_load</span> <span class="nb">load</span>

<span class="c1"># Passo 2 encadeamento Alias 2: definir novas versões dos métodos</span>
<span class="k">def</span> <span class="nf">require</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
<span class="err">  </span><span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">file</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>     <span class="c1"># Lembre-se de onde que estava carregado</span>
<span class="err">  </span><span class="n">original_require</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>                <span class="c1"># Chame o método original</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="err"> </span> <span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>  <span class="c1"># Lembre-se de onde que estava carregado</span>
<span class="err"> </span> <span class="n">original_load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>                  <span class="c1"># Chame o método original</span>
<span class="k">end</span>

<span class="c1"># Este método hook é chamado de cada vez que uma nova classe é definida</span>
<span class="k">def</span> <span class="nc">Object</span><span class="o">.</span><span class="nf">inherited</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="err">  </span><span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">c</span><span class="p">,</span><span class="nb">caller</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>        <span class="c1"># Lembre-se onde que foi definido</span>
<span class="k">end</span>

<span class="c1"># Kernel.at_exit registra um bloco a ser executado quando o programa sai</span>
<span class="c1"># Vamos utilizá-lo para comunicar os dados de arquivo e de classe que recolhemos</span>
<span class="nb">at_exit</span> <span class="p">{</span>
  <span class="n">o</span> <span class="o">=</span> <span class="no">ClassTrace</span><span class="o">::</span><span class="no">OUT</span>
  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">60</span>
  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Files Loaded and Classes Defined:&quot;</span>
  <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">60</span>
  <span class="no">ClassTrace</span><span class="o">::</span><span class="n">T</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">what</span><span class="p">,</span><span class="n">where</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">what</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">Class</span>  <span class="c1"># Report class (with hierarchy) defined</span>
      <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Defined: </span><span class="si">#{</span><span class="n">what</span><span class="o">.</span><span class="n">ancestors</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;&lt;-&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="n">where</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span>                 <span class="c1"># Report file loaded</span>
      <span class="n">o</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Loaded: </span><span class="si">#{</span><span class="n">what</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="n">where</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="p">}</span>
</pre>
</div>
