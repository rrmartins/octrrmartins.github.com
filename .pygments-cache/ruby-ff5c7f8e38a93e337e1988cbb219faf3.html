<div class="highlight"><pre><span class="c1"># Define métodos trace! e untrace! de instância para todos os objetos.</span>
<span class="c1"># trace! &quot;Cadeias&quot; os métodos chamados por definir métodos singleton</span>
<span class="c1"># Que adiciona a funcionalidade de rastreamento e use super para chamar o original.</span>
<span class="c1"># untrace! exclui os métodos singleton para remover o rastreamento.</span>
<span class="n">classe</span> <span class="no">Object</span>
<span class="err">  </span><span class="c1"># os métodos trace especificados, enviando a saída para STDERR.</span>
<span class="err">  </span><span class="k">def</span> <span class="nf">trace!</span><span class="p">(</span><span class="o">*</span><span class="nb">methods</span><span class="p">)</span>
    <span class="vi">@_traced</span> <span class="o">=</span> <span class="vi">@_traced</span> <span class="o">||</span> <span class="o">[]</span>    <span class="c1"># Lembre-se o conjunto de métodos traçados</span>

<span class="err">    </span><span class="c1"># Se nenhum método foi especificado, use todos os métodos públicos definidos</span>
<span class="err">    </span><span class="c1"># Diretamente (não herdado) pela classe deste objeto</span>
<span class="err">    </span><span class="nb">methods</span> <span class="o">=</span> <span class="nb">public_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nb">methods</span><span class="o">.</span><span class="n">map!</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">to_sym</span> <span class="p">}</span>	<span class="c1"># Converta qualquer cordas para símbolos</span>
<span class="err">    </span><span class="nb">methods</span> <span class="o">-=</span> <span class="vi">@_traced</span> 					<span class="c1"># remove métodos que já estão traçadas</span>
<span class="err">    </span><span class="k">return</span> <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">empty?</span>     	<span class="c1"># Voltar mais cedo se não há nada a fazer</span>
<span class="err">    </span><span class="vi">@_traced</span> <span class="o">|=</span> <span class="nb">methods</span>           <span class="c1"># Adiciona métodos para definir métodos de traçados</span>

<span class="err">    </span><span class="c1"># Trace o fato de que estamos começando a traçar estes métodos</span>
<span class="err">    </span><span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Tracing </span><span class="si">#{</span><span class="nb">methods</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>

		<span class="c1"># Singleton métodos são definidos na eigenclass</span>
    <span class="n">eigenclass</span> <span class="o">=</span> <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span>

		<span class="nb">methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="c1"># Para cada método m</span>
<span class="err">      </span><span class="c1"># Define uma versão trace singleton do método m.</span>
<span class="err">      </span><span class="c1"># Saída de informações de rastreamento e usar super para invocar o</span>
<span class="err">      </span><span class="c1"># Método de instância que é o rastreamento.</span>
<span class="err">      </span><span class="c1"># Queremos que os métodos definidos para ser capaz de aceitar blocos, de modo que</span>
<span class="err">      </span><span class="c1"># Não pode usar define_method, e deve avaliar, em vez de uma string.</span>
<span class="err">      </span><span class="c1"># Note que tudo entre %Q{} e a correspondência é uma</span>
<span class="err">      </span><span class="c1"># Entre aspas de string, não um bloco. Observe também que há</span>
<span class="err">      </span><span class="c1"># Dois níveis de interpolações de string aqui. # {} É interpolada</span>
<span class="err">      </span><span class="c1"># Quando o método singleton é definida. E \ # {} é interpolada</span>
<span class="err">      </span><span class="c1"># Quando o método singleton é invocado.</span>
<span class="err">      </span><span class="n">eigenclass</span><span class="o">.</span><span class="n">class_eval</span> <span class="sx">%Q{</span>
<span class="sx">        def </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(*args, &amp;block)</span>
<span class="sx">          begin</span>
<span class="sx">            STDERR &lt;&lt; &quot;Entering: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">(</span><span class="se">\#</span><span class="sx">{args.join(&#39;, &#39;)})</span><span class="se">\n</span><span class="sx">&quot;</span>
<span class="sx">            result = super</span>
<span class="sx">            STDERR &lt;&lt; &quot;Exiting: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx"> with </span><span class="se">\#</span><span class="sx">{result}</span><span class="se">\n</span><span class="sx">&quot;</span>
<span class="sx">            result</span>
<span class="sx">          rescue</span>
<span class="sx">            STDERR &lt;&lt; &quot;Aborting: </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="sx">: </span><span class="se">\#</span><span class="sx">{$!.class}: </span><span class="se">\#</span><span class="sx">{$!.message}&quot;</span>
<span class="sx">            raise</span>
<span class="sx">          end</span>
<span class="sx">        end</span>
<span class="sx">      }</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="err">  </span><span class="c1"># Untrace os métodos especificados ou todos os métodos rastreados</span>
	<span class="k">def</span> <span class="nf">untrace!</span><span class="p">(</span><span class="o">*</span><span class="nb">methods</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">methods</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>    <span class="c1"># Se nenhuma métodos especificados untrace</span>
      <span class="nb">methods</span> <span class="o">=</span> <span class="vi">@_traced</span>    <span class="c1"># todos os métodos atualmente rastreados</span>
      <span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Untracing all methods on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">else</span>                    <span class="c1"># Caso contrário, untrace</span>
      <span class="nb">methods</span><span class="o">.</span><span class="n">map!</span> <span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">m</span><span class="o">.</span><span class="n">to_sym</span> <span class="p">}</span>  <span class="c1"># Converter string para símbolos</span>
      <span class="nb">methods</span> <span class="o">&amp;=</span> <span class="vi">@_traced</span>   <span class="c1"># todos os métodos especificados que são rastreados</span>
      <span class="no">STDERR</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Untracing </span><span class="si">#{</span><span class="nb">methods</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> on </span><span class="si">#{</span><span class="nb">object_id</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">end</span>

		<span class="vi">@_traced</span> <span class="o">-=</span> <span class="nb">methods</span>     <span class="c1"># Retire-os do nosso conjunto de métodos de traçados</span>

		<span class="c1"># Remove os métodos traçados únicos do eigenclass</span>
		<span class="c1"># Note que nós class_eval um bloco aqui, não uma string</span>
		<span class="p">(</span><span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">;</span> <span class="k">end</span><span class="p">)</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
		  <span class="nb">methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
		    <span class="n">remove_method</span> <span class="n">m</span>     <span class="c1"># undef_method não funciona corretamente</span>
		  <span class="k">end</span>
		<span class="k">end</span>

		<span class="c1"># Se nenhum método são traçados mais, remover o nosso exemplo var</span>
		<span class="k">if</span> <span class="vi">@_traced</span><span class="o">.</span><span class="n">empty?</span>
		  <span class="n">remove_instance_variable</span> <span class="ss">:@_traced</span>
		<span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>
